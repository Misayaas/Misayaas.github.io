<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favcion.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"misayaas.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万头攒动，火树银花之处不必寻我">
<meta property="og:type" content="website">
<meta property="og:title" content="Misayaas">
<meta property="og:url" content="https://misayaas.github.io/index.html">
<meta property="og:site_name" content="Misayaas">
<meta property="og:description" content="万头攒动，火树银花之处不必寻我">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="花花花铃">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://misayaas.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Misayaas</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Misayaas</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/%20/%20fa%20fa-home" rel="section">首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="花花花铃"
      src="/images/avater.jpg">
  <p class="site-author-name" itemprop="name">花花花铃</p>
  <div class="site-description" itemprop="description">万头攒动，火树银花之处不必寻我</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%80%BB%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%80%BB%E7%BA%BF/" class="post-title-link" itemprop="url">总线</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-09 16:38:00 / 修改时间：16:38:30" itemprop="dateCreated datePublished" datetime="2023-12-09T16:38:00+08:00">2023-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机组织与结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>类型：</p>
<ol>
<li><p><strong>系统总线</strong>：连接CPU、存储器、I/O控制器和其他功能设备</p>
</li>
<li><p><strong>通信总线</strong>：连接主机和I/O设备，或连接不同的计算机系统</p>
</li>
</ol>
<p>设计要素：</p>
<ol>
<li><p><strong>用途</strong></p>
<ul>
<li>专用总线、复用总线</li>
</ul>
</li>
<li><p><strong>仲裁</strong></p>
<ul>
<li>集中式、分布式</li>
</ul>
</li>
<li><p><strong>时序</strong></p>
<ul>
<li>同步、异步、半同步、分离事务</li>
</ul>
</li>
<li><p><strong>总线带宽和数据传输速率</strong></p>
</li>
<li><p><strong>总线层次结构</strong></p>
<ul>
<li>单总线、双总线、多总线</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/1.png" alt=""></p>
<h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><ol>
<li><p><strong>数据线</strong>：在系统组件之间传输数据</p>
<ul>
<li>数据线的数量决定了<strong>一次可以传输的数据的大小</strong></li>
</ul>
</li>
<li><p><strong>地址线</strong>：在数据线和地址I/O端口上指定数据的来源和去向</p>
<ul>
<li>地址线的数量决定了<strong>寻址空间的大小</strong></li>
</ul>
</li>
<li><p><strong>控制线</strong>：控制对数据线和地址线的存取和使用</p>
<ul>
<li><p><strong>时钟</strong>：用于总线同步操作</p>
</li>
<li><p><strong>总线请求</strong>：表示模块需要获得对总线的控制</p>
</li>
<li><p><strong>总线允许</strong>：发出请求的设备已经被允许控制总线</p>
</li>
<li><p><strong>中断请求</strong>：表示某个中断正悬而未决</p>
</li>
<li><p><strong>中断响应</strong>：未决的中断请求被响应</p>
</li>
<li><p><strong>存储器读</strong>：从存储器读数据到总线</p>
</li>
<li><p><strong>存储器写</strong>：将数据从总线写入存储器</p>
</li>
<li><p><strong>I/O读</strong>：从I/O端口读数据到总线</p>
</li>
<li><p><strong>I/O写</strong>：将数据从总线写入I/O端口</p>
</li>
</ul>
</li>
</ol>
<p><strong>总线上数据传输的特点</strong>：</p>
<ol>
<li><p><u>总线可以被多个设备监听，但同一时刻只能由一个设备发送数据</u></p>
<ul>
<li><p>如果同一时刻多个设备同时发送数据，会造成数据之间的混淆</p>
</li>
<li><p><strong>总线被使用时，其他设备不能抢占</strong></p>
</li>
</ul>
</li>
<li><p>如果连在总线上的某个设备希望向另一个设备<strong>发送数据</strong>，需要：</p>
<ul>
<li><p><strong>获得总线的使用权</strong></p>
</li>
<li><p>通过总线传送数据</p>
</li>
</ul>
</li>
<li><p>如果连在总线上的某个设备希望向另一个组件<strong>请求数据</strong>，需要：</p>
<ul>
<li><p><strong>获得总线的使用权</strong></p>
</li>
<li><p>通过总线向另一个设备发送请求，等待另一个设备发送数据</p>
</li>
</ul>
</li>
</ol>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol>
<li><p><strong>专用总线</strong>：始终只负责一项功能，或始终分配给特定的计算机组件</p>
</li>
<li><p><strong>复用总线</strong>：将同一线路用于多种用途</p>
</li>
</ol>
<h2 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h2><p><strong>总线仲裁</strong>：当多个设备需要与总线通信时，通过某种策略选择一个设备</p>
<p><strong>平衡因素</strong>：</p>
<ul>
<li><p><strong>优先级</strong>：优先级高的设备优先被服务</p>
</li>
<li><p><strong>公平性</strong>：优先级最低的设备不能一直被延迟</p>
</li>
</ul>
<h3 id="仲裁方案"><a href="#仲裁方案" class="headerlink" title="仲裁方案"></a>仲裁方案</h3><ol>
<li><p><strong>集中式</strong>：由<strong>仲裁器或总线控制器</strong>负责分配总线使用权</p>
<ul>
<li><p>链式查询/菊花链</p>
</li>
<li><p>计数器查询</p>
</li>
<li><p>独立请求</p>
</li>
</ul>
</li>
<li><p><strong>分布式</strong>：每个设备都包含<strong>访问控制逻辑</strong>，各设备共同作用分享总线</p>
<ul>
<li><p>自举式</p>
</li>
<li><p>冲突检测</p>
</li>
</ul>
</li>
</ol>
<h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><p>所有的设备都是<strong>串行</strong>连接的，并允许信号从优先级最高的设备下发到优先级最低的设备</p>
<ul>
<li><p>总线仲裁器收到请求后，在<strong>总线不忙的前提</strong>下，发起允许信号</p>
</li>
<li><p>如果某个设备收到了允许信号并且发起了总线请求，该设备将总线设置为繁忙状态，允许信号将不再被进一步传递</p>
</li>
</ul>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQDhBhTTGPAJdgE_hbbynEIa6CCMIudgcwCSg&amp;usqp=CAU" alt="PPT - 第2 章总线与接口芯片PowerPoint Presentation, free download - ID:3756437"></p>
<p><strong>优点</strong>：</p>
<ol>
<li><p>确定优先级简单</p>
</li>
<li><p>可以灵活地添加设备</p>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>不能保证公平性</p>
</li>
<li><p>对电路故障敏感</p>
</li>
<li><p>限制总线的速度</p>
</li>
</ol>
<h4 id="计数器查询"><a href="#计数器查询" class="headerlink" title="计数器查询"></a>计数器查询</h4><p>将总线允许线替换为<strong>设备ID线</strong></p>
<ul>
<li><p>如果总线空闲，总线仲裁器通过设备ID线发送计数</p>
</li>
<li><p>如果当前发送请求的设备ID等于总线仲裁器当前的计数，中线仲裁器将停止计数，并将总线设置为忙</p>
</li>
</ul>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_kQ00J_TyusCmXWhsLEAdG32s1lrtf_-JYA&amp;usqp=CAU" alt="第3章系统总线| MyBlog - GxkOrd"></p>
<p><strong>优点</strong>：</p>
<ol>
<li><p>通过使用不同的初始计数，可以灵活确定设备优先级</p>
<ul>
<li><p>强调优先级：从1开始</p>
</li>
<li><p>强调公平性：从下一个设备的ID开始</p>
</li>
</ul>
</li>
<li><p>对电路故障不敏感</p>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>需要添加设备ID线</p>
</li>
<li><p>需要解码和比较设备ID信号</p>
</li>
<li><p>限制总线的速度</p>
</li>
</ol>
<h4 id="独立请求"><a href="#独立请求" class="headerlink" title="独立请求"></a>独立请求</h4><p>每个设备都有自己的总线请求线和总线允许线，且<strong>直接连接到总线仲裁器</strong></p>
<ul>
<li><p>当一个设备请求总线时，它通过总线请求线将请求信号发送给总线仲裁器</p>
</li>
<li><p>总线仲裁器决定哪个设备可以使用总线</p>
<ul>
<li>固定优先级、公平链式、LRU、FIFO、$\cdots$</li>
</ul>
</li>
</ul>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQZHfjMosF4rzF7YdqHtDC8Ho2OHSvD5rxdKA&amp;usqp=CAU" alt="了解计算机系统的总线- 墨天轮"></p>
<p><strong>优点</strong>：</p>
<ol>
<li><p>快速响应</p>
</li>
<li><p>可编程的优先级</p>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>复杂的控制逻辑</p>
</li>
<li><p>更多的控制线路</p>
</li>
</ol>
<h4 id="自举式"><a href="#自举式" class="headerlink" title="自举式"></a>自举式</h4><p>每个设备在其总线请求线上发送请求，<strong>固定优先级</strong>，自行判断自己是否在请求总线地设备中优先级最高</p>
<ul>
<li><p><strong>最低优先级的设备没有请求线</strong></p>
</li>
<li><p>箭头最少的优先级最高</p>
</li>
</ul>
<h4 id="冲突检测法"><a href="#冲突检测法" class="headerlink" title="冲突检测法"></a>冲突检测法</h4><p><strong>冲突</strong>：如果两个设备发现总线空闲，它们可能同时使用总线</p>
<ul>
<li><p>在传输数据时，设备会监听总线，检查是否存在冲突</p>
</li>
<li><p>如果发生冲突，所有使用总线的设备将停止数据传输，并分别在<strong>随机间隔时间</strong>后再次请求总线</p>
</li>
</ul>
<h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><p>确定每个总线事物的开始和结束时间</p>
<ul>
<li><strong>总线事务</strong>：地址 + 数据 + $\cdots$ + 数据</li>
</ul>
<p>类型：<u>同步时序、异步时序、半同步、分离事物</u></p>
<h3 id="同步时序"><a href="#同步时序" class="headerlink" title="同步时序"></a>同步时序</h3><p>时间的发生由始终决定</p>
<p><strong>优点</strong>：</p>
<ol>
<li>更容易实现和测试</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>所有设备共享一个时钟</p>
</li>
<li><p>总线长度受到时钟偏差的限制</p>
<ul>
<li><strong>同步总线很短，不然会出现时钟混乱</strong></li>
</ul>
</li>
<li><p>数据过长会导致不同步，造成问题</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/8.png" alt=""></p>
<h3 id="异步时序"><a href="#异步时序" class="headerlink" title="异步时序"></a>异步时序</h3><p>一个时间的发生取决于前一个事件的发生</p>
<p>分为<u>非互锁、半互锁、全互锁</u>三个阶段（使用<strong>握手规则</strong>）</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/12.png" alt=""></p>
<ul>
<li><p>蓝色表示先后关系，也就是“一次握手”</p>
</li>
<li><p><strong>非互锁（第一次握手）</strong>：我告诉你我准备好了</p>
</li>
<li><p><strong>半互锁（第二次握手）</strong>：我告诉你我已经收到了</p>
<ul>
<li>“我准备好了”信号只能在你说“我收到了”之后才能撤回</li>
</ul>
</li>
<li><p><strong>全互锁（第三次握手）</strong>：我知道了你知道“收到了”之后才能撤回</p>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ol>
<li>可以灵活地协调速度不同的设备</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>接口逻辑复杂</p>
</li>
<li><p>对噪声敏感</p>
</li>
</ol>
<h4 id="异步数据传输"><a href="#异步数据传输" class="headerlink" title="异步数据传输"></a>异步数据传输</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/9.png" alt=""></p>
<ol>
<li><p>CPU设置地址并设置<strong>ReadReq线</strong></p>
<ul>
<li><u>存储器读取相应地址</u></li>
</ul>
</li>
<li><p>存储器读取相应地址并设置<strong>Ack线</strong></p>
<ul>
<li><u>CPU释放地址线和ReadReq线</u></li>
</ul>
</li>
<li><p>CPU释放地址线和<strong>ReadReq线</strong></p>
<ul>
<li><u>存储器释放Ack线</u></li>
</ul>
</li>
<li><p>存储器释放<strong>Ack线</strong></p>
<ul>
<li>存储器将数据传到数据线</li>
</ul>
</li>
<li><p>存储器将数据传到数据线并设置<strong>DataRdy线</strong></p>
<ul>
<li><u>CPU读取数据</u></li>
</ul>
</li>
<li><p>CPU读取数据并设置<strong>Ack线</strong></p>
<ul>
<li><u>存储器释放数据线和DataRdy线</u></li>
</ul>
</li>
<li><p>存储器释放数据线和<strong>DataRdy线</strong></p>
<ul>
<li><u>CPU释放Ack线</u></li>
</ul>
</li>
</ol>
<h3 id="半同步时序"><a href="#半同步时序" class="headerlink" title="半同步时序"></a>半同步时序</h3><p>同步时序和异步时序相结合</p>
<p>为了减少噪声的影响，<strong>在异步计时中使时钟</strong></p>
<ul>
<li>准备和响应信号在<strong>时钟上升沿</strong>有效</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/10.png" alt=""></p>
<h3 id="分离事务"><a href="#分离事务" class="headerlink" title="分离事务"></a>分离事务</h3><p>设备准备数据期间释放总线，将一个总线事件分离为两个过程</p>
<p><strong>优点</strong>：</p>
<ol>
<li>增加总线利用率</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>增加每个总线事件地持续时间和系统复杂度</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/11.png" alt=""></p>
<ul>
<li>将两个信号之间的总线释放出来</li>
</ul>
<h2 id="总线带宽和数据传输速率"><a href="#总线带宽和数据传输速率" class="headerlink" title="总线带宽和数据传输速率"></a>总线带宽和数据传输速率</h2><p><strong>总线带宽</strong>：总线的最大数据传输速率</p>
<ul>
<li>不考虑总线仲裁、数据传输等因素</li>
</ul>
<p><strong>数据传输速率</strong>：</p>
<ul>
<li>考虑地址传输、握手等因素</li>
</ul>
<p><strong>总线宽度</strong>：组成总线的线数</p>
<ul>
<li><p>数据总线越宽，一次传输的数据位数就越多</p>
</li>
<li><p>地址总线越宽，一次传输的地址位数就越多</p>
</li>
</ul>
<p>例子：</p>
<p>我们假设同步总线的时钟周期为50ns，并且每一次数据传输需要一个时钟周期，异步总线每次握手需要40ns。两种总线均为32位宽，并且数据的准备时间均为200ns，计算当总线从内存中读取一个字(32位)的时候的数据传输率</p>
<ol>
<li><p><strong>同步总线</strong>：</p>
<p> <strong>数据传输率</strong>：$\frac{32bit}{(50 + 200 +50)ns} = 106.7Mbps$</p>
<ul>
<li><p>发送指令和地址到内存：50ns</p>
</li>
<li><p>内存准备数据：200ns</p>
</li>
<li><p>将数据传输到CPU：50ns</p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p><strong>异步总线</strong>：</p>
<p> <img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/13.png" alt=""></p>
<p> <strong>数据传输率</strong>：$\frac{32bit}{(40 + 200 +120)ns} = 106.7Mbps$</p>
<ul>
<li><p>步骤1：40ns</p>
</li>
<li><p>步骤2、3、4 / 数据准备：$max((40 \times 3) ns,200ns)$</p>
</li>
<li><p>步骤5、6、7：$(40 \times 3)ns$</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>如果把存储器的数据准备时间改为230ns，则同步总线的数据准备时间应该是250ns，异步总线仍是230ns</strong></p>
<ul>
<li><strong>同步总线一个时间周期不可以做两件事情</strong></li>
</ul>
</li>
</ul>
<h3 id="不同数据块大小的数据传输速率"><a href="#不同数据块大小的数据传输速率" class="headerlink" title="不同数据块大小的数据传输速率"></a>不同数据块大小的数据传输速率</h3><p>假设系统存在以下特征：</p>
<ul>
<li><p>支持访问大小为4到16个字（每个字32位）的块</p>
</li>
<li><p>同步总线具有64位宽和200MHz时钟频率，需要1个时钟周期来传输地址或64位数据</p>
</li>
<li><p>在两个总线事务之间有2个空闲时钟周期</p>
</li>
<li><p>内存访问时准备前4个字需要200ns，后面每4个字准备需要20ns</p>
</li>
<li><p>当前面的数据在总线上传输时，内存可以同时读取后面的数据</p>
</li>
</ul>
<p>如果读取256个字，分别计算每次传输4个字和16个字时的数据传输速率、传输时间和每秒总线事务数：</p>
<ol>
<li><p><strong>每次传输4个字</strong></p>
<p>  总线事务：地址 + 4个字</p>
<ul>
<li><p>地址传输：1个时钟周期</p>
</li>
<li><p>数据准备：200ns（40个时钟周期）</p>
</li>
<li><p>数据传输：2个时钟周期</p>
</li>
<li><p>空闲：2个时钟周期</p>
<p>总共：$\frac{256}{4} \times (1+40+2+2) = 2880$ 个时钟周期</p>
<p>传输时间：$2880 \times 5ns = 14400ns$</p>
<p>每秒总线事务数：$\frac{64 \times 1s}{14400ns} = 4.44M$</p>
</li>
<li><p>乘以64是因为：<strong>计算的总时间是传输256，而非一个总线事务</strong></p>
<p>数据传输速率：$\frac{256 \times 32bit}{14400ns} = 568.9Mbps$</p>
</li>
</ul>
</li>
<li><p><strong>每次传输16个字</strong></p>
<p>  总线事务：地址 + 16个字</p>
<ul>
<li><p>地址传输：1个时钟周期</p>
</li>
<li><p>数据准备（<strong>前4个字</strong>）：200ns（40个时钟周期）</p>
</li>
<li><p>数据传输：2个时钟周期（<strong>同时读取后4个字：20ns</strong>）</p>
</li>
<li><p>空闲：2个时钟周期</p>
<p>总共：$\frac{256}{16} \times (1+40+3 \times max(2,4)+2+2) = 912$ 个时钟周期</p>
<p>传输时间：$912 \times 5ns = 4560ns$</p>
<p>每秒总线事务数：$\frac{16 \times 1s}{4560ns} = 3.51M$</p>
</li>
<li><p>乘以16是因为：<strong>计算的总时间是传输256，而非一个总线事务</strong></p>
<p>数据传输速率：$\frac{256 \times 32bit}{4560ns} =1796.5Mbps$</p>
</li>
</ul>
</li>
</ol>
<h3 id="提高总线数据传输率"><a href="#提高总线数据传输率" class="headerlink" title="提高总线数据传输率"></a>提高总线数据传输率</h3><ol>
<li><p>增加时钟频率</p>
</li>
<li><p>增加数据总线宽度</p>
<ul>
<li>每次传输更多数据</li>
</ul>
</li>
<li><p>块传输</p>
<ul>
<li>传输一次地址就传输一块数据</li>
</ul>
</li>
<li><p>分离总线事务</p>
<ul>
<li>减少总线空闲时间</li>
</ul>
</li>
<li><p>分离地址线和数据线</p>
<ul>
<li>同时传输地址和数据</li>
</ul>
</li>
</ol>
<h2 id="总线层次结构"><a href="#总线层次结构" class="headerlink" title="总线层次结构"></a>总线层次结构</h2><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><p>CPU、存储器、I/O模块都连接到一条<strong>系统总线</strong></p>
<p><strong>优点</strong>：</p>
<ol>
<li>简单，易于扩展</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>连接的设备越多，总线长度越大，传输延迟也就越大</p>
</li>
<li><p>聚集的传输请求接近总线容量时，总线成为瓶颈</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/14.png" alt=""></p>
<h3 id="双总线结构I"><a href="#双总线结构I" class="headerlink" title="双总线结构I"></a>双总线结构I</h3><p>在CPU和存储器中间增加一个<strong>存储器总线</strong></p>
<p><strong>优点</strong>：</p>
<ol>
<li>增加CPU和存储器之间的传输效率，同时降低系统总线的负担</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/15.png" alt=""></p>
<h3 id="双总线结构II"><a href="#双总线结构II" class="headerlink" title="双总线结构II"></a>双总线结构II</h3><p>将系统总线分为<u>存储器总线、<strong>I/O总线和IOP</strong>（input/output processer）</u></p>
<p><strong>优点</strong>：</p>
<ol>
<li>降低I/O对总线的负担</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/16.png" alt=""></p>
<h3 id="多总线结构I"><a href="#多总线结构I" class="headerlink" title="多总线结构I"></a>多总线结构I</h3><p>增加一个<strong>本地总线</strong>来连接CPU和Cache</p>
<p><strong>优点</strong>：</p>
<ol>
<li>分离了CPU和I/O的交互</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/18.png" alt=""></p>
<h3 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h3><p>将系统总线分为<u>存储器总线、I/O总线和<strong>DMA总线</strong></u></p>
<p><strong>优点</strong>：</p>
<ol>
<li>增加I/O效率</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/17.png" alt=""></p>
<h3 id="多总线结构III"><a href="#多总线结构III" class="headerlink" title="多总线结构III"></a>多总线结构III</h3><p>增加一个<strong>高速I/O总线</strong>来连接高速设备</p>
<p><strong>优点</strong>：</p>
<ol>
<li>增加I/O交互效率</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt13/19.png" alt=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%BE%AE%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%BE%AE%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8/" class="post-title-link" itemprop="url">微操作与控制器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-08 00:35:06 / 修改时间：00:35:42" itemprop="dateCreated datePublished" datetime="2023-12-08T00:35:06+08:00">2023-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机组织与结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="微操作"><a href="#微操作" class="headerlink" title="微操作"></a>微操作</h2><p>执行程序时，计算机操作是由一系列指令周期组成的</p>
<ul>
<li>每个周期执行一条机器指令</li>
</ul>
<p>每个指令周期可以看作是由几个更小的子周期组成</p>
<ul>
<li><strong>取指、间指、执行、中断</strong></li>
</ul>
<p><strong>微操作</strong>：每个子周期由一系列<strong>涉及CPU寄存器操作</strong>的更小步骤组成</p>
<p><strong>微操作分组原则</strong>：</p>
<ol>
<li><p>事件流动顺序必须是恰当的</p>
</li>
<li><p><strong>必须避免冲突</strong></p>
<ul>
<li>$MBR \leftarrow 内存$ 和 $IR \leftarrow MBR$  不应出现在同一时间单位</li>
</ul>
</li>
<li><p>所用的时间单位尽可能少</p>
</li>
</ol>
<h3 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h3><p>出现在每个指令周期的开始，将指令从存储器中取出</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/2.png" alt=""></p>
<ul>
<li><p><strong>时间要尽可能少，提高效率</strong></p>
</li>
<li><p><u>涉及同一个设备或具有逻辑先后顺序</u>的不能同时进行</p>
</li>
</ul>
<h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p>若指令采用<strong>间接寻址</strong>，则在指令执行前有一个间址周期</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/3.png" alt=""></p>
<h3 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h3><p>对于不同的操作码，会出现不同的微操作序列</p>
<ol>
<li><strong>加法指令</strong></li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/5.png" alt=""></p>
<ol>
<li><strong>转移并保存地址指令</strong></li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/7.png" alt=""></p>
<h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><p>在完成执行周期时，要确定是否有允许的中断产生</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/4.png" alt=""></p>
<ul>
<li><p>如果有，则出现一个中断周期</p>
</li>
<li><p>$MAR \leftarrow Save_Address$ 和 $Memory \leftarrow (MBR)$ 划掉</p>
</li>
</ul>
<h3 id="指令周期代码"><a href="#指令周期代码" class="headerlink" title="指令周期代码"></a>指令周期代码</h3><p>取指、间址、中断周期各有一个微操作序列，执行周期对于每个操作码有一个微操作序列</p>
<p><strong>指令周期代码</strong>：假设一个2位的ICC寄存器，明确CPU处于指令周期哪个阶段</p>
<ul>
<li><p>00：取指</p>
</li>
<li><p>01：间址</p>
</li>
<li><p>10：执行</p>
</li>
<li><p>11：中断</p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/8.png" alt=""></p>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><h3 id="CPU内部总线"><a href="#CPU内部总线" class="headerlink" title="CPU内部总线"></a>CPU内部总线</h3><p>ALU和寄存器都连在CPU内部总线上</p>
<p>为了数据在该内部总线和各寄存器之间传递，<strong>内部总线和寄存器之间有门和控制信号</strong></p>
<p><strong>控制线控制着数据和系统总线（外部）的交换以及ALU的操作</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/13.png" alt=""></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/12.png" alt=""></p>
<h3 id="控制CPU的功能需求"><a href="#控制CPU的功能需求" class="headerlink" title="控制CPU的功能需求"></a>控制CPU的功能需求</h3><ol>
<li><p><strong>CPU的基本元素</strong></p>
<ul>
<li>ALU、寄存器组、内部数据通路、控制器、外部数据通路</li>
</ul>
</li>
<li><p><strong>CPU需要完成的微操作</strong></p>
<ul>
<li><p>在寄存器之间传送数据</p>
</li>
<li><p>将数据由寄存器传送到外部接口（如系统总线）</p>
</li>
<li><p>将数据由外部接口传送到寄存器</p>
</li>
<li><p><strong>将寄存器作为输入和输出，完成算术和逻辑运算</strong></p>
</li>
</ul>
</li>
<li><p><strong>控制器的两个基本任务</strong></p>
<ul>
<li><p>定序：<u>根据正被执行的程序，控制器使CPU以正确的顺序通过一系列微操作</u></p>
</li>
<li><p>执行：<u>控制器使每个微操作得以完成</u></p>
</li>
</ul>
</li>
</ol>
<h3 id="控制器的输入和输出"><a href="#控制器的输入和输出" class="headerlink" title="控制器的输入和输出"></a>控制器的输入和输出</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/9.png" alt=""></p>
<ul>
<li><p><strong>指令寄存器</strong>：当前指令的寻址方式和操作码</p>
</li>
<li><p><strong>标志</strong>：确定CPU状态和前一个ALU操作的结果</p>
</li>
<li><p><strong>时钟</strong>：控制器要在每个时钟脉冲完成一个或一组同时的微操作</p>
</li>
<li><p><strong>来自控制总线的控制信号</strong>：向控制器提供控制信号</p>
</li>
</ul>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p><strong>CPU内的控制信号</strong>：</p>
<ul>
<li><p>用于寄存器之间传送数据</p>
</li>
<li><p>用于启动特定的ALU功能</p>
</li>
</ul>
<p><strong>到控制总线的控制信号</strong>：</p>
<ul>
<li><p>到存储器的控制信号</p>
</li>
<li><p>到I/O模块的控制信号</p>
</li>
</ul>
<p>所有控制信号最终作为<strong>二进制输入量</strong>直接输入到各个逻辑门上</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/9.png" alt=""></p>
<h3 id="控制信号"><a href="#控制信号" class="headerlink" title="控制信号"></a>控制信号</h3><p><strong>所有控制信号最终都作为二进制输入直接应用于各个逻辑门</strong></p>
<p>三种控制信号：</p>
<ul>
<li><p><strong>激活ALU的功能</strong></p>
</li>
<li><p><strong>激活数据通路</strong></p>
</li>
<li><p><strong>通过系统总线或其他外部接口传递来的信号</strong></p>
</li>
</ul>
<p>举例：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/11.png" alt=""></p>
<ol>
<li><p>传送PC的内容到MAR</p>
<ul>
<li>打开$C_2$：PC传到MAR</li>
</ul>
</li>
<li><p>由存储器读一条指令装入MBR，并且递增PC</p>
<ul>
<li><p>打开$C_0$：MAR的内容送到地址总线上</p>
</li>
<li><p>存储器读控制信号$C_R$送到控制总线上</p>
</li>
<li><p>打开$C_5$：数据总线上的内容存入MBR</p>
</li>
<li><p>控制信号对PC内容加以，并把结果存回PC</p>
</li>
</ul>
</li>
<li><p>传送MBR的内容到IR</p>
<ul>
<li>打开$C_4$：MBR的内容送到IR</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/10.png" alt=""></p>
<ul>
<li><p>小圆点表示的是<strong>门</strong>，$C_R$是读信号</p>
</li>
<li><p><strong>一个固定长度二进制串用来控制相应的门的开关</strong></p>
</li>
</ul>
<h3 id="控制器的最小特性"><a href="#控制器的最小特性" class="headerlink" title="控制器的最小特性"></a>控制器的最小特性</h3><ol>
<li><p>它只需要知道将被执行的指令和算术、逻辑运算结果的性质（比如正负、溢出等）</p>
<ul>
<li>不需要知道正被处理的数据或得到的实际结果是什么</li>
</ul>
</li>
<li><p>它只是以<strong>少量的</strong>送到CPU内的和送到系统总线上的控制信号来实现控制</p>
</li>
</ol>
<h3 id="控制器实现"><a href="#控制器实现" class="headerlink" title="控制器实现"></a>控制器实现</h3><ol>
<li><p><strong>硬布线实现</strong></p>
<ul>
<li><u>控制器是一个组合电路</u>，把输入逻辑信号转换为一组输出逻辑信号，即控制信号</li>
</ul>
</li>
<li><p><strong>微程序实现</strong></p>
<ul>
<li><u>控制逻辑是微程序指定的</u>，控制器是一个相对简单的逻辑电路，通过<strong>执行每条微指令</strong>来产生控制信号</li>
</ul>
</li>
</ol>
<h4 id="硬布线实现"><a href="#硬布线实现" class="headerlink" title="硬布线实现"></a>硬布线实现</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/14.png" alt=""></p>
<ul>
<li><p><strong>标志和控制总线信号</strong>：每位都有特定意义</p>
</li>
<li><p><strong>指令寄存器</strong>：通过译码使得<u>每一个操作码有一个唯一的逻辑输入</u></p>
<ul>
<li>$n$个输入 $\rightarrow$ $2^n$个输出</li>
</ul>
</li>
<li><p><strong>时钟</strong>：在一个时钟周期内，控制器在不同时间单位发送不同的控制信号</p>
<ul>
<li><p>使用一个<strong>定时器</strong>作为控制器的输入，并且控制器在指令周期结束时必须通知定时器使其重新开始计数</p>
</li>
<li><p><strong>时钟脉冲的周期必须足够长</strong>，以允许信号沿数据路径和通过处理器电路传播</p>
</li>
</ul>
</li>
</ul>
<h5 id="控制器逻辑"><a href="#控制器逻辑" class="headerlink" title="控制器逻辑"></a>控制器逻辑</h5><p>为每个输出的控制信号设计一个关于控制器输入的布尔表达式</p>
<p>定义两个控制信号 $P$ 和 $Q$</p>
<ul>
<li><p>$PQ = 00$：取指周期</p>
</li>
<li><p>$PQ = 01$：间址周期</p>
</li>
<li><p>$PQ = 10$：执行周期</p>
</li>
<li><p>$PQ = 11$：中断周期</p>
</li>
</ul>
<p>举例：</p>
<p>$C_5$：使外部数据总线上的数据读入MBR</p>
<ol>
<li><p>$C_5$ 在取指和间址周期的第二个时间单位有效：</p>
<ul>
<li>$C_5 = \bar{P} \cdot \bar{Q} \cdot T_2 + \bar{P} \cdot Q \cdot T_2$</li>
</ul>
</li>
<li><p>$C_5$ 在执行周期也有效：</p>
<ul>
<li>$C_5 = \bar{P} \cdot \bar{Q} \cdot T_2 + \bar{P} \cdot Q \cdot T_2 + P \cdot \bar{Q} \cdot (LDA + ADD + AND) \cdot T_2$</li>
</ul>
</li>
</ol>
<h4 id="微程序实现"><a href="#微程序实现" class="headerlink" title="微程序实现"></a>微程序实现</h4><p>微程序<u>基于硬件和软件之间</u></p>
<p><strong>微指令</strong>：每行描述一个时间内出现的一组微操作</p>
<p>基本思路：</p>
<ol>
<li><p>对于每个微操作，控制器的任务是<strong>产生一组控制信号</strong></p>
</li>
<li><p>构造一个控制字，每位代表一根控制线</p>
<ul>
<li>这样每个微操作能用控制字中不同的0和1的样式来表示</li>
</ul>
</li>
<li><p>将这些控制字串在一起，可以表示控制器需要完成的微操作序列</p>
</li>
</ol>
<p><strong>由于每个微操作的顺序不是固定的，控制字被放入存储器中，每个字都有一个唯一的地址</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/18.png" alt=""></p>
<ul>
<li><p>添加少数几位用于指示条件的真假</p>
<ul>
<li><p>假则顺序执行下一条指令</p>
</li>
<li><p>真则地址字段指向的微指令是下一条执行的微指令</p>
</li>
</ul>
</li>
<li><p><strong>地址字段</strong>：指示条件为真时，将要执行的下一控制字的位置</p>
</li>
</ul>
<p><strong>微程序执行</strong>：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/19.png" alt=""></p>
<h5 id="微程序控制器构成"><a href="#微程序控制器构成" class="headerlink" title="微程序控制器构成"></a>微程序控制器构成</h5><ol>
<li><p><strong>定序逻辑</strong>：向控制地址寄存器装入地址，并发出读命令</p>
</li>
<li><p><strong>控制地址寄存器</strong>：含有下面即将被读取的微指令地址</p>
</li>
<li><p><strong>控制存储器</strong>：存有一组微指令</p>
</li>
<li><p><strong>控制缓冲寄存器</strong>：存放被读出的微指令</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/20.png" alt=""></p>
<h5 id="微程序控制器任务"><a href="#微程序控制器任务" class="headerlink" title="微程序控制器任务"></a>微程序控制器任务</h5><ol>
<li><p><strong>微指令定序</strong></p>
<p> 根据当前的微指令、条件标志和指令寄存器的内容，产生下一微指令的控制存储器地址</p>
<ol>
<li><p><strong>双地址字段</strong>：在每条微指令中提供两个地址字段，选择并发送其中某一个地址或操作码到控制地址寄存器</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/26.png" alt=""></p>
</li>
<li><p><strong>单地址字段</strong>：下一个地址得选择可以是地址字段或下一个顺序地址</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/27.png" alt=""></p>
</li>
<li><p><strong>可变格式</strong>：提供两种完全不同的指令格式，一位字段用于指定哪种格式被使用</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/28.png" alt=""></p>
<p>设计考虑：</p>
</li>
<li><p>微指令的大小</p>
</li>
<li><p>地址生成时间</p>
</li>
</ol>
</li>
<li><p><strong>微指令执行</strong></p>
<p> <strong>产生控制信号</strong>：发往CPU内部，送往外部控制总线或其他外部接口</p>
</li>
</ol>
<h5 id="微程序控制器工作流程"><a href="#微程序控制器工作流程" class="headerlink" title="微程序控制器工作流程"></a>微程序控制器工作流程</h5><ol>
<li><p>为执行一条指令，定序逻辑发出一个<strong>读命令</strong>给控制存储器</p>
</li>
<li><p>当一条微指令由控制存储器读出后，被传送到控制缓冲寄存器</p>
<ul>
<li><strong>从控制地址寄存器读</strong></li>
</ul>
</li>
<li><p>控制缓冲寄存器的内容<strong>生成控制信号</strong>，并<strong>为定序逻辑提供下一条地址信息</strong></p>
<ul>
<li><p>控制缓冲寄存器的左半部分与控制器发出的控制线相连</p>
</li>
<li><p><strong>由控制存储器读一条微指令等同于执行这条微指令</strong></p>
</li>
</ul>
</li>
<li><p>定序逻辑根据这个地址信息和ALU标志，将新的地址装入到控制地址寄存器</p>
</li>
</ol>
<p>生成新地址的三个选择：</p>
<ol>
<li><p><strong>取顺序下一条微指令</strong>：加1到控制地址寄存器</p>
</li>
<li><p><strong>基于跳转微指令转移到一个新的例程</strong>：将控制缓冲寄存器的地址字段装入控制地址寄存器</p>
</li>
<li><p><strong>转移到一个机器指令例程</strong>：根据IR总的操作码向控制地址寄存器装入机器指令例程的第一条微指令</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt16/20.png" alt=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF/" class="post-title-link" itemprop="url">数据通路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-06 21:17:05 / 修改时间：23:28:44" itemprop="dateCreated datePublished" datetime="2023-12-06T21:17:05+08:00">2023-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机组织与结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="CPU任务"><a href="#CPU任务" class="headerlink" title="CPU任务"></a>CPU任务</h3><ul>
<li><p><strong>取指令</strong>：从存储器读取指令</p>
</li>
<li><p><strong>解释指令</strong>：对指令进行译码，以确认所要求的动作</p>
</li>
<li><p><strong>取数据</strong>：指令的执行可能要求从存储区或I/O模块中读取数据</p>
</li>
<li><p><strong>处理数据</strong>：指令的执行可能要求对数据完成某些算数或逻辑运算</p>
</li>
<li><p><strong>写数据</strong>：执行的结果可能要求写数到存储器或I/O模块</p>
</li>
</ul>
<h3 id="CPU需求"><a href="#CPU需求" class="headerlink" title="CPU需求"></a>CPU需求</h3><p><strong>CPU需要一些小容量的内部存储器</strong></p>
<ol>
<li><p>CPU需要在指令周期中<strong>临时保存指令和数据</strong></p>
</li>
<li><p>CPU需要<strong>记录当前所执行指令的位置</strong>，以便知道从何处得到下一条指令</p>
</li>
</ol>
<h3 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h3><ol>
<li><p><strong>存储地址寄存器</strong>：MAR</p>
<ul>
<li><p><u>MAR直接到地址总线</u></p>
</li>
<li><p>不仅仅是存储指令的地址，而是可以存储所有的数据地址</p>
</li>
</ul>
</li>
<li><p><strong>存储缓冲（数据）寄存器</strong>：MBR/MDR</p>
<ul>
<li><p><u>包含要写入内存的数据字或最近读取的数据字</u></p>
</li>
<li><p><u>MBR直接连接到数据总线</u></p>
</li>
<li><p>可以直接访问MBR和用户可见寄存器</p>
</li>
</ul>
</li>
<li><p><strong>程序计数器</strong>：PC</p>
<ul>
<li><p><u>处理器在每次取指令后就更新PC</u></p>
</li>
<li><p>分支或跳过指令也会修改PC的内容</p>
</li>
</ul>
</li>
<li><p><strong>指令寄存器</strong>：IR</p>
<ul>
<li>获取的指令呗加载到IR中，在IR中分析操作码和操作数说明符</li>
</ul>
</li>
<li><p><strong>程序状态字</strong>：PSW</p>
<p> 一个或一组寄存器包含状态信息</p>
<ul>
<li><p><strong>Sign</strong>：最后一次算术运算结果的符号位</p>
</li>
<li><p><strong>Zero</strong>：结果为0时设置</p>
</li>
<li><p><strong>Carry</strong>：有进位或出位则设置</p>
</li>
<li><p><strong>Equal</strong>：设置逻辑比较结果是否相等</p>
</li>
<li><p><strong>Overflow</strong>：表示算术溢出</p>
</li>
<li><p><strong>Interupt</strong>：启用或禁用中断</p>
</li>
<li><p><strong>Supervisor</strong>：指示处理器是以Supervisor模式还是用户模式执行</p>
</li>
</ul>
</li>
</ol>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><h3 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h3><ol>
<li>把下一条指令地址放到MAR中，然后交给内存</li>
</ol>
<ol>
<li><p>控制单元设置控制线的信号，如果控制线设置为相应信号，内存会始终监听信号线</p>
<ul>
<li>当读到<strong>读信号</strong>时，则会从MAR中读出一个地址，然后取出数据给数据总线</li>
</ul>
</li>
<li><p>将数据从数据总线读到MBR中，然后<strong>拷贝</strong>到IR中</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/5.png" alt=""></p>
<h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><ol>
<li><p><strong>MBR中是地址</strong>，将地址<strong>拷贝</strong>到MAR中</p>
</li>
<li><p>控制单元发送<strong>读请求</strong>，内从从MAR中进行拉取后，从内存中取出来，返给MBR</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/6.png" alt=""></p>
<h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><ol>
<li><p>控制单元会先告诉主存有写操作</p>
</li>
<li><p>之后控制单元会为MAR指定一个写入的位置</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/7.png" alt=""></p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p><strong>指令流水线</strong>：一条指令的处理过程分成若干个阶段，每个阶段由相应的功能部件完成</p>
<h3 id="两阶段方法"><a href="#两阶段方法" class="headerlink" title="两阶段方法"></a>两阶段方法</h3><p>将指令处理分为两个阶段：<u>取指令、执行指令</u></p>
<ul>
<li><strong>在当前指令的执行期间取下一条指令</strong></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/8.png" alt=""></p>
<p><strong>问题</strong>：</p>
<ol>
<li><p><strong>执行时间一般长于取指时间</strong></p>
</li>
<li><p>可能出现内存访问冲突</p>
</li>
<li><p>条件分支指令使得待取的下一条指令的地址是未知的</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/9.png" alt=""></p>
<h3 id="六阶段方法"><a href="#六阶段方法" class="headerlink" title="六阶段方法"></a>六阶段方法</h3><p>为了进一步的加速，流水线必须有更多阶段，<strong>各个阶段所需要的时间几乎是相等的</strong></p>
<ol>
<li><p><strong>取指令（FI）</strong>：读下一条指令到缓冲器</p>
</li>
<li><p><strong>译码指令（DI）</strong>：确定操作码和操作数指定符</p>
</li>
<li><p><strong>计算操作数（CO）</strong>：计算每个源操作数的有效地址</p>
</li>
<li><p><strong>取操作数（FO）</strong>：从存储器取出每个操作数，寄存器中的操作数不用取</p>
</li>
<li><p><strong>执行指令（EI）</strong>：完成指定的操作，若有指定的目的操作数的位置，则将结果写入此位置</p>
</li>
<li><p><strong>写操作数（WO）</strong>：将结果存入存储器</p>
</li>
</ol>
<p><strong>不是所有指令都包含6个阶段</strong></p>
<ul>
<li>LOAD指令不需要WO阶段</li>
</ul>
<p><strong>不是所有阶段都能并行完成</strong></p>
<ul>
<li>FI、FO、WO都涉及存储器访问</li>
</ul>
<p><strong>限制</strong>：</p>
<ol>
<li><p>若6个阶段不全是相等的时间，则会在各个流水阶段涉及某种等待</p>
</li>
<li><p>条件分支指令可以是使多个指令获取无效</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/11.png" alt=""></p>
<ul>
<li>如果调到了15号指令，则之前的所有的数据都被“浪费掉”</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/12.png" alt=""></p>
<p><strong>问题</strong>：</p>
<ol>
<li><p>最多的时候会同时处理6件事情，所以需要<strong>遵守6个任务中时间最长的任务所需时间</strong></p>
</li>
<li><p><strong>微指令之间存在时间间隔</strong>，所以6个指令加起来的运算时间要大于原来一次计算完</p>
</li>
<li><p>可能出现内存冲突</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/10.png" alt=""></p>
<h2 id="流水线性能"><a href="#流水线性能" class="headerlink" title="流水线性能"></a>流水线性能</h2><p>假设：</p>
<ul>
<li><p>$t_i$：流水线第 $i$ 段的电路延迟时间</p>
</li>
<li><p>$t_m$: 最大段延迟（<strong>通过耗时最长段的延迟</strong>）</p>
</li>
<li><p>$k$：指令流水线段数</p>
</li>
<li><p>$d$：锁存延时（<strong>数据和信号从上一段到下一段所需的段间锁存接收时间</strong>）</p>
</li>
</ul>
<p><strong>周期时间</strong>：$t = max[t_i] + d = t_m + d$</p>
<p>令 $T_{k,n}$ 为 $k$ 阶段流水线执行所有 $n$ 条指令所需的总时间，则：</p>
<ul>
<li><p>$T_{k,n} = [k + (n - 1)] t$</p>
</li>
<li><p><strong>加速比</strong>：$S_k = \frac{T_{1,n}}{T_{k,n}} = \frac{nkt}{[k + (n - 1)]t} = \frac{nk}{k + (n - 1)} = \frac{n}{1 + \frac{n - 1}{k}}$</p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/15.png" alt=""></p>
<p><strong>误解</strong>：流水线中的阶段数越多，执行速度越快</p>
<ul>
<li><p>会造成指令间隔变多，间隔浪费的时间也会增加</p>
</li>
<li><p>会造成指令控制比较复杂</p>
</li>
</ul>
<p><strong>原因</strong>：</p>
<ul>
<li><p>在管道的每个阶段，将数据从一个缓冲区移动到另一个缓冲区以及执行各种准备和传递功能都会涉及一些开销</p>
</li>
<li><p>处理内存和寄存器依赖项以及优化管道使用所需的控制逻辑量随着阶段数的增加而大大增加</p>
</li>
</ul>
<h2 id="冒险（Hazard）"><a href="#冒险（Hazard）" class="headerlink" title="冒险（Hazard）"></a>冒险（Hazard）</h2><p>在某些情况下，指令流水线会<strong>阻塞或停顿（stall）</strong>，导致后续指令无法正确执行</p>
<p>类型：</p>
<ul>
<li><p><strong>结构冒险</strong>（硬件资源冲突）</p>
</li>
<li><p><strong>数据冒险</strong>（数据依赖性）</p>
</li>
<li><p><strong>控制冒险</strong></p>
</li>
</ul>
<h3 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h3><p>已进入流水线的不同指令在同一时刻访问相同的硬件资源</p>
<p><strong>解决</strong>：使用多个不同的硬件资源，或者分时使用同一个硬件资源  </p>
<ul>
<li>可以<strong>分时复用</strong>：前半段读出，后半段写入</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/16.png" alt=""></p>
<h3 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h3><p>未生成指令所需要的数据</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/17.png" alt=""></p>
<p><strong>解决</strong>：</p>
<ol>
<li><strong>插入nop指令（空操作）</strong></li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/18.png" alt=""></p>
<ol>
<li><strong>插入bubble（等待）</strong></li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/19.png" alt=""></p>
<ol>
<li><strong>转发（forwarding）/ 旁路（bypassing）</strong></li>
</ol>
<ul>
<li>旁路：添加一根线来获取目标数据</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/20.png" alt=""></p>
<ol>
<li><strong>交换指令顺序</strong></li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/21.png" alt=""></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/22.png" alt=""></p>
<h3 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h3><p>指令执行顺序被更改</p>
<ul>
<li><strong>转移、中断、异常、调用/返回</strong></li>
</ul>
<p><strong>解决</strong>：</p>
<ol>
<li><p><strong>取多条指令</strong></p>
<ul>
<li><p>多个指令流：<u>复制流水线的开始部分，并允许流水线同时取这两条指令，使用两个指令流</u></p>
</li>
<li><p>预取多支目标：<u>识别出一个条件分支指令时，除了取此份之指令之后的指令外，分支目标处的指令也被取来</u></p>
</li>
<li><p>循环缓冲器：<u>由流水线指令取指阶段维护的一个小的但极高速的存储器，含有n条最近顺序取来的指令</u></p>
</li>
</ul>
</li>
<li><p><strong>分支预测</strong></p>
<ul>
<li><p>静态预测：</p>
<ul>
<li><p>预测绝不发生</p>
</li>
<li><p>预测总是发生</p>
</li>
<li><p>依操作码预测</p>
</li>
</ul>
</li>
<li><p>动态预测：</p>
<ul>
<li><p>发生/不发生切换</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/23.png" alt=""></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/24.png" alt=""></p>
</li>
<li><p>转移历史表</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt15/25.png" alt=""></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">指令系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-06 16:36:03 / 修改时间：16:36:41" itemprop="dateCreated datePublished" datetime="2023-12-06T16:36:03+08:00">2023-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机组织与结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>指令是计算机<strong>处理</strong>的最基本单位，采取<strong>多周期</strong>实现方案</p>
<ul>
<li><p>操作码 + 操作数</p>
</li>
<li><p><u>取指令，译码/取寄存器，执行/有效地址/完成分支，访问内存，存储结果</u></p>
</li>
</ul>
<h2 id="指令表示"><a href="#指令表示" class="headerlink" title="指令表示"></a>指令表示</h2><p>指令由一个<strong>位串</strong>来表示</p>
<p><strong>指令格式</strong>：对于指令的个要素，这个位串划分成几个字段</p>
<ul>
<li>大多数指令集使用不止一种指令格式</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/5.png" alt=""></p>
<p><strong>机器指令符号表示法</strong>：</p>
<ol>
<li><p>操作码缩写成<strong>助记符</strong>，比如 ADD、SUB 等</p>
</li>
<li><p>操作数也可以用符号表示</p>
<ul>
<li><strong>寄存器编号或内存地址</strong></li>
</ul>
</li>
</ol>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>所有计算机上都会存在相同的常用操作类型，比如<u><strong>数据传送、算数运算、逻辑运算</strong>、转换、输入/输出、系统控制、控制转移</u></p>
<h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>常见类型：<u>地址、数值、字符、逻辑数据</u></p>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p>一个指令需要有<strong>4个地址</strong>引用：<u>2个源操作数,1个目的操作数、1个下一指令地址</u></p>
<ul>
<li>下一指令地址是<strong>隐含</strong>的</li>
</ul>
<p>每条指令中的地址数目越少，指令的长度越短，不需要复杂的CPU，但是<u>程序总的指令条数更多，执行时间更长，程序更长更复杂</u></p>
<h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>计算机存储的数值是受限的</p>
<h4 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h4><p><strong>国际参考字母表IRA / 美国信息交换标准码ASCII</strong>：每个字符被表示为唯一的7位二进制串</p>
<p><strong>扩展的二进制编码的十进制交换码EBCDIC</strong>：8位编码</p>
<p><strong>统一码Unicode</strong>：16位/32位</p>
<h4 id="逻辑数据"><a href="#逻辑数据" class="headerlink" title="逻辑数据"></a>逻辑数据</h4><p>将一个n位单元看成是由n个1位项组成，每一项有值0或1</p>
<h4 id="大端序和小端序"><a href="#大端序和小端序" class="headerlink" title="大端序和小端序"></a>大端序和小端序</h4><p><strong>大端序</strong>：把数据高位放在低地址</p>
<p><strong>小端序</strong>：把数据低位放在低地址</p>
<ul>
<li><p>两种策略中每个数据项有同样地址</p>
</li>
<li><p>端序不影响结构中的数据项的次序</p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/16.png" alt=""></p>
<h3 id="操作数的引用"><a href="#操作数的引用" class="headerlink" title="操作数的引用"></a>操作数的引用</h3><p><strong>寻址方式</strong>：<u>立即寻址、直接寻址、简介寻址、寄存器寻址、寄存器间接寻址、偏移寻址、栈寻址</u></p>
<p><strong>记号</strong>：</p>
<ul>
<li><p>A：指令中地址字段的内容</p>
</li>
<li><p>R：<strong>指向寄存器的指令地址字段的内容</strong></p>
</li>
<li><p>EA：被访问位置的实际地址</p>
</li>
<li><p>(X)：<strong>存储器位置X或寄存器X的内容</strong></p>
</li>
</ul>
<h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p><strong>操作数</strong>实际出现在指令中</p>
<ul>
<li><p>除了取指令之外，获取操作数<u>不要求另外的存储器访问</u></p>
</li>
<li><p>数的大小受限于地址字段的长度</p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/18.png" alt=""></p>
<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>地址字段含有<strong>操作数的有效地址</strong></p>
<ul>
<li><p><u>只要求1次存储器访问</u>，且无需为生成地址而专门计算</p>
</li>
<li><p>地址空间有限</p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/23.png" alt=""></p>
<h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>地址字段指示<strong>一个存储器字地址，而此地址保存有操作数的全长度地址</strong></p>
<ul>
<li><p><strong>第一层地址指向第二层的实际地址</strong></p>
</li>
<li><p>扩大了地址空间</p>
</li>
<li><p>取操作数<u>需要2次访问存储器</u></p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/19.png" alt=""></p>
<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>地址字段指示的是<strong>寄存器</strong></p>
<ul>
<li><p><strong>寄存器存的是操作数</strong></p>
</li>
<li><p>指令中仅需要一个较小的地址字段，而<u>不需要存储器访问</u></p>
</li>
<li><p>地址空间十分有限</p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/20.png" alt=""></p>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>地址字段指示<strong>寄存器</strong></p>
<ul>
<li><p><strong>寄存器存的是操作数地址</strong></p>
</li>
<li><p>扩大地址空间，<u>比间接寻址少1次存储器访问</u></p>
</li>
<li><p>相对于寄存器寻址，<u>需要多1次存储器访问</u></p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/21.png" alt=""></p>
<h4 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h4><p>结合直接寻址和寄存器间接寻址能力</p>
<ul>
<li>实际地址：<strong>寄存器存放的地址 + 直接指示的地址</strong></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/22.png" alt=""></p>
<h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>隐含引用的寄存器是<strong>程序计数器（PC）</strong></p>
<ul>
<li>实际地址：下一条指令的地址 +直接指示的地址</li>
</ul>
<h4 id="基址寄存器寻址"><a href="#基址寄存器寻址" class="headerlink" title="基址寄存器寻址"></a>基址寄存器寻址</h4><p>引用的寄存器含有一个存储器地址，地址字段含有偏移量（通常是无符号整数）</p>
<ul>
<li><p>实际地址：<strong>寄存器存放的地址 + 直接指示的偏移量</strong></p>
</li>
<li><p>寄存器引用可以是显式的，也可以是隐式的</p>
</li>
</ul>
<h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><p>指令地址字段引用一个主存地址，被引用的寄存器含有的对该地址的一个<strong>正的偏移量</strong></p>
<ul>
<li>实际地址：<strong>直接指示的地址 + 寄存器存放的偏移量</strong></li>
</ul>
<h4 id="栈寻址"><a href="#栈寻址" class="headerlink" title="栈寻址"></a>栈寻址</h4><p>栈指针保存在寄存器中，对寄存器中栈位置的访问<strong>实际上是一种寄存器间接寻址方式</strong></p>
<ul>
<li>与栈相关的是一个指针，<strong>它的值是栈顶地址</strong>，或者当栈顶的两个元素已在CPU寄存器内，此时栈顶指针指向栈顶的第三个元素</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/24.png" alt=""></p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>指令格式通过它的各个构成部分来定义指令的位安排</p>
<ul>
<li><p>一个指令格式必须包含<u>一个操作码，以及显式或隐式的、零个或多个操作数</u></p>
</li>
<li><p><strong>必须显式或隐式地为每个操作数指定其寻址方式</strong></p>
</li>
</ul>
<p>大多数指令集使用不止一种指令格式</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li><p><strong>指令尽量短</strong></p>
<ul>
<li>占用存储空间小</li>
</ul>
</li>
<li><p><strong>有足够的操作码位数</strong></p>
<ul>
<li>要为操作类型不断增加预留</li>
</ul>
</li>
<li><p><strong>操作码地编码必须有唯一的解释</strong></p>
</li>
<li><p><strong>指令长度是字节地整数倍</strong></p>
<ul>
<li>内存是按字节寻址</li>
</ul>
</li>
<li><p><strong>合理选择地址字段的个数</strong></p>
</li>
<li><p><strong>指令尽量规整</strong></p>
</li>
</ol>
<h3 id="指令长度"><a href="#指令长度" class="headerlink" title="指令长度"></a>指令长度</h3><p><strong>指令长度应该是字符长度或定点数长度的整数倍</strong></p>
<p><strong>指令长度应该等于存储器的传送长度（数据总线宽度）</strong></p>
<ul>
<li>或者这两个值其中之一是另一个的整数倍</li>
</ul>
<p>最明显的权衡考虑是在强有力的指令清单和节省空间之间进行</p>
<ul>
<li><p>编程人员希望更多的操作码、更多的操作数、更多的寻址方式和更大的地址范围</p>
</li>
<li><p>指令长度变短可以<strong>节省存储空间和减少数据传送时间</strong></p>
</li>
</ul>
<h3 id="位的分配"><a href="#位的分配" class="headerlink" title="位的分配"></a>位的分配</h3><p>对于给定的指令长度，在操作码数目和寻址能力之间存在着权衡考虑</p>
<ol>
<li><p><strong>使用变长的操作码</strong></p>
<ul>
<li>使用一个最小操作码长度，但是对于某些操作码，可以使用<strong>指令附加位</strong>的方式来指定附加的操作</li>
</ul>
</li>
<li><p>使用寻址位的考虑因素</p>
<ul>
<li><p><u>寻址方式的种数、操作数的数量、寄存器与存储器比较、寄存器组的数目、地址范围、寻址粒度</u></p>
<ul>
<li><p>能用于操作数引用的寄存器越多，指令需要的位数越少</p>
</li>
<li><p>对于固定数目的寄存器，功能上的分开将是指令只需较少的位数</p>
</li>
<li><p>使用较大的字时，需要的地址位更少</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="变长指令"><a href="#变长指令" class="headerlink" title="变长指令"></a>变长指令</h4><p>提供不同长度的各种指令格式</p>
<ul>
<li><strong>取至少等于最长指令长度的几个字节或几个字</strong></li>
</ul>
<p>优点：</p>
<ul>
<li><p>易于提供大的操作码清单，而操作码具有不同的长度</p>
</li>
<li><p>寻址方式能更灵活，指令格式能将各种寄存器和存储器引用加上寻址方式予以组合</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>增加了CPU的复杂程度</li>
</ul>
<h2 id="指令集设计"><a href="#指令集设计" class="headerlink" title="指令集设计"></a>指令集设计</h2><p><strong>指令集</strong>：<strong>定义了处理器应完成的多数功能</strong>，对处理器的实现有着显著的影响，是程序员控制处理器的方式，设计时必须考虑程序员的要求</p>
<p>设计基本原则：</p>
<ul>
<li><p><strong>完备性/完整性</strong></p>
<ul>
<li>操作类型应当尽可能完备，但是太复杂也会给硬件实现增加困难</li>
</ul>
</li>
<li><p><strong>兼容性</strong></p>
<ul>
<li>应当兼容以前的指令系统，为软件重复利用带来方便</li>
</ul>
</li>
<li><p><strong>均匀性</strong></p>
<ul>
<li>应当能对多种类型的数据进行处理</li>
</ul>
</li>
<li><p><strong>可扩充性</strong></p>
<ul>
<li>操作码要预留一定的编码空间</li>
</ul>
</li>
</ul>
<p>设计的基本问题：</p>
<ul>
<li><p><strong>操作指令表</strong></p>
</li>
<li><p><strong>数据类型</strong></p>
</li>
<li><p><strong>指令格式</strong></p>
</li>
<li><p><strong>寄存器</strong></p>
</li>
<li><p><strong>寻址方式</strong></p>
</li>
<li><p><strong>下一条指令地址的确定</strong></p>
</li>
</ul>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><h3 id="简单指令周期"><a href="#简单指令周期" class="headerlink" title="简单指令周期"></a>简单指令周期</h3><p>当且仅有当<u>机器关闭，不可被恢复的错误发生或者程序指令停止了计算机</u>时，程序执行才会停止，不然操作系统的执行是不会停止的</p>
<p><strong>指令周期</strong>：处理单个指令的过程</p>
<ol>
<li><p><strong>取指周期</strong>：从内存中获取指令</p>
</li>
<li><p><strong>执行周期</strong>：执行所提取的指令</p>
</li>
</ol>
<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSZC7CV43Cfnfe18qiEHoV2oKCxryIfy_3Xew&amp;usqp=CAU" alt="指令执行过程- 掘金"></p>
<p><strong>指令周期状态图</strong>：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/2.png" alt=""></p>
<ol>
<li><p>从内存中取指令</p>
</li>
<li><p>解析指令获取操作码</p>
</li>
<li><p>获取操作数</p>
</li>
</ol>
<h3 id="含有中断的指令周期"><a href="#含有中断的指令周期" class="headerlink" title="含有中断的指令周期"></a>含有中断的指令周期</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/3.png" alt=""></p>
<ol>
<li><p>开中断时响应中断（Interupt enable）</p>
<ul>
<li><strong>每执行完成一次指令后要check有无中断并且进行处理</strong></li>
</ul>
</li>
<li><p>关中断的时候不响应中断</p>
</li>
</ol>
<p><strong>指令周期状态图</strong>：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt14/4.png" alt=""></p>
<h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p>指令的执行可能涉及一个或多个存储器中的操作数，它们都要求一次存储器访问</p>
<ul>
<li><strong>使用间接寻址，还需要额外的存储器访问</strong></li>
</ul>
<p><strong>间址周期</strong>：把简介地址的读取看成是一个额外的指令子周期</p>
<p><img src="https://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/image/s7.gif" alt="计算机组成原理"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%BA%A6%E6%9D%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%BA%A6%E6%9D%9F/" class="post-title-link" itemprop="url">约束</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-04 02:01:04 / 修改时间：02:01:45" itemprop="dateCreated datePublished" datetime="2023-12-04T02:01:04+08:00">2023-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>810</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述（感觉没什么要写的）"><a href="#概述（感觉没什么要写的）" class="headerlink" title="概述（感觉没什么要写的）"></a>概述（<del>感觉没什么要写的</del>）</h2><p>约束是<u>作用于表中字段上的规则</u>，用于<strong>限制存储在表中的数据</strong></p>
<p>目的：<u>保证数据库中数据的正确、有效性和完整性</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>非空约束</strong></td>
<td>限制该字段的数据不能为 null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td><strong>唯一约束</strong></td>
<td>保证该字段所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td><strong>主键约束</strong></td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td><strong>默认约束</strong></td>
<td>存储数据时，如果未指定该字段的值，则用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td><strong>检查约束</strong></td>
<td>保证字段值满足一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td><strong>外键约束</strong></td>
<td>用来让两张表的数据之间建立联系，保证数据的一致性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody>
</table>
</div>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><ol>
<li><p>添加外键</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段名 数据类型;</span><br><span class="line">	...</span><br><span class="line">	[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h3><div class="table-container">
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NO ACTION</strong></td>
<td>当在父表中删除/更新对应记录时，应检查该记录是否有对应外键，如果有则不允许删除/更新</td>
</tr>
<tr>
<td><strong>RESTRICT</strong></td>
<td>当在父表中删除/更新对应记录时，应检查该记录是否有对应外键，如果有则不允许删除/更新</td>
</tr>
<tr>
<td><strong>CASCADE</strong></td>
<td>当在父表中删除/更新对应记录时，应检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录</td>
</tr>
<tr>
<td><strong>SET NULL</strong></td>
<td>当在父表中删除对应记录时，应检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求外键允许取null）</td>
</tr>
<tr>
<td><strong>SET DEFAULT</strong></td>
<td>父表有变更时，自建将外键列设置成一个默认的值（innodb不支持）</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> [行为] <span class="keyword">ON</span> <span class="keyword">DELETE</span> [行为]</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-12-03 03:04:39 / 修改时间：03:05:17" itemprop="dateCreated datePublished" datetime="2023-12-03T03:04:39+08:00">2023-12-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>738</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CONCAT(S1, S2, …, Sn)</strong></td>
<td>字符串拼接</td>
</tr>
<tr>
<td><strong>LOWER(str)</strong></td>
<td>转小写</td>
</tr>
<tr>
<td><strong>UPPER(str)</strong></td>
<td>转大写</td>
</tr>
<tr>
<td><strong>LPAD(str, n, pad)</strong></td>
<td>用pad进行左填充，达到n个字符长度</td>
</tr>
<tr>
<td><strong>RPAD(str, n, pad)</strong></td>
<td>用pad进行右填充，达到n个字符长度</td>
</tr>
<tr>
<td><strong>TRIM(str)</strong></td>
<td>出去首部和尾部的空格</td>
</tr>
<tr>
<td><strong>SUBSTRING(str, start, len)</strong></td>
<td>截取字符串</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CEIL(x)</strong></td>
<td>向上取整</td>
</tr>
<tr>
<td><strong>FLOOR(x)</strong></td>
<td>向下取整</td>
</tr>
<tr>
<td><strong>MOD(x, y)</strong></td>
<td>取模</td>
</tr>
<tr>
<td><strong>RNAD()</strong></td>
<td>0·1之间的随机数</td>
</tr>
<tr>
<td><strong>ROUND(X, y)</strong></td>
<td>x四舍五入，保留y位</td>
</tr>
</tbody>
</table>
</div>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CURDATE()</strong></td>
<td>当前日期</td>
</tr>
<tr>
<td><strong>CURTIME()</strong></td>
<td>当前时间</td>
</tr>
<tr>
<td><strong>NOW()</strong></td>
<td>当前日期和时间</td>
</tr>
<tr>
<td><strong>YEAR(date)</strong></td>
<td>指定date的年份</td>
</tr>
<tr>
<td><strong>MONTH(date)</strong></td>
<td>指定date的月份</td>
</tr>
<tr>
<td><strong>DAY(date)</strong></td>
<td>指定date的日期</td>
</tr>
<tr>
<td><strong>DATE_ADD(date, INTERVAL expr type)</strong></td>
<td>一个日期/时间值 加上一个时间间隔expr</td>
</tr>
<tr>
<td><strong>DATEDIFF(date1, date2)</strong></td>
<td>相差的天数(date1 - date2)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>DATE_ADD函数中的<strong>INTERVAL是固定要写的</strong>，type可以是<U>DAY、MONTH、YEAR</U></li>
</ul>
<h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IF(value, t, f)</strong></td>
<td>如果value为true则t，否则f</td>
</tr>
<tr>
<td><strong>IFNULL(value1, value2)</strong></td>
<td>如果value不为空则value1，否则value2</td>
</tr>
<tr>
<td><strong>CASE WHEN [val1] THEN [res1] … ELSE [default] END</strong></td>
<td>如果val1为true则res1，…，否则default默认值</td>
</tr>
<tr>
<td><strong>CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</strong></td>
<td>如果expr等于val1则res1，…，否则default默认值</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>多个目标要用多个when</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/" class="post-title-link" itemprop="url">虚拟存储器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-28 00:34:14" itemprop="dateCreated datePublished" datetime="2023-11-28T00:34:14+08:00">2023-11-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-07 21:55:59" itemprop="dateModified" datetime="2023-12-07T21:55:59+08:00">2023-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机组织与结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如何将更多任务装入主存</p>
<ul>
<li><p>增大主存容量</p>
</li>
<li><p>使用交换技术、</p>
<ul>
<li><p>当主存中没有处于就绪的任务时，操作系统调入其他任务来执行</p>
</li>
<li><p><strong>分区和分页</strong></p>
</li>
</ul>
</li>
<li><p><strong>虚拟存储器</strong></p>
<ul>
<li><p><strong>请求分页</strong>：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上</p>
</li>
<li><p><strong>虚拟地址</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="分区方式"><a href="#分区方式" class="headerlink" title="分区方式"></a>分区方式</h3><p>主存分为两大区域：<u>系统区、用户区</u></p>
<ol>
<li><p><strong>简单固定分区</strong></p>
<p> 用户区划分成长度不等的<strong>固定长</strong>的分区，当一个任务调入主存时，分配一个可用的、能容纳它的、最小的分区</p>
<p> <img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/1.png" alt=""></p>
</li>
<li><p><strong>可变长分区</strong></p>
<p> 用户区按每个人物所需要的内存大小进行分配</p>
<ul>
<li><strong>时间越长，存储器中的碎片就会越多</strong><br><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/4.png" alt=""></li>
</ul>
</li>
</ol>
<h3 id="分页方式"><a href="#分页方式" class="headerlink" title="分页方式"></a>分页方式</h3><p>基本思想：</p>
<ul>
<li><p>把主存分成固定长且比较小的存储块，称为<strong>页框</strong>，每个任务也被划分成固定长的程序块，称为<strong>页</strong></p>
</li>
<li><p>将页装入页框上，且无需采用连续的页框来存放一个任务中所有的页</p>
</li>
</ul>
<p><strong>逻辑地址</strong>：指令中的地址</p>
<p><strong>物理地址</strong>：实际主存地址</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/2.png" alt=""></p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>基本思想：</p>
<ul>
<li><p><strong>请求分页</strong>：仅将当前需要的页面调入主存</p>
<ul>
<li><p>通过硬件将逻辑地址转换为物理地址</p>
</li>
<li><p>未命中时在主存和硬盘之间交换信息</p>
</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ol>
<li><p><strong>在不扩大物理内存的前提下，可以载入更多的任务</strong></p>
</li>
<li><p>编写程序时不需要考虑可用物理内存的状态</p>
</li>
<li><p>可以在大于物理内存的逻辑地址空间中编程</p>
</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li><p>先把程序加载到硬盘的特定区域，然后我们什么时候需要这个内存，移动到主存中去</p>
</li>
<li><p>存储是否被加载到物理内存中，如果被加载进物理内存，则是物理地址，如果没有在里面就在磁盘中</p>
<ul>
<li>满了可以使用替换策略进行替换</li>
</ul>
</li>
<li><p>内存中有的，硬盘中也是有的</p>
<ul>
<li><strong>拷贝关系</strong></li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/3.png" alt=""></p>
<p><strong>页大小</strong>：4KB、8KB、$\cdots$</p>
<p><strong>映射算法</strong>：全相联映射</p>
<p><strong>写策略</strong>：写回法</p>
<ul>
<li>被替换出来才修改硬盘中的数据</li>
</ul>
<p><strong>种类</strong>：</p>
<ul>
<li><p><strong>分页式虚拟存储器</strong></p>
</li>
<li><p>分段式虚拟存储器</p>
</li>
<li><p>段页式虚拟存储器</p>
</li>
</ul>
<h2 id="分页式虚拟存储器"><a href="#分页式虚拟存储器" class="headerlink" title="分页式虚拟存储器"></a>分页式虚拟存储器</h2><p><strong>主存储器和虚拟地址空间都被划分成大小相等的页面</strong></p>
<ul>
<li><p><strong>虚拟页/逻辑页</strong>：虚拟地址空间中的页面</p>
</li>
<li><p><strong>物理页/页框</strong>：主存空间中的页面</p>
</li>
</ul>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表中包含了<strong>所有虚拟页的信息</strong>，包括<u>虚拟页的存放位置、有效位（<strong>有无被加载到物理内存中</strong>）、修改位、存取权限位</u>等等</p>
<ul>
<li>保存在主存中</li>
</ul>
<p><strong>虚拟地址：<u>页号+页内偏移量</u></strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>页号</th>
<th>页内偏移量</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>根据页表中记录的物理页存放位置，可以将虚拟地址转化为物理地址</p>
<ul>
<li>虚拟页号 + 页内偏移量 $\rightarrow$ 物理页号 + 页内偏移量</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/8.png" alt=""></p>
<ul>
<li><p><strong>location没写</strong>：指向硬盘的指针</p>
</li>
<li><p><strong>loaction = null</strong>：表示磁盘里没有，而不是内存中没有</p>
</li>
<li><p><strong>虚拟页号比物理页号大一些</strong></p>
<ul>
<li>虚拟页号没必要存储，按照相应的物理页号位置来找虚拟页号的位置</li>
</ul>
</li>
</ul>
<p>如果location的长度是不同的，那么必须<strong>按照最长的部分等长存储</strong>，以免无法进行更换</p>
<h3 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h3><p>为了减少对内存的访问，我们将<strong>常用的页表的行</strong>放到Cache中去</p>
<ul>
<li><p>需要在前面加上个标记<strong>表示第几行</strong> </p>
</li>
<li><p>映射方式：<strong>全相联映射、组相联映射</strong></p>
</li>
<li><p>替换策略：<strong>随机替换</strong></p>
</li>
</ul>
<h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/9.png" alt=""></p>
<p>我们只要将虚拟页号根据页表转换到物理页号中去</p>
<ul>
<li><p>前提：<strong>在物理内存中</strong></p>
</li>
<li><p><strong>如果hit，直接传入物理地址；如果miss，到页表中去访问</strong></p>
<ul>
<li><p>这里的hit和miss发生在Cache中，因为TLB存放在Cache中</p>
</li>
<li><p>如果hit并且是invaild（无效）的情况下，我们用硬盘把页送到内存中去，<strong>然后到Cache正常访问</strong></p>
<ul>
<li>有效位是表示有无加载到物理内存中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果没在物理内存中的话，就是发生了<strong>缺页操作</strong>，于是对磁盘进行操作</p>
<ul>
<li>也就是invaild操作</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/10.png" alt=""></p>
<h4 id="TLB、页表、Cache缺失组合"><a href="#TLB、页表、Cache缺失组合" class="headerlink" title="TLB、页表、Cache缺失组合"></a>TLB、页表、Cache缺失组合</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>TLB</th>
<th>页</th>
<th>Cache</th>
<th>可能性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>hit</td>
<td>hit</td>
<td>hit</td>
<td>可能</td>
<td>TLB命中则页一定命中，信息在主存里，就可能在Cache中</td>
</tr>
<tr>
<td>2</td>
<td>hit</td>
<td>hit</td>
<td>miss</td>
<td>可能</td>
<td>TLB命中则页一定命中，信息在主存里，可能不在Cache中</td>
</tr>
<tr>
<td>3</td>
<td>miss</td>
<td>hit</td>
<td>hit</td>
<td>可能</td>
<td>TLB缺失但页可能命中，信息在主存里，就可能在Cache中</td>
</tr>
<tr>
<td>4</td>
<td>miss</td>
<td>hit</td>
<td>miss</td>
<td>可能</td>
<td>TLB缺失但页可能命中，信息在主存里，但可能不在Cache中</td>
</tr>
<tr>
<td>5</td>
<td>miss</td>
<td>miss</td>
<td>miss</td>
<td>可能</td>
<td>TLB缺失，则页也可能缺失，信息不在主存，一定也不在Cache</td>
</tr>
<tr>
<td>6</td>
<td>hit</td>
<td>miss</td>
<td>miss</td>
<td>不可能</td>
<td>页缺失，说明信息不在主存，TLB一定没有该页表项</td>
</tr>
<tr>
<td>7</td>
<td>hit</td>
<td>miss</td>
<td>hit</td>
<td>不可能</td>
<td>页缺失，说明信息不在主存，TLB一定没有该页表项</td>
</tr>
<tr>
<td>8</td>
<td>miss</td>
<td>miss</td>
<td>hit</td>
<td>不可能</td>
<td>页缺失，说明信息不在主存，Cache一定没有该信息</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>Cache是内存的拷贝</p>
</li>
<li><p><strong>TLB miss的情况下只是比hit的情况多一次内存访问</strong></p>
</li>
</ul>
<p><strong>访问主存和硬盘次数</strong>：</p>
<ul>
<li><p><strong>无需访问主存</strong>：1</p>
</li>
<li><p><strong>访问一次主存</strong>：2、3</p>
</li>
<li><p><strong>访问两次主存</strong>：4</p>
</li>
<li><p><strong>访问2次主存，且访问硬盘</strong>：5</p>
</li>
</ul>
<h2 id="分段式虚拟存储器"><a href="#分段式虚拟存储器" class="headerlink" title="分段式虚拟存储器"></a>分段式虚拟存储器</h2><p>将程序和数据分成不同长度的段，将所需的段加载到主存中</p>
<p><strong>虚拟地址：段号 + 段内偏移量</strong></p>
<p><strong>优点</strong>：段的分解与程序的自然分解相对应，易于变易、管理、修改和保护</p>
<p><strong>缺点</strong>：段的长度不固定</p>
<h2 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h2><p>将程序和数据分段，段内再进行分页</p>
<ul>
<li>每个分段都有一个页表</li>
</ul>
<p><strong>虚拟地址：段号 + 页号 + 页内偏移量</strong></p>
<p><strong>优点</strong>：程序按段实现共享与保护</p>
<p><strong>缺点</strong>：需要多次查表</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/11/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/" class="post-title-link" itemprop="url">外部存储器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-27 15:46:18 / 修改时间：15:47:04" itemprop="dateCreated datePublished" datetime="2023-11-27T15:46:18+08:00">2023-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机组织与结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>特性：</p>
<ul>
<li><p>用于<u>不经常使用的、数据量较大的信息</u></p>
</li>
<li><p>非易失性</p>
</li>
</ul>
<p>类型：</p>
<ul>
<li><p><strong>磁盘存储器</strong></p>
<ul>
<li><p>软盘floppy disk</p>
</li>
<li><p><strong>硬盘hard disk</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-1.png" alt=""></p>
</li>
</ul>
</li>
<li><p>光存储器</p>
</li>
<li><p>磁带</p>
</li>
<li><p>U盘</p>
</li>
<li><p>固态硬盘</p>
</li>
</ul>
<h2 id="硬磁盘存储器"><a href="#硬磁盘存储器" class="headerlink" title="硬磁盘存储器"></a>硬磁盘存储器</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>磁盘存储器<u>每个盘片表面有一个读写磁头</u>，所有磁头通过机械方式固定在一起，同时移动</p>
<ul>
<li>磁头<u>对盘片进行读写操作</u></li>
</ul>
<p><strong>在任何时候，所有磁头都位于距离磁盘中心等距离的轨道上</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-2.png" alt=""></p>
<ul>
<li><p>蓝色代表<strong>主轴</strong></p>
</li>
<li><p>红色代表<strong>磁盘</strong></p>
</li>
<li><p>绿色代表<strong>磁臂和磁头</strong></p>
</li>
</ul>
<h3 id="读写机制"><a href="#读写机制" class="headerlink" title="读写机制"></a>读写机制</h3><p>在读写操作期间，<strong>磁头静止</strong>，盘片在其下方进行旋转</p>
<ul>
<li><p>单磁头：读写共用</p>
</li>
<li><p>双磁头：使用一个单独的磁头进行读取</p>
</li>
</ul>
<h3 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h3><p>盘片上的数据组织呈现为一组同心圆环，称为<strong>磁道</strong></p>
<p>数据以<strong>扇区</strong>的形式传输到磁盘或传出</p>
<ul>
<li><strong>默认为512B</strong></li>
</ul>
<p>相邻磁道之间有<strong>间隙</strong>，相邻扇区之间也有</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-4.png" alt=""></p>
<p>所有盘片上处于<strong>相同的相对位置</strong>的一组磁道称为<strong>柱面</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-7.png" alt=""></p>
<p><strong>扇区划分</strong>：</p>
<ol>
<li><p><strong>恒定角速度</strong></p>
<p> 保持读写速度恒定，<u>能以磁道号和扇区号直接寻址各个数据块</u></p>
<p> <img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-5.png" alt=""></p>
</li>
<li><p><strong>多带式记录</strong></p>
<p> 将盘面划分为多个同心圆区域，每个区域中各磁道的扇区数量时相同的，<u>距离中心较远的分区包含的扇区数多于距离中心的分区</u><br> <img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-6.png" alt=""></p>
</li>
</ol>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>磁道必须有一些起始点和辨别每个扇区起点和终点的方法</p>
<p>格式化时会附有一些<strong>仅被磁盘驱动器使用</strong>而不被用户存取的额外数据</p>
<h3 id="I-O访问时间"><a href="#I-O访问时间" class="headerlink" title="I/O访问时间"></a>I/O访问时间</h3><p><strong>寻道时间</strong>：磁头定位到所需移动到的磁道花费的时间</p>
<ul>
<li>初始启动时间，跨越若干磁道所用的时间</li>
</ul>
<p><strong>旋转延迟</strong>：等待响应扇区的起始处到达磁头所需的时间</p>
<ul>
<li>通常是<strong>磁道旋转半周的时间</strong></li>
</ul>
<p><strong>传送时间</strong>：数据传输所需的时间</p>
<ul>
<li>假设：T = 传送时间、b = 传送的字节数、N = 每磁道的字节数、r = 旋转速率(转/秒)，那么$T = \frac{b}{rN}$</li>
</ul>
<p><strong>平均访问时间</strong>：$T_a = T_s + \frac{1}{2r} + \frac{b}{rN}$</p>
<ul>
<li>$T_s$ 是平均寻道时间</li>
</ul>
<p>对于连续访问多个相邻磁道时，<strong>对于每个磁道都要考虑旋转延迟，通常只需要考虑第一个磁道的寻道时间</strong></p>
<ul>
<li>除非明确知道跨越一个磁道需要的时间</li>
</ul>
<h3 id="磁头寻道-磁盘调度"><a href="#磁头寻道-磁盘调度" class="headerlink" title="磁头寻道/磁盘调度"></a>磁头寻道/磁盘调度</h3><ol>
<li><p><strong>先来先服务FCFS</strong></p>
<p> 按照请求访问磁盘的先后次序进行处理</p>
</li>
<li><p><strong>最短寻道时间优先SSTF</strong></p>
<p> 优先处理起始位置与当前磁头位置最接近的读写任务</p>
<p> 可能会出现<strong>饥饿</strong>现象，尤其是位于两端的磁道请求</p>
</li>
<li><p><strong>扫描/电梯SCAN</strong></p>
<p> 总是按照一个方向进行磁盘调度，知道该方向上的边缘，然后改变方向</p>
</li>
<li><p><strong>循环扫描C-SCAN</strong></p>
<p> <strong>只有磁头朝某个方向移动时才会响应请求</strong>，移动到边缘后立即让磁头返回起点（<strong>0</strong>），返回途中不做任何处理</p>
<ul>
<li><strong>从N跳到0</strong></li>
</ul>
</li>
<li><p><strong>LOOK</strong></p>
<p> 只要磁头移动方向上不再有请求就立即改变磁头方向</p>
</li>
<li><p><strong>C-LOOK</strong></p>
<p> 只要在磁头移动方向上不再有请求，就立即让磁头返回起点（<strong>不是0</strong>）</p>
</li>
</ol>
<h2 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h2><p>比如<u>光盘(CD)、光盘只读存储器(CD-ROM)、可刻录光盘(CD-R)、可重写光盘(CD-RW)、数字多功能光盘(DVD)</u>等</p>
<h2 id="CD和CD-ROM"><a href="#CD和CD-ROM" class="headerlink" title="CD和CD-ROM"></a>CD和CD-ROM</h2><p>CD-ROM更加耐用且有纠错功能</p>
<p>通过安装在光盘播放器或启动装置内的低强度激光束从CD或CD-ROM读取信息</p>
<ul>
<li><p><strong>凹坑</strong>反射回<strong>低强度激光</strong></p>
</li>
<li><p><strong>台</strong>反射回<strong>高强度激光</strong></p>
</li>
</ul>
<p>盘片上包含一条<strong>单螺旋轨道</strong>，轨道上的所有扇区长度相同</p>
<p><strong>优点</strong>：廉价地大规模复制，可更换</p>
<p><strong>缺点</strong>：只读，存取时间长</p>
<h2 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h2><p>使用与磁盘类似的记录和读取技术</p>
<p>读取：<strong>顺序读取</strong></p>
<ul>
<li>磁盘是直接读取</li>
</ul>
<h2 id="U盘"><a href="#U盘" class="headerlink" title="U盘"></a>U盘</h2><p>采用了快闪存储器，属于<strong>非易失性半导体存储器</strong>，体积小容量大，携带方便</p>
<ul>
<li>固态硬盘容量更大，存储性能更好</li>
</ul>
<h2 id="冗余磁盘阵列RAID"><a href="#冗余磁盘阵列RAID" class="headerlink" title="冗余磁盘阵列RAID"></a>冗余磁盘阵列RAID</h2><p>将多个独立操作的磁盘按某种方式组织成磁盘阵列，以增加容量</p>
<ul>
<li>将数据存储在多个盘体上，通过这些盘并行工作来提高数据传输率</li>
</ul>
<p>采用<strong>数据冗余</strong>来进行错误恢复以提高系统可靠性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>级别</th>
<th>种类</th>
<th>描述</th>
<th>磁盘要求</th>
<th>数据可用性</th>
<th>大I/O数据传输能力</th>
<th>小I/O请求速率</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>条带化</td>
<td>非冗余</td>
<td><strong>N</strong></td>
<td>比单盘低</td>
<td>很高</td>
<td>读和写都很高</td>
</tr>
<tr>
<td>1</td>
<td>镜像</td>
<td>镜像</td>
<td><strong>2N</strong></td>
<td>比RAID 2、3、4、5高，比6低</td>
<td>读比单盘高，写和单盘类似</td>
<td>读高达单盘的两倍，写和单盘类似</td>
</tr>
<tr>
<td>2</td>
<td>并行存取</td>
<td><strong>海明码校验</strong></td>
<td><strong>N+m</strong></td>
<td>比单盘高很多，与RAID 3、4、5差不多</td>
<td>列表各级中最高</td>
<td>接近单盘的两倍</td>
</tr>
<tr>
<td>3</td>
<td>并行存取</td>
<td>位交错奇偶校验</td>
<td><strong>N+1</strong></td>
<td>比单盘高很多，与RAID 2、4、5差不多</td>
<td>列表各级中最高</td>
<td>接近单盘的两倍</td>
</tr>
<tr>
<td>4</td>
<td>独立存取</td>
<td>块交错奇偶校验</td>
<td><strong>N+1</strong></td>
<td>比单盘高很多，与RAID 2、3、5差不多</td>
<td>读和RAID 0类似，写低于单盘</td>
<td>读与RAID 0类似，写显著低于单盘</td>
</tr>
<tr>
<td>5</td>
<td>独立存取</td>
<td>块交错奇偶校验</td>
<td><strong>N+1</strong></td>
<td>比单盘高很多，与RAID 2、3、4差不多</td>
<td>读和RAID 0类似，写低于单盘</td>
<td>读与RAID 0类似，写显著低于单盘</td>
</tr>
<tr>
<td>6</td>
<td>独立存取</td>
<td>块交错奇偶校验</td>
<td><strong>N+2</strong></td>
<td>列表各级中最高</td>
<td>读和RAID 0类似，写比RAID 5低</td>
<td>读与RAID 0类似，写显著低于RAID 5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p>数据以条带的形式在可用的磁盘上分布</p>
<p><strong>不采用冗余来改善性能</strong></p>
<ul>
<li>不是RAID家族的真正成员</li>
</ul>
<p>用途：</p>
<ol>
<li><p>高数据传输率</p>
</li>
<li><p>高速响应I/O请求</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/2.png" alt=""></p>
<h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><p>采用数据条带，简单<strong>备份所有数据</strong>来实现冗余</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/4.png" alt=""></p>
<p>优点：</p>
<ol>
<li><p>高速响应I/O请求</p>
</li>
<li><p>读请求可以选择<strong>寻道时间较小的那个</strong></p>
</li>
<li><p>写请求可以并行完成，受限于写入较慢的磁盘</p>
</li>
</ol>
<ul>
<li>需要更新两个对应的条带</li>
</ul>
<ol>
<li>恢复受损磁盘简单</li>
</ol>
<p>用途：</p>
<p>只限于用在存储系统软件、数据和其他关键文件的驱动器中</p>
<h3 id="RAID-2"><a href="#RAID-2" class="headerlink" title="RAID 2"></a>RAID 2</h3><p>采用并行存取技术，所有磁盘都参与<strong>每个</strong>I/O请求的执行</p>
<p>纠错（<strong>海明码</strong>）：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/5.png" alt=""></p>
<ul>
<li>纠错能力强于RAID 2</li>
</ul>
<p>访问：</p>
<ul>
<li><p>读取：获取请求的数据和对应的校验码</p>
</li>
<li><p>写入：所有数据盘和校验盘都被访问</p>
</li>
</ul>
<h3 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h3><p>优点：</p>
<ul>
<li><p>能够获得非常高的数据传输率</p>
<ul>
<li>对于大量传送，性能改善特别明显</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>一次只能执行一个I/O请求</p>
<ul>
<li>面向多个I/O请求，性能将受损</li>
</ul>
</li>
</ul>
<h3 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID 4"></a>RAID 4</h3><p>采用独立存取技术，采用相对较大的数据条带，根据各个数据盘上的数据来逐位计算奇偶校验条带</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/7.png" alt=""></p>
<p>性能：</p>
<ul>
<li><p>当执行较小规模的I/O写请求时，RAID 4会遭遇写损失</p>
<ul>
<li>每一次写操作，不仅要修改用户数据，而且要<strong>修改对应的校验位</strong></li>
</ul>
</li>
</ul>
<h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p>与RAID 4组织方式相似，但<strong>在所有磁盘上都分布了奇偶校验条带</strong></p>
<ul>
<li>避免潜在的I/O瓶颈问题</li>
</ul>
<p>访问时需要<strong>两读两写</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/8.png" alt=""></p>
<h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p>采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中</p>
<p>优点：</p>
<ul>
<li>提升数据可用性</li>
</ul>
<p>缺点：</p>
<ul>
<li>写损失：<strong>每次都要影响到两个校验块</strong></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/9.png" alt=""></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/" class="post-title-link" itemprop="url">内部存储器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-24 01:51:07" itemprop="dateCreated datePublished" datetime="2023-11-24T01:51:07+08:00">2023-11-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-27 14:16:13" itemprop="dateModified" datetime="2023-11-27T14:16:13+08:00">2023-11-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">计算机组织与结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>存储器由一定数量的单元构成，每个单元可以被唯一标识，<u>每个单元都有存储一个数值的能力</u></p>
<ul>
<li><p><strong>地址</strong>：单元的唯一标识符</p>
</li>
<li><p><strong>地址空间</strong>：可唯一标识的单元总数</p>
</li>
<li><p><strong>寻址空间</strong>：<u>存储在每个单元中的信息的位数</u></p>
<ul>
<li>大多数存储器是<strong>字节寻址</strong>的</li>
</ul>
</li>
</ul>
<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.U_KazHXkAlJ1Ox3D238pSwHaEv?rs=1&amp;pid=ImgDetMain" alt="存储器层次结构_存储系统的层次结构_亚撒西带师的博客-CSDN博客"></p>
<h2 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h2><p><strong>位元</strong>(memory cell)：半导体存储器的基本元件，用于存储<strong>1位</strong>数据</p>
<ul>
<li><p><strong>呈现两种稳态（或半稳态）</strong>：分别表示二进制的0和1</p>
</li>
<li><p><strong>能够至少被写入数据一次</strong>：用来设置状态</p>
</li>
<li><p><strong>能够被读取来获取状态信息</strong></p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-1.png" alt=""></p>
<p>半导体存储器类别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>种类</th>
<th>可擦性</th>
<th>写机制</th>
<th>易失性</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机存取存储器(RAM)</td>
<td><strong>读-写存储器</strong></td>
<td>电可擦除，字节级</td>
<td>电</td>
<td><strong>易失</strong></td>
</tr>
<tr>
<td>只读存储器(ROM)</td>
<td>只读存储器</td>
<td><strong>不可能</strong></td>
<td><strong>掩膜</strong></td>
<td>非易失</td>
</tr>
<tr>
<td>可编程ROM(PROM)</td>
<td>只读存储器</td>
<td><strong>不可能</strong></td>
<td>电</td>
<td>非易失</td>
</tr>
<tr>
<td>可擦除PROM(EPROM)</td>
<td>主要进行读操作的存储器</td>
<td>紫外线可擦除，芯片级</td>
<td>电</td>
<td>非易失</td>
</tr>
<tr>
<td>电可擦除PROM(EEPROM)</td>
<td>主要进行读操作的存储器</td>
<td>电可擦除，字节级</td>
<td>电</td>
<td>非易失</td>
</tr>
<tr>
<td>快闪存储器</td>
<td>主要进行读操作的存储器</td>
<td>电可擦除，块级</td>
<td>电</td>
<td>非易失</td>
</tr>
</tbody>
</table>
</div>
<h3 id="随机存取存储器-RAM"><a href="#随机存取存储器-RAM" class="headerlink" title="随机存取存储器(RAM)"></a>随机存取存储器(RAM)</h3><p>特性：</p>
<ul>
<li><p>可以简单快速地进行读/写操作</p>
</li>
<li><p><strong>易失的（Volatile）</strong></p>
</li>
</ul>
<p>类型：</p>
<ol>
<li><p><strong>DRAM（动态RAM）</strong>：</p>
<p> 在电容器上用<strong>电容充电</strong>的方式存储数据</p>
<ul>
<li><p>电容器有无电荷分别代表二进制1和0</p>
<p><strong>需要周期地充电刷新以维护数据存储</strong></p>
</li>
<li><p><u>电容器有漏电的自然趋势</u></p>
</li>
<li><p>有一个阈值来确定电荷是解释为1还是0</p>
</li>
<li><p>刷新是<strong>异步刷新</strong></p>
<p>传统DRAM是异步的</p>
</li>
</ul>
<ol>
<li><p>处理器向内存提供地址和控制信号，表示内存中特定单元的一组数据应该被读出或写入DRAM </p>
</li>
<li><p>DRAM执行各种内部功能，如激活行和列地址线的高电容，读取数据，以及通过输出缓冲将数据输出，<strong>处理器只能等待这段延迟，即存取时间</strong></p>
</li>
<li><p>延时后，DRAM才写入或读取数据</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-3.png" alt=""></p>
</li>
</ol>
</li>
<li><p><strong>SRAM（静态RAM）</strong>：</p>
<p> 使用<strong>传统触发器、逻辑门配置</strong>来存储二进制值</p>
<ul>
<li><p>使用与处理器相同的逻辑元件</p>
<p><strong>只要有电源，就可以一直维持数据</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-4.png" alt=""></p>
</li>
</ul>
</li>
</ol>
<h4 id="DRAM和SRAM对比"><a href="#DRAM和SRAM对比" class="headerlink" title="DRAM和SRAM对比"></a>DRAM和SRAM对比</h4><p><strong>相同</strong>：</p>
<ul>
<li><strong>易失性</strong>：<u>两者都要求电源持续供电才能保持位值</u></li>
</ul>
<p><strong>不同</strong>：</p>
<ul>
<li><p>DRAM具有更简单、更小的位元，但要求能支持刷新的电路</p>
</li>
<li><p>DRAM密度更高，价格更低</p>
</li>
<li><p>SRAM通常更快</p>
</li>
<li><p>DRAM倾向满足大容量存储器的需求，<strong>SRAM一般用于高速缓存，SRAM用于主存</strong></p>
</li>
</ul>
<h4 id="高级DRAM架构"><a href="#高级DRAM架构" class="headerlink" title="高级DRAM架构"></a>高级DRAM架构</h4><p>传统的DRAM芯片受到其内部架构与处理器内存总线接口的限制</p>
<p>类型：</p>
<ol>
<li><p><strong>SDRAM（同步DRAM）</strong>：</p>
<p> SDRAM与处理器的数据交互同步与外部的时钟信号，并且以处理器/存储器总线的<strong>最高速度</strong>运行，<strong>不需要插入等待状态</strong></p>
<ul>
<li><p>由于<strong>SDRAM随系统时钟及时移动数据</strong>，CPU直到数据何时准备好，控制器可以完成其他工作</p>
</li>
<li><p>异步是需要再次沟通的，而<strong>同步是减少一些交互，确定具体的交互时间（延迟时间）</strong></p>
<p>数据读写是在时钟周期的<strong>上升点</strong>进行</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-5.png" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>DDR SDRAM（双速率SDRAM）</strong>：</p>
<p> 每个时钟周期发送两次数据，<strong>一次在时钟脉冲的上升沿，一次在下降沿</strong></p>
<p> DDR $\rightarrow$ DDR2 $\rightarrow$ DDR3 $\rightarrow$ DDR4</p>
<ul>
<li><p>增加操作频率</p>
</li>
<li><p>增加预取缓冲区</p>
</li>
</ul>
</li>
</ol>
<h3 id="只读存储器-ROM"><a href="#只读存储器-ROM" class="headerlink" title="只读存储器(ROM)"></a>只读存储器(ROM)</h3><p>特性：</p>
<ul>
<li><p><strong>非易失性</strong>：不要求供电来维持数据</p>
</li>
<li><p><strong>只可读</strong>：但不能写入新数据</p>
</li>
</ul>
<p>应用：</p>
<ul>
<li>微程序设计、库子系统、系统程序、函数表</li>
</ul>
<p>问题：</p>
<ul>
<li><p><strong>无出错处理机会</strong></p>
</li>
<li><p><strong>用户无法写入数据</strong></p>
<ul>
<li>唯一的数据写入机会在出厂时完成</li>
</ul>
</li>
</ul>
<h3 id="可编程ROM-PROM"><a href="#可编程ROM-PROM" class="headerlink" title="可编程ROM(PROM)"></a>可编程ROM(PROM)</h3><p>PROM提供了灵活性和方便性，在大批量生产领域仍具有吸引力</p>
<p>特性：</p>
<ul>
<li><p><strong>非易失性</strong></p>
</li>
<li><p><strong>只能写入一次</strong></p>
<ul>
<li><p>写过程是用电信号执行</p>
</li>
<li><p>需要特殊设备来完成写或“编程”过程</p>
</li>
</ul>
</li>
</ul>
<h3 id="可擦除可编程“只读”存储器-EPROM"><a href="#可擦除可编程“只读”存储器-EPROM" class="headerlink" title="可擦除可编程“只读”存储器(EPROM)"></a>可擦除可编程“只读”存储器(EPROM)</h3><p>EPROM比PROM更贵，但有<strong>可多次改写</strong>的优点</p>
<p>特性：</p>
<ul>
<li><p><strong>光擦除</strong>：在写操作前将封装芯片暴露在紫外线下</p>
<ul>
<li><p>所有的存储单元都便会相同的初始状态</p>
</li>
<li><p>每次擦除需要约20分钟</p>
</li>
</ul>
</li>
<li><p><strong>电写入</strong></p>
</li>
</ul>
<h3 id="电可擦除可编程“只读”存储器-EEPROM"><a href="#电可擦除可编程“只读”存储器-EEPROM" class="headerlink" title="电可擦除可编程“只读”存储器(EEPROM)"></a>电可擦除可编程“只读”存储器(EEPROM)</h3><p>与EPROM对比，EEPROM更贵，且密度低，支持小容量芯片</p>
<p>特性：</p>
<ul>
<li><p><strong>可以随时写入而不删除之前的内容</strong></p>
</li>
<li><p>只更新寻址到的一个或多个字节</p>
</li>
<li><p>写操作每字节需要几百微秒</p>
</li>
</ul>
<h3 id="快闪存储器"><a href="#快闪存储器" class="headerlink" title="快闪存储器"></a>快闪存储器</h3><p>价格和功能介于EPROM和EEPROM之间</p>
<p>特性：</p>
<ul>
<li><p><strong>电可擦除</strong></p>
<ul>
<li>与EEPROM相同</li>
</ul>
</li>
<li><p>擦除时间为几秒</p>
<ul>
<li>优于EPROM，不如EEPROM</li>
</ul>
</li>
<li><p><strong>可以在块级擦除，不能在字节级擦除</strong></p>
<ul>
<li>优于EPROM，不如EEPROM</li>
</ul>
</li>
</ul>
<h2 id="从位元到主存"><a href="#从位元到主存" class="headerlink" title="从位元到主存"></a>从位元到主存</h2><h3 id="寻址单元"><a href="#寻址单元" class="headerlink" title="寻址单元"></a>寻址单元</h3><p>寻址单元由<u>若干相同地址的位元</u>组成</p>
<p>每个寻址单元内的数据不能进行局部修改，而是<strong>整体修改</strong></p>
<p>寻址模式：</p>
<ul>
<li><p><strong>字节(Byte)</strong>：常用</p>
</li>
<li><p><strong>字(Word)</strong></p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-7.png" alt=""></p>
<h3 id="存储阵列"><a href="#存储阵列" class="headerlink" title="存储阵列"></a>存储阵列</h3><p>存储阵列由<u>大量寻址单元</u>组成</p>
<p>选中就是对行和列进行加电，然后<strong>同时被加电的地方被选中</strong></p>
<p><strong>随机访问</strong>：先读取地址，然后找到行和列，然后选中，所以<u>无论是什么单元，都是一样的访问时间</u></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-8.png" alt=""></p>
<h3 id="如何寻址"><a href="#如何寻址" class="headerlink" title="如何寻址"></a>如何寻址</h3><p>地址译码器：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-9.png" alt=""></p>
<h3 id="如何刷新"><a href="#如何刷新" class="headerlink" title="如何刷新"></a>如何刷新</h3><p><strong>存储周期</strong>：读/写一次所耗费的时间</p>
<ul>
<li>某行刷新一次的时间也等于一个存取周期</li>
</ul>
<p><strong>刷新间隔</strong>：所有存储单元都刷新一遍的时间</p>
<p>刷新类型：</p>
<ol>
<li><p><strong>集中式刷新(Centralized refresh)</strong></p>
<p> 停止读写操作，并刷新每一行</p>
<ul>
<li>刷新时无法操作内存</li>
</ul>
</li>
<li><p><strong>分散式刷新(Decentralized refresh)</strong></p>
<p> 在每个存储周期中，当读写操作完成时进行刷新</p>
<ul>
<li>会增加每个存储周期的时间</li>
</ul>
</li>
<li><p><strong>异步刷新(Asynchronous refresh)</strong></p>
<p> 每一行各自以64ms间隔刷新（按时间切割）</p>
<ul>
<li>效率高</li>
</ul>
</li>
</ol>
<h3 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h3><p>芯片引脚：</p>
<ul>
<li><p>Address：A0-A19</p>
</li>
<li><p>Data：D0-D7</p>
</li>
<li><p>Vcc：电源</p>
</li>
<li><p>Vss：地线</p>
</li>
<li><p><strong>CE：芯片允许引脚</strong></p>
</li>
<li><p>Vpp：程序电压</p>
</li>
<li><p><strong>WE：写允许</strong></p>
</li>
<li><p><strong>OE：读允许</strong></p>
</li>
<li><p><strong>RAS：行地址选通</strong></p>
</li>
<li><p><strong>CAS：列地址选通</strong></p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-10.png" alt=""></p>
<h3 id="模块组织"><a href="#模块组织" class="headerlink" title="模块组织"></a>模块组织</h3><ol>
<li><p><strong>位扩展</strong></p>
<p> 地址线不变，数据线增加</p>
<ul>
<li><p>使用8个4K*1bit的芯片组成4K*8bit的存储器</p>
<p><img src="https://pic1.zhimg.com/80/v2-668d7fef957899e9bc5d5790febdd3a8_1440w.webp" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>字扩展</strong></p>
<p> 地址线增加，数据线不变</p>
<ul>
<li><p>使用4个16K*8bit的芯片组成64K*8bit的存储器</p>
<p><img src="https://pic3.zhimg.com/80/v2-3a3f476d1753811c04e942031536caaa_1440w.webp" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>字位扩展</strong></p>
<p> 地址线增加，数据线增加</p>
<p> 使用8个16K*4bit的芯片组成64K*8bit的存储器</p>
<p> <img src="https://pic3.zhimg.com/80/v2-edee52a951e146238e2b77bdf7563f6e_1440w.webp" alt=""></p>
</li>
</ol>
<h2 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h2><p>CPU的速度比内存的速度块，且两者的差距不断扩大，导致出现<strong>内存墙</strong></p>
<h3 id="Cache的基本思路"><a href="#Cache的基本思路" class="headerlink" title="Cache的基本思路"></a>Cache的基本思路</h3><p>在使用主存之余，添加一块小而快的Cache，<strong>存放主存中部分信息的副本</strong></p>
<ul>
<li>Cache位于CPU和主存之间，可以集成在CPU内部或作为主板上的一个模块</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-1.png" alt=""></p>
<h3 id="Cache运行流程"><a href="#Cache运行流程" class="headerlink" title="Cache运行流程"></a>Cache运行流程</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-2.png" alt=""></p>
<ol>
<li><p><strong>检查</strong>：当CPU试图访问主存中的某个字时，会首先检查这个字是否在Cache中</p>
</li>
<li><p>检查后分两种情况：</p>
</li>
</ol>
<ul>
<li><p><strong>命中hit</strong>：如果在Cache则把这个字传送给CPU</p>
</li>
<li><p><strong>未命中miss</strong>：如果不在Cache，则将主存中包含这个字固定大小的块读入Cache中，然后<strong>再从Cache传送该字给CPU</strong></p>
</li>
</ul>
<p><strong>无论如何Cache都会首先访问Cache</strong></p>
<p>Cache通过<strong>标记tags</strong>来标识其内容在主存中的对应位置</p>
<ul>
<li>将Cache中每一行的标记和目标地址的标记进行比较，如果有相同即为命中</li>
</ul>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>定义：<u>处理器频繁访问主存中相同位置或相邻存储位置的现象</u></p>
<p>类型：</p>
<ol>
<li><p><strong>时间局部性</strong>：在相对较短的时间周期内，重复访问特定的信息</p>
<ul>
<li><p>也就是相同位置的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> factorial = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">	factorial = factorial * i;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>空间局部性</strong>：在相对较短的时间周期内，访问相邻存储位置的数据</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">	score[i] = final[i] * <span class="number">0.4</span> + midterm[i] * <span class="number">3</span> + assign[i] * <span class="number">0.2</span> + activity[i] * <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>顺序局部性</strong>：线性排列并访问</li>
</ul>
</li>
</ol>
<p>由于时间局部性，将未命中的数据再返回给CPU的同时存放在Cache中，<strong>以便再次访问命中</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-4.png" alt=""></p>
<p>由于空间局部性，将包含所访问的字的块存储到Cache中，<strong>以便在访问相邻数据时命中</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-5.png" alt=""></p>
<p><u>搬一个块的时间要比一次次搬块内每个单元的时间要快</u>，因此Cache能节省时间</p>
<h4 id="平均访问时间"><a href="#平均访问时间" class="headerlink" title="平均访问时间"></a>平均访问时间</h4><p>设P是命中率，$T_c$是Cache的访问时间，$T_m$是主存的访问时间</p>
<ul>
<li><p><strong>使用Cache的平均访问时间</strong>：$T_a = p \times T_c + (1-P) \times (T_c + T_m) = T_c + (1 - P) \times T_m$</p>
<ul>
<li><p>命中率P越大，$T_c$越小，效果越好</p>
</li>
<li><p>如果想要$T_a &lt; T_m$，必须要求$P &gt; \frac{T_c}{T_m}$</p>
</li>
</ul>
</li>
</ul>
<h3 id="Cache容量"><a href="#Cache容量" class="headerlink" title="Cache容量"></a>Cache容量</h3><p>扩大Cache容量后果：</p>
<ul>
<li><p>增大命中率P</p>
</li>
<li><p>增加Cache的开销和访问时间$T_c$</p>
<ul>
<li>随着块的增大，P增长会放缓，因为过大就<strong>不满足局部性原理</strong>了</li>
</ul>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-6.png" alt=""></p>
<h3 id="映射功能"><a href="#映射功能" class="headerlink" title="映射功能"></a>映射功能</h3><p>实现主存块到Cache行的映射</p>
<p>映射方式的选择会影响Cache的组织结构</p>
<ul>
<li><p><strong>直接映射</strong></p>
</li>
<li><p><strong>全关联映射</strong></p>
</li>
<li><p><strong>组关联映射</strong></p>
</li>
</ul>
<h4 id="Cache和主存结构"><a href="#Cache和主存结构" class="headerlink" title="Cache和主存结构"></a>Cache和主存结构</h4><ol>
<li><p><strong>Cache</strong></p>
<ul>
<li><p>一行：tag + 行 + 字</p>
</li>
<li><p>一共m个块，也就是m行</p>
</li>
<li><p>tag是主存储器的一部分，用来<strong>识别当前储存的是哪一块</strong></p>
</li>
</ul>
</li>
<li><p>主存：字长，每一块（k字）</p>
</li>
</ol>
<h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p>将主存中的每个块映射到<strong>一个固定可用</strong>的Cache行中，适合大容量的Cache</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-8.png" alt=""></p>
<ul>
<li>$Cache行号 = 主存储器块号\: \% \:Cache行数$</li>
</ul>
<p>主存储器地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标记</th>
<th>Cache行号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>标记</strong>：地址中最高的n位，<strong>区分映射到同一行的不同块</strong></p>
<ul>
<li><p>$n = log_2M - log_2C$</p>
<ul>
<li>M为块数，C为Cache行数</li>
</ul>
</li>
<li><p>为了成本，要用尽可能少的位置存储tag</p>
</li>
</ul>
<p><strong>优点</strong>：简单、快速映射、快速检查</p>
<p><strong>缺点</strong>：两个块被重复使用的话有可能出现<strong>抖动</strong>的现象</p>
<h4 id="全关联映射"><a href="#全关联映射" class="headerlink" title="全关联映射"></a>全关联映射</h4><p>一个内存块可以装入Cache的<strong>任意一行</strong>，适合容量较小的Cache</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-10.png" alt=""></p>
<p>主存储器地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标记（块号）</th>
<th>字（块内地址）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>优点</strong>：避免抖动</p>
<p><strong>缺点</strong>：实现起来比较复杂，搜索代价大，即检查的时候需要去访问Cache每一行</p>
<h4 id="组关联映射"><a href="#组关联映射" class="headerlink" title="组关联映射"></a>组关联映射</h4><p>Cache分为若干组，每一组包含相同数量的行，每个主存块被映射到<strong>固定组的任意一行</strong>，面向不同容量的Cache做了折中</p>
<p><img src="https://www.whuanle.cn/wp-content/uploads/2022/09/image-1663471542219.png" alt="Cache 的映射方式 - 面向云技术架构 - 痴者工良"></p>
<ul>
<li>$Cache组号 = 主存块号\: \% \:组数$</li>
</ul>
<p>K - 路组关联映射：<strong>K是每一组的行数</strong></p>
<ul>
<li><p>K=1则等价于直接映射</p>
</li>
<li><p>K=Cache行数则等价于全关联映射</p>
</li>
</ul>
<p>主存储器地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标记</th>
<th>Cache组号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>标记</strong>：地址中最高的n位，<strong>区分映射到同一组的不同块</strong></p>
<ul>
<li><p>$n = log_2M - log_2S$</p>
<ul>
<li>M为块数，C为组数</li>
</ul>
</li>
</ul>
<h4 id="三种映射方式对比"><a href="#三种映射方式对比" class="headerlink" title="三种映射方式对比"></a>三种映射方式对比</h4><p><strong>关联度</strong>：一个主存块映射到Cache中可能存放的位置个数</p>
<ul>
<li><p>直接映射：1</p>
</li>
<li><p>全关联映射：Cache行数</p>
</li>
<li><p>全关联映射：每组的行数</p>
</li>
</ul>
<p>关联度越低，则<u>命中率越低、判断是否命中的时间越短、标记所占额外空间开销越小</u></p>
<h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><h4 id="最近最少使用算法-LRU"><a href="#最近最少使用算法-LRU" class="headerlink" title="最近最少使用算法(LRU)"></a>最近最少使用算法(LRU)</h4><p>替换在Cache中<strong>最长时间未被访问</strong>的数据块</p>
<ul>
<li>可以设计一个USE位，<strong>未被访问则加1，被访问则置0，替换USE位最大的行</strong></li>
</ul>
<h4 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h4><p>替换在Cache中<strong>停留时间最长</strong>的数据块</p>
<h4 id="最不经常使用算法-LFU"><a href="#最不经常使用算法-LFU" class="headerlink" title="最不经常使用算法(LFU)"></a>最不经常使用算法(LFU)</h4><p>替换Cache中<strong>被访问次数最少</strong>的数据块</p>
<ul>
<li>每行设置一个计数器</li>
</ul>
<h4 id="随机替换算法-Random"><a href="#随机替换算法-Random" class="headerlink" title="随机替换算法(Random)"></a>随机替换算法(Random)</h4><p><strong>随机</strong>替换Cache中的数据块</p>
<h3 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h3><ul>
<li><p>如果没被修改，则该数据块可以直接被替换掉</p>
</li>
<li><p>如果被修改，则在替换掉该数据块之前，必须将修改后的数据块写回到主存对应位置</p>
</li>
</ul>
<h4 id="缓存命中时写策略"><a href="#缓存命中时写策略" class="headerlink" title="缓存命中时写策略"></a>缓存命中时写策略</h4><ol>
<li><p><strong>写直达</strong></p>
<p> 所有写操作<strong>同时</strong>对Cache和主存进行</p>
<p> <strong>优点</strong>：确保主存中的数据总是和Cache中的数据一致</p>
<p> <strong>缺点</strong>：产生大量的主存访问，减慢写操作</p>
</li>
<li><p><strong>写回法</strong></p>
<p> 先更新Cache中的数据，当Cache中某个数据块<strong>被替换</strong>，如果它被修改了，才被写回主存</p>
<ul>
<li><p>利用<strong>脏位</strong>或<strong>使用位</strong>表示是否被修改</p>
<p><strong>优点</strong>：减少访问主存的次数</p>
<p><strong>缺点</strong>：部分主存数据可能不是最新的（未发生替换但需要读主存的场景）</p>
</li>
</ul>
</li>
</ol>
<h4 id="缓存未命中写策略"><a href="#缓存未命中写策略" class="headerlink" title="缓存未命中写策略"></a>缓存未命中写策略</h4><ol>
<li><p><strong>写不分配</strong>：</p>
<p> 直接将数据写入主存，无需读入Cache，通常搭配<strong>写直达</strong></p>
<p> <strong>优点</strong>：避免Cache和主存数据不一致</p>
</li>
<li><p><strong>写分配</strong>：</p>
<p> 将数据所在的块读入Cache后，在Cache中更新内容，通常搭配<strong>写回法</strong></p>
<p> <strong>优点</strong>：减少写内存次数</p>
</li>
</ol>
<h3 id="行大小"><a href="#行大小" class="headerlink" title="行大小"></a>行大小</h3><ul>
<li><p>随着行大小的逐步增大，<strong>Cache命中率会增加</strong></p>
<ul>
<li>空间局部性</li>
</ul>
</li>
<li><p>行大小较大后，继续增加行大小，<strong>Cache命中率会下降</strong></p>
<ul>
<li>频繁替换</li>
</ul>
</li>
</ul>
<p>行太小，行数太多<strong>反时间局部性</strong></p>
<p>行太大，行数太少<strong>反空间局部性</strong></p>
<h3 id="Cache数目"><a href="#Cache数目" class="headerlink" title="Cache数目"></a>Cache数目</h3><p><strong>一级</strong></p>
<ul>
<li><p>将Cache与处理器置于同一芯片</p>
</li>
<li><p>减少处理器在外部总线上的活动，从而减少了执行时间</p>
</li>
</ul>
<p><strong>多级</strong></p>
<ul>
<li><p>当$L_1$未命中时，减少处理器对总线上DRAM或ROM的访问</p>
</li>
<li><p>使用单独的数据路径，代替系统总线在$L_2$缓存和处理器之间传输数据，部分处理器将$L_2$ Cache结合到处理器芯片上</p>
</li>
</ul>
<p><strong>统一</strong></p>
<ul>
<li><p>更高的命中率，在获取指令和数据的负载之间自动进行平衡</p>
</li>
<li><p>只需设计和实现一个Cache</p>
</li>
</ul>
<p><strong>分立</strong></p>
<ul>
<li>消除Cache在指令的取值/译码单元和执行单元之间的竞争，在任何基于指令的流水线的设计中都是重要的</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/11/21/%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%A0%E6%9B%BE%E6%98%AF%E5%B0%91%E5%B9%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/21/%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%A0%E6%9B%BE%E6%98%AF%E5%B0%91%E5%B9%B4/" class="post-title-link" itemprop="url">你曾是少年</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-11-21 16:33:54 / 修改时间：16:35:07" itemprop="dateCreated datePublished" datetime="2023-11-21T16:33:54+08:00">2023-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%89%80%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">所念</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>2023.11.19晚，比赛还未结束，也许是暂时还没结束，但是我已经绝望地合上电脑，走出待了四个小时的教室</p>
<blockquote>
<p>我的手臂伤势恢复一直不错，我可以继续比赛，不过休息不是件坏事，我会考虑我的下一步选择<br>——the shy赛后采访</p>
</blockquote>
<p>其实走出来的那个时候，外面的冷风倒是没那么的刺，依稀记得，那个时候我脑海里的是：</p>
<blockquote>
<p>明凯你不要退役啊<br>——女粉丝</p>
</blockquote>
<p>小时候不懂得这一切背后的意义，只是单纯觉得：“有必要吗？不就是一场比赛而已。”</p>
<blockquote>
<p>shy哥你不要退役啊<br>——我的内心</p>
</blockquote>
<p>现在我上大学了，似乎懂得了一点点这份英雄暮年的无奈，也许会有一些素不相识的小孩疑惑着：“有必要吗？不就是一场比赛而已。”</p>
<p><strong>年少时射出的一颗子弹，经过多年，正中眉心</strong></p>
<p>虽然很不想承认，但是这轮比赛完完全全地让宙斯登上了上路的王座，不再年轻的你看着意气风发的宙斯，会不会满眼都是18岁的自己</p>
<p>我想啊，初二那年如果我没有看你的比赛，这几天也不会有如此感触吧</p>
<p>从8强开始看的比赛，或许不能算什么真正的粉丝，毕竟自我小学开始玩LOL的时候，冠军总是被faker斩获，因此总是对所谓的比赛提不起多大兴趣，但是你真的让我对早已失去的LOL职业比赛重燃信心</p>
<p>同样的上单位，你让我明白了原来可以这么玩游戏，原来可以这么压制，原来可以$\cdots \:\cdots$</p>
<p>虽然上了高中后再也没有时间玩LOL了，但是在难得的两周一天的回家时间，在凌晨，我还是愿意打开你的直播间，看你rank，甚至是看你吃夜宵，我想那些日子我应该也挺开心吧</p>
<p>后来啊，你被人们说靠小虎抬进的世界赛，被人们说瑞士轮1：2闹麻了，被人们嘲笑上限冠军，被人们说打个欧美弱鸡闹麻了，被人们说抽签组闹麻了，被人们说打个BLG闹麻了，直到一步步走到首尔，走到最大的舞台$\cdots \:\cdots$</p>
<p>而我看到的是，早已下坡的你一次次挽狂澜于既倒，扶大厦于将倾，直到决赛之前，你的世界赛表现堪称完美，甚至是让人看到了IG.The Shy的身影，因此我更加相信，你在今年拥有一个美满的结局</p>
<blockquote>
<p>The Shy向上天祈祷，回应他的只有18年的自己<br>——虎扑评论</p>
</blockquote>
<p>这样的评论，几乎在决赛前的每一局都能出现，我也那么以为，登神的剧本描述的是你，我们万分期待着，四号种子掀翻T1的剧情再次上演</p>
<p>决赛时候我看BP过程的担心，还是应验了：</p>
<ul>
<li><p>三楼出剑魔的话宙斯会出永恩</p>
</li>
<li><p>塞拉斯不ban不能拿大树</p>
</li>
</ul>
<p>毋庸置疑faker的表现无可挑剔，也许他生来就是LOL这个故事的主角：主角在年少时拿下三连冠，后来沉寂许久，最后在自己第10年职业生涯拿下第四个冠军。一切看起来都那么完美，但是啊，<strong>我不是主角的粉丝</strong>，我好像永远被困在18年的仁川了，这次shy哥还是没能把我们带回家，也许再也没有机会了</p>
<p>晚上路过茶百道的时候，wjy问我：“你还想喝橙露啵啵吗？”我苦笑了一阵，一时也说不出话来。但其实啊，不管你拿不拿得到这个冠军，我都只是<strong>希望能看你多打几局比赛</strong>，这对我来说就是已经足够了</p>
<p>现在看来，我一个星期前梦中WBG 2 : 0 T1的梦境显得那么荒谬，但是无论无论怎么样，我全程看完今年世界赛的眼睛告诉我你发挥已经极致</p>
<blockquote>
<p>下山的路太吵了，我听不见<br>——网友</p>
</blockquote>
<p>故事的开始：</p>
<blockquote>
<p>基地来了个孩子，他的锐雯在天上飞</p>
</blockquote>
<p>故事的尾声：</p>
<blockquote>
<p>很可惜走到决赛却输了，更可惜的是我觉得我年纪大了，如果我再年轻一点是不是可以过更精彩的人生<br>——the shy赛后采访</p>
</blockquote>
<p>我想啊，如果身体还允许的话，能不能再让我看你一年，不奢求能走到多远了，只希望你开开心心地结束自己作为选手的生涯。你的少年时期，已经看过山上的风景，这段路，已经足够伟大</p>
<blockquote>
<p>许多年前，你有一双清澈的双眼<br>奔跑起来，就像一道春天的闪电<br>——焦迈奇《你曾是少年》</p>
</blockquote>
<p>我明白时光不能倒转，但是我还是很怀念我的初二，很怀念我初识你的时候，一切都能重新来过</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">花花花铃</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">152k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:36</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
