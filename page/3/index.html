<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favcion.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"misayaas.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="万头攒动，火树银花之处不必寻我">
<meta property="og:type" content="website">
<meta property="og:title" content="Misayaas">
<meta property="og:url" content="https://misayaas.github.io/page/3/index.html">
<meta property="og:site_name" content="Misayaas">
<meta property="og:description" content="万头攒动，火树银花之处不必寻我">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="花花花铃">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://misayaas.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Misayaas</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Misayaas</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/%20/%20fa%20fa-home" rel="section">首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="花花花铃"
      src="/images/avater.jpg">
  <p class="site-author-name" itemprop="name">花花花铃</p>
  <div class="site-description" itemprop="description">万头攒动，火树银花之处不必寻我</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://misayaas.github.io/2023/10/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avater.jpg">
      <meta itemprop="name" content="花花花铃">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Misayaas">
      <meta itemprop="description" content="万头攒动，火树银花之处不必寻我">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Misayaas">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">面向对象基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-25 11:57:03" itemprop="dateCreated datePublished" datetime="2023-10-25T11:57:03+08:00">2023-10-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-30 19:17:25" itemprop="dateModified" datetime="2023-10-30T19:17:25+08:00">2023-10-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>一个<code>class</code>可以包含多个<code>field</code>。但是，直接把<code>field</code>用<code>public</code>暴露给外部可能会<strong>破坏封装性</strong>。为了避免外部代码直接去访问<code>field</code>，我们可以用<code>private</code>修饰<code>field</code>，拒绝外部访问</p>
<ul>
<li>所以我们需要使用方法（<code>method</code>）来让外部代码可以<strong>间接修改</strong></li>
</ul>
<p>所以，一个类通过定义方法，就可以给外部代码暴露一些操作的<strong>接口</strong>，同时，内部自己保证逻辑一致性。</p>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 方法返回类型 方法名(方法参数列表) &#123;</span><br><span class="line">    若干方法语句;</span><br><span class="line">    <span class="keyword">return</span> 方法返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>private方法<br>定义<code>private</code>方法的理由是<strong>内部方法</strong>是可以调用<code>private</code>方法的</p>
</li>
<li><p>this变量<br>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向<strong>当前实例</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 前面的this不可少，少了就变成局部变量name了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><ul>
<li><strong>基本类型</strong>参数的传递，是调用方值的复制。双方各自的后续修改，互不影响</li>
<li><strong>引用类型</strong>参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>创建实例的时候，实际上是通过构造方法来<strong>初始化</strong>实例的。</p>
<ul>
<li>构造方法的名称就是类名</li>
<li>和普通方法相比，构造方法<strong>没有返回值</strong>（也没有<code>void</code>），调用构造方法，必须用<code>new</code>操作符。</li>
<li>任何<code>class</code><strong>都有</strong>构造方法</li>
<li>如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来</li>
</ul>
<p>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用<u>默认值</u>，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code></p>
<ul>
<li>也可以对字段直接进行初始化</li>
</ul>
<p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p>
<p> <strong>1.先初始化字段<br> 2.执行构造方法的代码进行初始化</strong></p>
<p>一个构造方法可以调用其他构造方法，这样做的目的是<strong>便于代码复用</strong>。调用其他构造方法的语法是<code>this(…)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unnamed&quot;</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法重载-Overload"><a href="#方法重载-Overload" class="headerlink" title="方法重载(Overload)"></a>方法重载(Overload)</h2><p>方法名相同，但各自的参数不同</p>
<p>方法重载的<strong>返回值类型</strong>通常都是相同的。</p>
<p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类自动获得了父类的所有字段，严禁定义与父类<strong>重名</strong>的字段！</p>
<p>任何类，除了<code>Object</code>，都会继承自某个类。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│  Object   │</span><br><span class="line">└───────────┘</span><br><span class="line">      ▲</span><br><span class="line">      │</span><br><span class="line">┌───────────┐</span><br><span class="line">│  Person   │</span><br><span class="line">└───────────┘</span><br><span class="line">      ▲</span><br><span class="line">      │</span><br><span class="line">┌───────────┐</span><br><span class="line">│  Student  │</span><br><span class="line">└───────────┘</span><br></pre></td></tr></table></figure></p>
<p>Java只允许一个class继承自一个类，因此，一个类<strong>有且仅有一个</strong>父类。只有<code>Object</code>特殊，它没有父类。</p>
<p>继承有个特点，就是子类<strong>无法访问</strong>父类的<code>private</code>字段或者<code>private</code>方法。</p>
<ul>
<li>为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问</li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">super</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p>
<p>在Java中，任何<code>class</code>的构造方法，<strong>第一行语句必须是调用父类的<u>构造方法</u></strong>。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code></p>
<ul>
<li><strong>这里的<code>super()</code>是无参数构造方法</strong></li>
<li>如果父类没有默认的构造方法，子类就必须<strong>显式调用<code>super()</code>并给出参数</strong>以便让编译器定位到父类的一个合适的构造方法</li>
</ul>
<p>子类<strong>不会继承</strong>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的</p>
<h3 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h3><p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Rect, Circle, Triangle &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。</li>
</ul>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>如果<code>Student</code>是从<code>Person</code>继承下来的，那，一个引用类型为<code>Person</code>的变量，<strong>能</strong>指向<code>Student</code>类型的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这种把一个子类类型安全地变为父类类型的赋值，被称为<strong>向上转型</strong>（upcasting）</li>
</ul>
<p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> p; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>如果把一个父类类型强制转型为子类类型，就是<strong>向下转型</strong>（downcasting）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1; <span class="comment">// ok，因为p1确实指向Student实例</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) p2; <span class="comment">// runtime error! ClassCastException!子类功能比父类多，多的功能无法凭空变出来。</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</li>
</ul>
<p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以<strong>先判断</strong>一个实例究竟是不是某种类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>具有has关系不应该使用继承，而是<strong>使用组合</strong>，即<code>Student</code>可以持有一个<code>Book</code>实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因此，继承是is关系，组合是has关系。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为<strong>重写</strong>（Override）</p>
<p><strong><u>Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</u></strong></p>
<p>==<u>Java的实例方法调用是基于运行时的<strong>实际类型</strong>的动态调用，而非变量的声明类型。</u>==</p>
<ul>
<li>多态是指，针对某个类型的方法调用，其真正执行的方法<strong>取决于运行时期实际类型的方法</strong></li>
<li>多态的特性就是，<strong>运行期</strong>才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。</li>
</ul>
<h3 id="重写Object方法"><a href="#重写Object方法" class="headerlink" title="重写Object方法"></a>重写Object方法</h3><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>
<ul>
<li><code>toString()</code>：把instance输出为<code>String</code>；</li>
<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>
<li><code>hashCode()</code>：计算一个instance的哈希值。<br>在有必要的情况下，我们可以重写这些方法</li>
</ul>
<h3 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h3><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code></p>
<ul>
<li>如果一个类不希望任何其他类继承自它，那么可以把这个<strong>类本身</strong>标记为<code>final</code></li>
</ul>
<p>可以在构造方法中初始化final字段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是<strong>让子类去重写它</strong>，那么，可以把父类的方法声明为抽象方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化</li>
<li>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它</li>
</ul>
<p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></p>
<p>抽象类可以<strong>强迫</strong>子类实现其定义的抽象方法，否则编译会报错</p>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不关心Person变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><br>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样不关心新的子类是如何实现run()方法的：</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">e.run();</span><br></pre></td></tr></table></figure><br>这种尽量引用高层类型，<strong>避免引用实际子类型</strong>的方式，称之为面向抽象编程</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li><p>上层代码只<strong>定义规范</strong>（例如：<code>abstract class Person</code>）；</p>
</li>
<li><p>不需要子类就可以实现业务逻辑（正常编译）；</p>
</li>
<li><p>具体的业务逻辑由不同的子类实现，<strong>调用者并不关心</strong>。</p>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如果一个抽象类没有字段，所有方法<strong>全部都是抽象方法</strong>，就可以把该抽象类改写为接口：<code>interface</code></p>
<p>在Java中，使用<code>interface</code>可以声明一个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所谓<code>interface</code>，就是比抽象类还要抽象的<strong>纯抽象</strong>接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符<strong>不需要写出来</strong>（写不写效果都一样）</p>
<p>一个类可以实现<strong>多个</strong><code>interface</code>（区别于继承）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意区分术语：</p>
<ul>
<li>Java的接口特指<code>interface</code>的定义，表示<strong>一个接口类型和一组方法签名</strong></li>
<li>编程接口<strong>泛指接口规范</strong>，如方法签名，数据格式，网络协议等。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承</td>
<td>只能extends一个class</td>
<td>可以implements多个interface</td>
</tr>
<tr>
<td>字段</td>
<td>可以定义实例字段</td>
<td>不能定义实例字段</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以定义抽象方法</td>
<td>可以定义抽象方法</td>
</tr>
<tr>
<td>非抽象方法</td>
<td>可以定义非抽象方法</td>
<td>可以定义default方法</td>
</tr>
</tbody>
</table>
</div>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个<code>interface</code>可以继承自另一个<code>interface</code><br><code>interface</code>继承自<code>interface</code>要使用<code>extends</code>，它相当于<strong>扩展</strong>了接口的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>一般来说，<strong>公共逻辑</strong>适合放在<code>abstract class</code>中，<strong>具体逻辑</strong>放到各个子类，而接口层次代表<strong>抽象程度</strong></p>
<p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为<strong>接口比抽象类更抽象</strong></p>
<h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现类可以不必覆写<code>default</code>方法。<br><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改<strong>全部子类</strong>。</p>
<ul>
<li>当类实现接口时，类要实现接口中<strong>所有方法</strong></li>
</ul>
<p>如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法<strong>无法访问</strong>字段，而抽象类的普通方法可以访问实例字段。</p>
<h2 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h2><h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p>实例字段在每个实例中都有自己的一个<strong>独立“空间”</strong><br>静态字段只有一个<strong>共享“空间”</strong>，所有实例都会共享该字段。</p>
<p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：<strong>所有</strong>实例的静态字段都被修改了，原因是<u><strong>静态字段并不属于实例</strong></u></p>
<ul>
<li>实例可以访问静态字段，但它们指向的都是一个<strong>共享</strong>的静态字段</li>
<li>在java程序中，实例对象并<strong>没有静态字段</strong><ul>
<li>实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象</li>
<li>推荐用<strong>类名</strong>来访问静态字段</li>
<li>可以把静态字段理解为描述<code>class</code><strong>本身</strong>的字段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.number = 99;</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>调用静态方法则不需要实例变量，通过<strong>类名</strong>就可以调用</p>
<p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它<strong>只能访问静态字段</strong></p>
<ul>
<li>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告</li>
</ul>
<p>静态方法经常用于<strong>工具类</strong>。例如：</p>
<ul>
<li><p>Arrays.sort()</p>
</li>
<li><p>Math.random()</p>
</li>
</ul>
<p>静态方法也经常用于<strong>辅助方法</strong></p>
<ul>
<li>注意到Java程序的入口<code>main()</code>也是静态方法。</li>
</ul>
<h3 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h3><p><code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型</p>
<ul>
<li>实际上，因为<code>interface</code>的字段<strong>只能</strong>是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>Java定义了一种名字空间，称之为<strong>包</strong>：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，<u><strong>真正的完整类名是<code>包名.类名</code></strong></u></p>
<ul>
<li>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</li>
<li>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</li>
<li>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</li>
<li>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</li>
</ul>
<p>在Java虚拟机执行的时候，<u><strong>JVM只看完整类名</strong></u>，因此，只要包名不同，类就不同</p>
<ul>
<li><u><strong>包可以是多层结构</strong></u>，用<code>.</code>隔开。例如：<code>java.util</code></li>
</ul>
<p>要特别注意：<u><strong>包没有父子关系</strong></u>。java.util和java.util.zip是不同的包，==两者没有任何继承关系==</p>
<p>没有定义包名的<code>class</code>，它使用的是<strong>默认包</strong>，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<ul>
<li>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包</li>
</ul>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>位于同一个包的类，可以访问<strong>包作用域</strong>的字段和方法</p>
<ul>
<li><strong>不用</strong><code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域</li>
</ul>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法</p>
<ol>
<li><del>直接写出完整类名</del><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名(<strong>最常用</strong>)<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的<u><strong>所有</strong><code>class</code></u>都导入进来（==但不包括子包的<code>class</code>==）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包</li>
</ul>
<p>3.<del><code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法</del><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于调用System.out.println(…)</span></span><br><span class="line">        out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java编译器最终编译出的<code>.class</code>文件只使用<strong>完整类名</strong></p>
<p>在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li><p>如果是完整类名，就直接根据<strong>完整类名</strong>查找这个<code>class</code>；</p>
</li>
<li><p>如果是简单类名，按下面的顺序依次查找：</p>
<ul>
<li><p>查找当前<code>package</code>是否存在这个<code>class</code>；</p>
</li>
<li><p>查找<code>import</code>的包是否包含这个<code>class</code>；</p>
</li>
<li><p>查找<code>java.lang</code>包是否包含这个<code>class</code>。</p>
</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则<strong>编译报错</strong></p>
<p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p>
<ul>
<li><p>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</p>
</li>
<li><p>默认自动<code>import java.lang.*</code>。</p>
</li>
</ul>
<p>注意：<u><strong>自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入</strong></u></p>
<p>如果有两个<code>class</code>名称相同,只能<code>import</code>其中一个，另一个必须写完整类名</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免名字冲突，我们需要确定<strong>唯一</strong>的包名</p>
<ul>
<li>推荐的做法是<u><strong>使用倒置的域名来确保唯一性</strong></u></li>
<li>子包就可以根据功能自行命名</li>
</ul>
<p>要注意不要和<code>java.lang</code>包的类重名<br>要注意也不要和<strong>JDK常用类</strong>重名</p>
<h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><p>假设我们创建了如下的目录结构：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">work</span><br><span class="line">├── bin</span><br><span class="line">└── src</span><br><span class="line">    └── com</span><br><span class="line">        └── itranswarp</span><br><span class="line">            ├── sample</span><br><span class="line">            │   └── Main.java</span><br><span class="line">            └── world</span><br><span class="line">                └── Person.java</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>bin</code>目录用于存放编译后的<code>class</code>文件，<code>src</code>目录按<strong>包结构</strong>存放Java源码</p>
<p>首先，<strong>确保</strong>当前目录是<code>work</code>目录，即存放<code>src</code>和<code>bin</code>的父目录：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">bin src</span><br></pre></td></tr></table></figure><br>然后，<strong>编译</strong><code>src</code>目录下的所有Java文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac -d ./bin src/**/*.java</span><br></pre></td></tr></table></figure></p>
<ul>
<li>命令行<code>-d</code><strong>指定</strong>输出的<code>class</code>文件存放<code>bin</code>目录，后面的参数<code>src/**/*.java</code>表示<code>src</code>目录下的所有<code>.java</code>文件，包括<strong>任意深度</strong>的子目录。</li>
<li>注意：Windows不支持<code>**</code>这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有<code>.java</code>文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\work&gt; javac -d bin src\com\itranswarp\sample\Main.java src\com\itranswarp\world\Persion.java</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果编译无误，则<code>javac</code>命令<strong>没有任何输出</strong>。可以在<code>bin</code>目录下看到如下<code>class</code>文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bin</span><br><span class="line">└── com</span><br><span class="line">    └── itranswarp</span><br><span class="line">        ├── sample</span><br><span class="line">        │   └── Main.class</span><br><span class="line">        └── world</span><br><span class="line">            └── Person.class</span><br></pre></td></tr></table></figure><br>现在，我们就可以直接运行<code>class</code>文件了。根据当前目录的位置<strong>确定classpath</strong>，例如，当前目录仍为<code>work</code>，则classpath为<code>bin</code>或者<code>./bin</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -cp bin com.itranswarp.sample.Main </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他<strong>任何类</strong>访问</p>
<p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的<strong>权限</strong></p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>定义为<code>private</code>的<code>field</code>、<code>method</code><strong>无法</strong>被其他类访问、</p>
<ul>
<li><code>private</code>访问权限被限定在<code>class</code>的<strong>内部</strong>，而且<u><strong>与方法声明顺序无关</strong></u></li>
<li>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，<strong>嵌套类</strong>拥有访问<code>private</code>的权限<ul>
<li>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类</li>
</ul>
</li>
</ul>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p><code>protected</code>作用于<strong>继承关系</strong>。</p>
<p>定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</p>
<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法</p>
<ul>
<li>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code></li>
<li>注意，包名必须<strong>完全一致</strong>，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="Inner-class"><a href="#Inner-class" class="headerlink" title="Inner class"></a>Inner class</h3><p>有一种类，它被定义在另一个类的内部，所以称为内部类（Nested Class）。</p>
<ul>
<li>Inner Class的实例<strong>不能单独存在</strong>，必须依附于一个Outer Class的实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h3>还有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在<strong>方法内部</strong>，通过匿名类（Anonymous Class）来定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">asyncHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的<strong>匿名类</strong>，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法</li>
<li>如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code></li>
</ul>
<p>除了接口外，匿名类也完全可以继承自普通类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#125;; <span class="comment">// 匿名类!</span></span><br><span class="line">        HashMap&lt;String, String&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(map3.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h3><p>一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">StaticNested</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNested</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个<strong>完全独立</strong>的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。</p>
<h2 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h2><h3 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h3><p><code>classpath</code>是JVM用到的一个<strong>环境变量</strong>，它用来<u><strong>指示JVM如何搜索<code>class</code></strong></u></p>
<ul>
<li><strong>编译后</strong>的<code>.class</code>文件才是真正可以被JVM执行的字节码</li>
</ul>
<p><code>classpath</code>就是<strong>一组目录的集合</strong>，它设置的搜索路径与操作系统相关</p>
<ul>
<li>在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\work\project1\bin;C:\shared;&quot;D:\My 	Documents\project1\bin&quot;</span><br></pre></td></tr></table></figure></li>
<li>在Linux系统上，用<code>:</code>分隔  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会<strong>依次查找</strong>：</p>
<ul>
<li><p>&lt;当前目录&gt;\abc\xyz\Hello.class</p>
</li>
<li><p>C:\work\project1\bin\abc\xyz\Hello.class</p>
</li>
<li><p>C:\shared\abc\xyz\Hello.class<br>注意到<code>.</code>代表<strong>当前目录</strong></p>
</li>
</ul>
<p>如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>
<p><code>classpath</code>的设定方法有两种：</p>
<ul>
<li><p><del>在系统环境变量中设置<code>classpath</code>环境变量</del></p>
<ul>
<li><u><strong>污染整个系统环境</strong></u></li>
</ul>
</li>
<li><p>在<strong>启动JVM时</strong>设置<code>classpath</code>变量</p>
<ul>
<li>给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure></li>
<li>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即<strong>当前目录</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java abc.xyz.Hello</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是<u><strong>当前工程的<code>bin</code>目录和引入的jar包</strong></u></p>
<ul>
<li>==不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！==</li>
</ul>
<p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p>
<p>如果指定的<code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错</p>
<h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>jar包可以把<code>package</code>组织的目录层级，以及各个目录下的<strong>所有文件</strong>（包括<code>.class</code>文件和其他文件）都打成一个jar文件</p>
<p>jar包里的第一层目录，不能是<code>bin</code></p>
<ul>
<li>Windows中应该是这样<br><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/files/attachments/1261393208671488/l">https://www.liaoxuefeng.com/files/attachments/1261393208671488/l</a></li>
<li>有问题的长这样<br><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/files/attachments/1261391527906784/l">https://www.liaoxuefeng.com/files/attachments/1261391527906784/l</a></li>
</ul>
<p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息</p>
<p>JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure></p>
<h2 id="class版本"><a href="#class版本" class="headerlink" title="class版本"></a>class版本</h2><p>我们通常说的Java 8，Java 11，Java 17，是指<strong>JDK</strong>的版本，也就是<strong>JVM</strong>的版本，更确切地说，就是<code>java.exe</code>这个程序的版本</p>
<ul>
<li>而每个版本的JVM，它能执行的<strong>class文件版本</strong>也不同</li>
<li>只要看到<code>UnsupportedClassVersionError</code>就表示当前要加载的class文件版本超过了JVM的能力，必须使用<strong>更高版本</strong>的JVM才能运行</li>
</ul>
<p>指定编译输出有两种方式，一种是在<code>javac</code>命令行中用参数<code>--release</code>设置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ javac --release 11 Main.java</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>参数<code>--release 11</code>表示源码兼容Java 11，编译的class输出版本为<strong>Java 11兼容</strong>，即class版本55。</li>
</ul>
<p>第二种方式是用参数<code>--source</code>指定<strong>源码版本</strong>，用参数<code>--target</code>指定<strong>输出class版本</strong>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac --source 9 --target 11 Main.java</span><br></pre></td></tr></table></figure></p>
<ul>
<li>上述命令如果使用Java 17的JDK编译，它会把源码视为<strong>Java 9兼容版本</strong>，并输出class为Java 11兼容版本</li>
</ul>
<p>注意<code>--release</code>参数和<code>--source --target</code>参数只能<strong>二选一</strong>，不能同时设置<br>指定版本如果<strong>低于</strong>当前的JDK版本，会有一些潜在的问题</p>
<p>==如果使用—release 11则会在编译时检查该方法是否在Java 11中存在==</p>
<p>如果运行时的JVM版本是Java 11，则编译时也最好使用Java 11，而不是用高版本的JDK编译输出低版本的class</p>
<p>如果使用<code>javac</code>编译时不指定任何版本参数，那么相当于使用<code>--release 当前版本</code>编译，即源码版本和输出版本均为<strong>当前版本</strong></p>
<p>在开发阶段，多个版本的JDK可以同时安装，当前使用的JDK版本可由<code>JAVA_HOME</code>环境变量切换</p>
<p>在编译的时候，如果用<code>--source</code>或<code>--release</code>指定源码版本，则使用指定的源码版本检查语法</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的<strong>Java标准库</strong>，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M</p>
<p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</span><br></pre></td></tr></table></figure><br>==注意：JVM自带的标准库<u><strong>rt.jar</strong></u>不要写到classpath中，写了反而会干扰JVM的正常运行==</p>
<ul>
<li>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code>ClassNotFoundException</code></li>
<li>jar只是用于存放class的容器，它并<strong>不关心</strong>class之间的依赖</li>
</ul>
<p>如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种<strong>自带依赖关系</strong>的<u>class容器</u>就是模块</p>
<p>从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>
<ul>
<li>java.base.jmod</li>
<li>java.compiler.jmod</li>
<li>java.datatransfer.jmod</li>
<li>java.desktop.jmod</li>
<li>…</li>
</ul>
<p>这些<code>.jmod</code>文件每一个都是一个模块，<u><strong>模块名就是文件名</strong></u></p>
<ul>
<li>模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code></li>
<li>模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了</li>
</ul>
<p>所有的模块<strong>都</strong>直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“<strong>根模块</strong>”，好比所有的类都是从<code>Object</code>直接或间接继承而来</p>
<p><strong>模块支持多版本</strong>，即在同一个模块中可以为不同的JVM提供不同的版本</p>
<h3 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h3><p>以<code>oop-module</code>工程为例，它的目录结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">├── build.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure><br>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是<strong>模块的描述文件</strong></p>
<ul>
<li><p>在这个模块中，它长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">	<span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。<u><strong>花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名</strong></u>。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块</p>
</li>
<li><p>当我们使用模块声明了依赖关系后，才能使用引入的模块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.XMLConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Greeting</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line">		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是<strong>声明依赖关系</strong> </p>
</li>
</ul>
<h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><p>1.我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure><br>如果编译成功，现在项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">│   ├── com</span><br><span class="line">│   │   └── itranswarp</span><br><span class="line">│   │       └── sample</span><br><span class="line">│   │           ├── Greeting.class</span><br><span class="line">│   │           └── Main.class</span><br><span class="line">│   └── module-info.class</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure>
<p>2.我们需要把bin目录下的<strong>所有class文件先打包成jar</strong>，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure>
<p>3.继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure><br>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块</p>
<h3 id="运行模块"><a href="#运行模块" class="headerlink" title="运行模块"></a>运行模块</h3><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要<strong>指定模块名</strong>。试试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java --module-path hello.jmod --module hello.world</span><br></pre></td></tr></table></figure><br>结果是一个错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error occurred during initialization of boot layer</span><br><span class="line">java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</span><br></pre></td></tr></table></figure><br>原因是<u><strong><code>.jmod</code>不能被放入<code>--module-path</code>中</strong></u>。换成<code>.jar</code>就没问题了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java --module-path hello.jar --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure><br>那我们辛辛苦苦创建的<code>hello.jmod</code>有什么用？答案是我们可以用它来<strong>打包JRE</strong></p>
<h3 id="打包JRE"><a href="#打包JRE" class="headerlink" title="打包JRE"></a>打包JRE</h3><p>JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉</p>
<ul>
<li>并不是说把系统安装的JRE给删掉部分模块，而是<strong>复制</strong>一份JRE，但<u><strong>只带上用到的模块</strong></u><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure></li>
<li>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录</li>
</ul>
<p>在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE</p>
<p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是<u><strong>b模块明确地导出了可以访问的包</strong></u></p>
<p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml &#123;</span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>只有它声明的导出的包，外部代码才被允许访问</strong>。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> java.base;</span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因此，<strong>模块进一步隔离了代码的访问权限</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">花花花铃</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">134k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:03</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
