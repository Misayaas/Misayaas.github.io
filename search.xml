<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA核心类</title>
    <url>/2023/10/25/JAVA%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>字符串和编码</li>
<li>StringBuilder</li>
<li>StringJoiner</li>
<li>包装类型</li>
<li>JavaBean</li>
<li>枚举类</li>
<li>记录类</li>
<li>BigInteger</li>
<li>BigDecimal<br> 10.常用工具类</li>
</ol>
<h2 id="1-字符串和编码"><a href="#1-字符串和编码" class="headerlink" title="1.字符串和编码"></a>1.字符串和编码</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>Java提供了<code>&quot;...&quot;</code>这种<strong>字符串字面量</strong>表示方法</p>
<p>Java字符串的一个重要特点就是<strong>字符串不可变</strong>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的</p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想<u><strong>比较字符串的内容是否相同</strong></u>。必须使用<code>equals()</code>方法而不能用<code>==</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的</p>
<ul>
<li>所以，这种<code>==</code>比较返回<code>true</code>纯属巧合</li>
</ul>
<p>换一种写法，<code>==</code>比较就会失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法</strong></u></p>
<p><code>String</code>类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否包含子串:</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意到<code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>实现的一个接口</li>
</ul>
<p><strong>搜索</strong>子串的更多的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>提取</strong>子串的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="去除首尾空白字符"><a href="#去除首尾空白字符" class="headerlink" title="去除首尾空白字符"></a>去除首尾空白字符</h3><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>&#x3D;&#x3D;注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串&#x3D;&#x3D;</li>
</ul>
<p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure>

<h3 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h3><p>1.根据字符或字符串替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure>
<p>2.通过正则表达式替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>上面的代码通过正则表达式，把匹配的子串统一替换为<code>&quot;,&quot;</code></li>
</ul>
<h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不确定用啥占位符，那就始终用<code>%s</code>，因为<u><strong><code>%s</code>可以显示任何数据类型</strong></u></p>
<p>要查看完整的格式化语法，请参考<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Formatter.html#syntax">JDK文档</a></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>要把任意基本类型或引用类型转换为字符串，可以使用<strong>静态方法</strong><code>valueOf()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>
<p>把字符串转换为<code>int</code>类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure>
<p>把字符串转换为<code>boolean</code>类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的<strong>系统变量</strong>转换为<code>Integer</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br></pre></td></tr></table></figure>

<h3 id="转换为char"><a href="#转换为char" class="headerlink" title="转换为char[]"></a>转换为char[]</h3><p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>

<p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会<strong>复制</strong>一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为<u><strong>这是两个不同的数组</strong></u></li>
<li>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用</li>
</ul>
<p>例如，下面的代码设计了一个<code>Score</code>类保存一组学生的成绩</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">88</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">66</span> &#125;;</span><br><span class="line">        <span class="type">Score</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(scores);</span><br><span class="line">        s.printScores();</span><br><span class="line">        scores[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        s.printScores();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] scores;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(<span class="type">int</span>[] scores)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scores = scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScores</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Arrays.toString(scores));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Score</code>内部直接引用了外部传入的<code>int[]</code>数组，这会造成外部代码对<code>int[]</code>数组的修改，影响到<code>Score</code>类的字段</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用<strong>一个字节</strong>，编码范围从<code>0</code>到<code>127</code>，最高位始终为<code>0</code>，称为<code>ASCII</code>编码。例如，字符<code>&#39;A&#39;</code>的编码是<code>0x41</code>，字符<code>&#39;1&#39;</code>的编码是<code>0x31</code></p>
<p><code>GB2312</code>标准使用<strong>两个字节</strong>表示一个汉字，其中第一个字节的最高位始终为<code>1</code>，以便和<code>ASCII</code>编码区分开。例如，汉字<code>&#39;中&#39;</code>的<code>GB2312</code>编码是<code>0xd6d0</code>。</p>
<p>为了<strong>统一全球所有语言的编码</strong>，全球统一码联盟发布了<code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p>
<p><code>Unicode</code>编码需要<strong>两个或者更多字节</strong>表示</p>
<p>英文字符<code>&#39;A&#39;</code>的<code>ASCII</code>编码和<code>Unicode</code>编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         ┌────┐</span><br><span class="line">ASCII:   │ 41 │</span><br><span class="line">         └────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 00 │ 41 │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>英文字符的<code>Unicode</code>编码就是简单地在前面添加一个<code>00</code>字节</strong></li>
</ul>
<p>中文字符<code>&#39;中&#39;</code>的<code>GB2312</code>编码和<code>Unicode</code>编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         ┌────┬────┐</span><br><span class="line">GB2312:  │ d6 │ d0 │</span><br><span class="line">         └────┴────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 4e │ 2d │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure>

<p>因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，<u>包含大量英文的文本会浪费空间</u>，所以，出现了<code>UTF-8</code>编码，它是一种<strong>变长编码</strong>，用来把固定长度的<code>Unicode</code>编码变成<strong>1～4字节</strong>的变长编码。通过<code>UTF-8</code>编码，英文字符<code>&#39;A&#39;</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>&#39;中&#39;</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code></p>
<p><code>UTF-8</code>编码的另一个好处是<strong>容错能力强</strong>。如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码</p>
<p><code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组&#x3D;&#x3D;</p>
<p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] b = ...</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure>

<p><strong>Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示</strong></p>
<h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>早期JDK版本的<code>String</code>总是以<code>char[]</code>存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>较新的JDK版本的<code>String</code>则以<code>byte[]</code>存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则，每两个<code>byte</code>存储一个字符，这样做的目的是为了<strong>节省内存</strong>，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符</li>
</ul>
<h2 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2.StringBuilder"></a>2.StringBuilder</h2><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个<strong>可变对象</strong>，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，<strong>不会创建新的临时对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p><code>StringBuilder</code>还可以进行链式操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>进行链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法</li>
</ul>
<p>&#x3D;&#x3D;注意：对于普通的字符串<code>+</code>操作，并<strong>不需要</strong>我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作&#x3D;&#x3D;</p>
<h2 id="3-StringJoiner"><a href="#3-StringJoiner" class="headerlink" title="3.StringJoiner"></a>3.StringJoiner</h2><p>很多时候，我们拼接的字符串像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sb.append(name).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意去掉最后的&quot;, &quot;:</span></span><br><span class="line">        sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">        sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<strong>分隔符</strong>拼接数组的需求很常见，所以Java标准库还提供了一个<code>StringJoiner</code>来干这个事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>StringJoiner</code>的结果少了前面的<code>&quot;Hello &quot;</code>和结尾的<code>&quot;!&quot;</code>！遇到这种情况，需要给<code>StringJoiner</code>指定“开头”和“结尾”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="String-join"><a href="#String-join" class="headerlink" title="String,join()"></a>String,join()</h3><p><code>String</code>还提供了一个<strong>静态方法</strong><code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure>

<h2 id="4-包装类型"><a href="#4-包装类型" class="headerlink" title="4.包装类型"></a>4.包装类型</h2><p>想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的<strong>包装类</strong>（Wrapper Class）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好了<code>Integer</code>类，我们就可以把<code>int</code>和<code>Integer</code>互相转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> n2.intValue();</span><br></pre></td></tr></table></figure>

<p>因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的引用类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>java.lang.Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>java.lang.Byte</td>
</tr>
<tr>
<td>short</td>
<td>java.lang.Short</td>
</tr>
<tr>
<td>int</td>
<td>java.lang.Integer</td>
</tr>
<tr>
<td>long</td>
<td>java.lang.Long</td>
</tr>
<tr>
<td>float</td>
<td>java.lang.Float</td>
</tr>
<tr>
<td>double</td>
<td>java.lang.Double</td>
</tr>
<tr>
<td>char</td>
<td>java.lang.Character</td>
</tr>
</tbody></table>
<p>我们可以直接使用，不需要自己定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n3</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h3><p>Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure>
<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为<strong>自动装箱</strong>（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为<strong>自动拆箱</strong>（Auto Unboxing）</p>
<ul>
<li>&#x3D;&#x3D;注意：自动装箱和自动拆箱只发生在<strong>编译阶段</strong>，目的是为了少写代码&#x3D;&#x3D;</li>
<li><strong>自动拆箱</strong>执行时可能会报<code>NullPointerException</code></li>
<li>装箱和拆箱会影响<strong>代码的执行效率</strong>，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的</li>
</ul>
<h3 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h3><p>所有的包装类型都是不变类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，一旦创建了<code>Integer</code>对象，该对象就是<strong>不变</strong>的</p>
<p>对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是<strong>引用类型</strong>，必须使用<code>equals()</code>比较</p>
<p>我们自己创建<code>Integer</code>的时候，以下两种方法：</p>
<ul>
<li><del>方法1：<code>Integer n = new Integer(100);</code></del></li>
<li>方法2：<code>Integer n = Integer.valueOf(100);</code></li>
</ul>
<p>我们把能创建“新”对象的静态方法称为<strong>静态工厂方法</strong></p>
<ul>
<li><code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存</li>
</ul>
<p>&#x3D;&#x3D;创建新对象时，优先选用静态工厂方法而不是new操作符&#x3D;&#x3D;</p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的<strong>静态方法</strong><code>parseInt()</code>可以把字符串解析成一个整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure>
<p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// &quot;100&quot;,表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// &quot;2s&quot;,表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// &quot;1100100&quot;,表示为2进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们经常使用的<code>System.out.println(n);</code>是依靠核心库自动把整数格式化为<strong>10进制</strong>输出并显示在屏幕上，使用<code>Integer.toHexString(n)</code>则通过核心库自动把整数格式化为<strong>16进制</strong></p>
<p>这里我们注意到程序设计的一个重要原则：<strong>数据的存储和显示要分离</strong></p>
<p>ava的包装类型还定义了一些有用的<strong>静态变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span><br><span class="line">```java</span><br><span class="line">Boolean t = Boolean.TRUE;</span><br><span class="line">Boolean f = Boolean.FALSE;</span><br><span class="line">// int可表示的最大/最小值:</span><br><span class="line">int max = Integer.MAX_VALUE; // 2147483647</span><br><span class="line">int min = Integer.MIN_VALUE; // -2147483648</span><br><span class="line">// long类型占用的bit和byte数量:</span><br><span class="line">int sizeOfLong = Long.SIZE; // 64 (bits)</span><br><span class="line">int bytesOfLong = Long.BYTES; // 8 (bytes)</span><br></pre></td></tr></table></figure>
<p>最后，所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上转型为Number:</span></span><br><span class="line"><span class="type">Number</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">999</span>);</span><br><span class="line"><span class="comment">// 获取byte, int, long, float, double:</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> num.byteValue();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.intValue();</span><br><span class="line"><span class="type">long</span> <span class="variable">ln</span> <span class="operator">=</span> num.longValue();</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> num.floatValue();</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> num.doubleValue();</span><br></pre></td></tr></table></figure>

<h3 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h3><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型</p>
<ul>
<li>无符号整型和有符号整型的转换在Java中就需要借助<strong>包装类型的静态方法</strong>完成<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
类似的，可以把一个<code>short</code>按unsigned转换为<code>int</code>，把一个<code>int</code>按unsigned转换为<code>long</code></li>
</ul>
<h2 id="5-JavaBean"><a href="#5-JavaBean" class="headerlink" title="5.JavaBean"></a>5.JavaBean</h2><p>如果读写方法符合以下这种命名规范：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> Type <span class="title function_">getXyz</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXyz</span><span class="params">(Type value)</span></span><br></pre></td></tr></table></figure>
<p>那么这种<code>class</code>被称为<code>JavaBean</code></p>
<p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChild</span><span class="params">(<span class="type">boolean</span> value)</span></span><br></pre></td></tr></table></figure>

<p>我们通常把一组对应的<u><strong>读方法（<code>getter</code>）和写方法（<code>setter</code>）</strong></u>称为<strong>属性</strong>（<code>property</code>）。例如，<code>name</code>属性：</p>
<ul>
<li>对应的读方法是<code>String getName()</code></li>
<li>对应的写方法是<code>setName(String)</code></li>
</ul>
<p>只有<code>getter</code>的属性称为<strong>只读属性</strong>（read-only）<br>只有<code>setter</code>的属性称为<strong>只写属性</strong>（write-only）</p>
<ul>
<li><u>只读属性很常见，只写属性不常见</li>
<li>属性只需要定义<code>getter</code>和<code>setter</code>方法，<strong>不一定需要对应的字段</strong></li>
</ul>
<p>例如，<code>child</code>只读属性定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt;= <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>getter</code>和<code>setter</code>也是一种<strong>数据封装</strong>的方法</p>
<h3 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h3><p>JavaBean主要用来<strong>传递数据</strong>，即把一组数据组合成一个JavaBean便于传输<br>JavaBean可以方便地被<strong>IDE工具</strong>分析，生成读写属性的代码，主要用在图形界面的可视化设计中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击右键，在弹出的菜单中选择<u><strong>“Source”，“Generate Getters and Setters”</strong></u>，在弹出的对话框中选中需要生成<code>getter</code>和<code>setter</code>方法的字段，点击确定即可由IDE自动完成所有方法代码</p>
<h3 id="枚举JavaBean属性"><a href="#枚举JavaBean属性" class="headerlink" title="枚举JavaBean属性"></a>枚举JavaBean属性</h3><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BeanInfo</span> <span class="variable">info</span> <span class="operator">=</span> Introspector.getBeanInfo(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以列出所有的属性，以及对应的读写方法</p>
<ul>
<li>&#x3D;&#x3D;注意<code>class</code>属性是从<code>Object</code>继承的<code>getClass()</code>方法带来的&#x3D;&#x3D;</li>
</ul>
<h2 id="6-枚举类"><a href="#6-枚举类" class="headerlink" title="6.枚举类"></a>6.枚举类</h2><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>为了让编译器能<strong>自动检查</strong>某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>enum</code>常量本身带有<strong>类型信息</strong>，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (day == Weekday.SUN) &#123; <span class="comment">// Compile error: bad operand types for binary operator &#x27;==&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不可能引用到非枚举的值，因为无法通过编译</li>
<li><strong>不同类型</strong>的枚举不能互相比较或者赋值，因为类型不符<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Weekday</span> <span class="variable">x</span> <span class="operator">=</span> Weekday.SUN; <span class="comment">// ok!</span></span><br><span class="line"><span class="type">Weekday</span> <span class="variable">y</span> <span class="operator">=</span> Color.RED; <span class="comment">// Compile error: incompatible types</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="enum的比较"><a href="#enum的比较" class="headerlink" title="enum的比较"></a>enum的比较</h3><p>使用<code>enum</code>定义的枚举类是一种引用类型<br>引用类型比较，要始终使用<code>equals()</code>方法，<u><strong>但<code>enum</code>类型可以例外</strong></u></p>
<ul>
<li>这是因为<code>enum</code>类型的每个常量在JVM中只有一个<strong>唯一实例</strong>，所以可以直接用<code>==</code>比较<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.FRI) &#123; <span class="comment">// ok!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (day.equals(Weekday.SUN)) &#123; <span class="comment">// ok, but more code!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h3><p><code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且<strong>无法被继承</strong></li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例</li>
<li>定义的每个实例都是引用类型的<strong>唯一实例</strong></li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句</li>
</ul>
<p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例，因此，这些实例有一些方法：</p>
<ul>
<li><h3 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h3>  返回常量名，例如：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = Weekday.SUN.name(); // &quot;SUN&quot;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="ordinal"><a href="#ordinal" class="headerlink" title="ordinal()"></a>ordinal()</h3>  返回定义的常量的顺序，从0开始计数，例如：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n = Weekday.MON.ordinal(); // 1</span><br></pre></td></tr></table></figure>
  改变枚举常量<strong>定义的顺序</strong>就会导致<code>ordinal()</code>返回值发生变化</li>
</ul>
<p>如果在代码中编写了类似<code>if(x.ordinal()==1)</code>这样的语句，就要保证<code>enum</code>的枚举顺序不能变。<strong>新增的常量必须放在最后</strong>。</p>
<p>实现enum和int之间的转化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<code>int</code>值</li>
</ul>
<p>&#x3D;&#x3D;注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！&#x3D;&#x3D;</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-纪录类"><a href="#7-纪录类" class="headerlink" title="7.纪录类"></a>7.纪录类</h2><p>假设我们希望定义一个<code>Point</code>类，有<code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保证不变类的比较，还需要正确覆写<code>equals()</code>和<code>hashCode()</code>方法，这样才能在集合类中正常使用。</p>
<h3 id="record"><a href="#record" class="headerlink" title="record"></a>record</h3><p>把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>把上述定义改写为class，相当于以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换句话说，使用<code>record</code>关键字，可以<strong>一行写出一个不变类</strong></p>
<ul>
<li>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到方法<code>public Point &#123;...&#125;</code>被称为<strong>Compact Constructor</strong>，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为<code>record</code>的<code>Point</code>仍然可以添加<strong>静态方法</strong>。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-BigInteger"><a href="#8-BigInteger" class="headerlink" title="8.BigInteger"></a>8.BigInteger</h2><p>如果我们使用的整数范围<strong>超过了<code>long</code>型</strong>怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示<strong>任意大小</strong>的整数。<code>BigInteger</code>内部用一个<code>int[]</code><strong>数组</strong>来模拟一个非常大的整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure>

<p>对<code>BigInteger</code>做运算的时候，只能使用<strong>实例方法</strong>，例如，加法运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>BigInteger</code>不会有范围限制，但缺点是<strong>速度比较慢</strong></li>
</ul>
<p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure>
<p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code></p>
<p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是<strong>不可变类</strong>，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p>
<ul>
<li>转换为<code>byte</code>：<code>byteValue()</code></li>
<li>转换为<code>short</code>：<code>shortValue()</code></li>
<li>转换为<code>int</code>：<code>intValue()</code></li>
<li>转换为<code>long</code>：<code>longValue()</code></li>
<li>转换为<code>float</code>：<code>floatValue()</code></li>
<li>转换为<code>double</code>：<code>doubleValue()</code></li>
</ul>
<p>如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。</p>
<p>如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常</p>
<h2 id="9-BigDecimal"><a href="#9-BigDecimal" class="headerlink" title="9.BigDecimal"></a>9.BigDecimal</h2><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个<strong>任意大小且精度完全准确</strong>的浮点数</p>
<p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但<strong>去掉了末尾0</strong>的<code>BigDecimal</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d4</span> <span class="operator">=</span> d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0</li>
</ul>
<p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456789&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d4</span> <span class="operator">=</span> d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure>
<p>还可以对BigDecimal做除法的同时求余数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12.345&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.12&quot;</span>);</span><br><span class="line">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">        System.out.println(dr[<span class="number">0</span>]); <span class="comment">// 102</span></span><br><span class="line">        System.out.println(dr[<span class="number">1</span>]); <span class="comment">// 0.105</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是<strong>商和余数</strong>，其中商总是整数，余数不会大于除数</li>
</ul>
<h3 id="比较BigDecimal"><a href="#比较BigDecimal" class="headerlink" title="比较BigDecimal"></a>比较BigDecimal</h3><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等</p>
<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于</p>
<ul>
<li>&#x3D;&#x3D;总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！&#x3D;&#x3D;</li>
</ul>
<p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimal</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BigDecimal&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-常用工具类"><a href="#10-常用工具类" class="headerlink" title="10.常用工具类"></a>10.常用工具类</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>求绝对值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br></pre></td></tr></table></figure>
<p>取最大或最小值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure>
<p>计算xy次方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br></pre></td></tr></table></figure>
<p>计算√x：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br></pre></td></tr></table></figure>
<p>计算ex次方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.389...</span></span><br></pre></td></tr></table></figure>
<p>计算以e为底的对数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br></pre></td></tr></table></figure>
<p>计算以10为底的对数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>三角函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure>
<p>Math还提供了几个数学常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure>
<p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure>

<p>如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间在[MIN, MAX)的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.random(); <span class="comment">// x的范围是[0,1)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> x * (max - min) + min; <span class="comment">// y的范围是[10,50)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">long</span>) y; <span class="comment">// n的范围是[10,50)的整数</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java标准库还提供了一个<code>StrictMath</code>，它提供了和<code>Math</code>几乎一模一样的方法</p>
<ul>
<li><code>StrictMath</code>保证所有平台计算结果都是<strong>完全相同</strong>的，而<code>Math</code>会尽量针对平台优化计算速度</li>
</ul>
<h3 id="HexFormat"><a href="#HexFormat" class="headerlink" title="HexFormat"></a>HexFormat</h3><p>要将<code>byte[]</code>数组转换为十六进制字符串，可以用<code>formatHex()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">HexFormat</span> <span class="variable">hf</span> <span class="operator">=</span> HexFormat.of();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hexData</span> <span class="operator">=</span> hf.formatHex(data); <span class="comment">// 48656c6c6f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要定制转换格式，则使用定制的<code>HexFormat</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分隔符为空格，添加前缀0x，大写字母:</span></span><br><span class="line"><span class="type">HexFormat</span> <span class="variable">hf</span> <span class="operator">=</span> HexFormat.ofDelimiter(<span class="string">&quot; &quot;</span>).withPrefix(<span class="string">&quot;0x&quot;</span>).withUpperCase();</span><br><span class="line">hf.formatHex(<span class="string">&quot;Hello&quot;</span>.getBytes())); <span class="comment">// 0x48 0x65 0x6C 0x6C 0x6F</span></span><br></pre></td></tr></table></figure>
<p>从十六进制字符串到<code>byte[]</code>数组转换，使用<code>parseHex()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bs = HexFormat.of().parseHex(<span class="string">&quot;48656c6c6f&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的<br>要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果不给定种子，就使用<strong>系统当前时间戳</strong>作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同</li>
</ul>
<p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 51, 80, 41, 28, 55...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前面我们使用的<code>Math.random()</code>实际上内部调用了<code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子</li>
</ul>
<h3 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h3><p>。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建<strong>安全的随机数</strong>的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<p><code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法</p>
<p>实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            sr = <span class="keyword">new</span> <span class="title class_">SecureRandom</span>(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">        sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SecureRandom</code>的安全性是通过<strong>操作系统</strong>提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”</p>
<p>&#x3D;&#x3D;需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！&#x3D;&#x3D;</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2023/10/25/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>Java的异常</li>
<li>捕获异常</li>
<li>抛出异常</li>
<li>自定义异常</li>
<li>NullPointerException</li>
<li>使用断言</li>
<li>使用JDK Logging</li>
<li>使用Commons Logging</li>
<li>使用Log4j</li>
<li>使用SLF4J和Logback</li>
</ol>
<h2 id="1-Java的异常"><a href="#1-Java的异常" class="headerlink" title="1.Java的异常"></a>1.Java的异常</h2><p>调用方如何获知调用失败的信息？有两种方法：</p>
<p>方法一：<strong>约定返回错误码</strong><br>例如，处理一个文件，如果返回<code>0</code>，表示成功，返回其他整数，表示约定的错误码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> processFile(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// file not found:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// no read permission:</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为使用<code>int</code>类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</li>
</ul>
<p>方法二：在语言层面上提供一个<strong>异常处理机制</strong></p>
<p>Java内置了一套异常处理机制，总是使用<strong>异常</strong>来表示错误</p>
<p>异常是一种<code>class</code>，因此它本身带有类型信息。<br><u><strong>异常可以在任何地方抛出，但只需要在上层捕获</strong></u>，这样就和方法调用分离了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为Java的异常是<code>class</code>，它的继承关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class="line">         └─────────────────────┘ └─────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从继承关系可知：<code>Throwable</code>是异常体系的<strong>根</strong>，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示<strong>严重的错误</strong>，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：<strong>内存耗尽</strong></li>
<li><code>NoClassDefFoundError</code>：<strong>无法加载某个Class</strong></li>
<li><code>StackOverflowError</code>：<strong>栈溢出</strong></li>
</ul>
<p>而<code>Exception</code>则是<strong>运行时的错误</strong>，<u>它可以被捕获并处理</u></p>
<p>某些异常是<strong>应用程序逻辑处理</strong>的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：<strong>数值类型的格式错误</strong></li>
<li><code>FileNotFoundException</code>：<strong>未找到文件</strong></li>
<li><code>SocketException</code>：<strong>读取网络失败</strong></li>
</ul>
<p>还有一些异常是<strong>程序逻辑编写不对</strong>造成的，应该修复程序本身。例如：</p>
<ul>
<li><code>NullPointerException</code>：<strong>对某个<code>null</code>的对象调用方法或字段</strong></li>
<li><code>IndexOutOfBoundsException</code>：<strong>数组索引越界</strong></li>
</ul>
<p><code>Exception</code>又分为两大类：</p>
<ol>
<li><strong><code>RuntimeException</code>以及它的子类</strong></li>
<li>**非<code>RuntimeException</code>**（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>
</ol>
<p>Java规定：</p>
<ul>
<li><p>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为<strong>Checked Exception</strong>。</p>
</li>
<li><p>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</p>
</li>
</ul>
<p>&#x3D;&#x3D;注意：编译器对RuntimeException及其子类<strong>不做强制捕获要求</strong>，不是指应用程序本身不应该捕获并处理RuntimeException。是否需要捕获，具体问题具体分析&#x3D;&#x3D;</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果我们不捕获<code>UnsupportedEncodingException</code>，会出现编译失败的问题</li>
<li>编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且<strong>准确地指出</strong>需要捕获的语句是<code>return s.getBytes(&quot;GBK&quot;);</code></li>
<li>意思是说，像<code>UnsupportedEncodingException</code>这样的Checked Exception，必须被捕获</li>
</ul>
<p>这是因为<code>String.getBytes(String)</code>方法定义是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在方法定义的时候，使用<code>throws Xxx</code>表示该方法<strong>可能抛出</strong>的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错</li>
</ul>
<p>在<code>toGBK()</code>方法中，因为调用了<code>String.getBytes(String)</code>方法，就必须捕获<code>UnsupportedEncodingException</code></p>
<p>我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>，就可以让<code>toGBK()</code>方法通过编译器检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用<code>return s.getBytes(&quot;GBK&quot;);</code>的问题，而是<code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在<code>main()</code>方法中，调用<code>toGBK()</code>，没有捕获它声明的可能抛出的<code>UnsupportedEncodingException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可见，只要是方法声明的Checked Exception，<u><strong>不在调用层捕获，也必须在更高的调用层捕获</strong></u>。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会</p>
</li>
<li><p>如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">       System.out.println(Arrays.toString(bs));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">       <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">       <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代价就是一旦发生异常，程序会立刻退出</li>
</ul>
</li>
</ul>
<p>还有一些童鞋喜欢在<code>toGBK()</code>内部“消化”异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 什么也不干</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要<strong>先把异常记录下来</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈</li>
</ul>
<h2 id="2-捕获异常"><a href="#2-捕获异常" class="headerlink" title="2.捕获异常"></a>2.捕获异常</h2><h3 id="多catch语句"><a href="#多catch语句" class="headerlink" title="多catch语句"></a>多catch语句</h3><p>VM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后_不再继续匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>子类必须写在前面</strong></li>
</ul>
<h3 id="finally语句"><a href="#finally语句" class="headerlink" title="finally语句"></a>finally语句</h3><p><code>finally</code>语句块保证有无错误都会执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>finally</code>有几个特点：</p>
<ol>
<li><code>finally</code>语句<strong>不是必须</strong>的，可写可不写；</li>
<li><code>finally</code>总是<strong>最后执行</strong>。</li>
</ol>
<p>可以没有<code>catch</code>，只使用<code>try ... finally</code>结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为方法声明了可能抛出的异常，所以可以不写<code>catch</code></p>
<h3 id="捕获多种异常"><a href="#捕获多种异常" class="headerlink" title="捕获多种异常"></a>捕获多种异常</h3><p>如果某些异常的处理逻辑相同，但是异常<u><strong>本身不存在继承关系</strong></u>，那么就得编写多条<code>catch</code>子句;</p>
<ul>
<li>若处理<code>IOException</code>和<code>NumberFormatException</code>的代码是相同的，我们可以把它两用<code>|</code>合并到一起   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-抛出异常"><a href="#3-抛出异常" class="headerlink" title="3.抛出异常"></a>3.抛出异常</h2><h3 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h3><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到<strong>上层</strong>调用方法，直到遇到某个<code>try ... catch</code>被捕获为止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        Integer.parseInt(<span class="literal">null</span>); <span class="comment">// 会抛出NumberFormatException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>printStackTrace()</code>可以打印出<strong>方法的调用栈</strong>，类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NumberFormatException: <span class="literal">null</span></span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">614</span>)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">770</span>)</span><br><span class="line">    at Main.process2(Main.java:<span class="number">16</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">12</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在<code>java.lang.Integer.parseInt</code>方法中被抛出的，<strong>从下往上</strong>看，调用层次依次是：</p>
<ol>
<li><code>main()</code>调用<code>process1()</code>；</li>
<li><code>process1()</code>调用<code>process2()</code>；</li>
<li><code>process2()</code>调用<code>Integer.parseInt(String)</code>；</li>
<li><code>Integer.parseInt(String)</code>调用<code>Integer.parseInt(String, int)</code></li>
</ol>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>抛出异常分两步：</p>
<ol>
<li>创建某个<code>Exception</code>的实例；</li>
<li>用<code>throw</code>语句抛出。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型<strong>“转换”</strong>了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在<code>main()</code>中捕获<code>IllegalArgumentException</code>，我们看看打印的异常栈：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出的异常栈类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:<span class="number">15</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>这说明新的异常<u><strong>丢失了原始异常信息</strong></u>，我们已经看不到原始异常<code>NullPointerException</code>的信息了</li>
</ul>
<p>为了能追踪到完整的异常栈，在构造异常的时候，<u><strong>把原始的<code>Exception</code>实例传进去</strong></u>，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，打印出的异常栈类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:<span class="number">15</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:<span class="number">20</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>注意到<code>Caused by: Xxx</code>，说明捕获的<code>IllegalArgumentException</code>并不是造成问题的根源，根源在于<code>NullPointerException</code>，是在<code>Main.process2()</code>方法抛出的</li>
</ul>
<p>在代码中<strong>获取原始异常</strong>可以使用<code>Throwable.getCause()</code>方法。如果返回<code>null</code>，说明已经是“根异常”了</p>
<h2 id="4-自定义异常"><a href="#4-自定义异常" class="headerlink" title="4.自定义异常"></a>4.自定义异常</h2><p>Java标准库定义的常用异常包括：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure>

<p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p>
<p>一个常见的做法是自定义一个<code>BaseException</code>作为<strong>“根异常”</strong>，然后，派生出各种业务类型的异常。</p>
<p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义的<code>BaseException</code>应该提供多个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-NullPointerException"><a href="#5-NullPointerException" class="headerlink" title="5.NullPointerException"></a>5.NullPointerException</h2><p><code>NullPointerException</code>即<u><strong>空指针异常</strong></u>，俗称NPE</p>
<p>如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code>，这个异常通常是由<strong>JVM</strong>抛出的，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-使用断言"><a href="#6-使用断言" class="headerlink" title="6.使用断言"></a>6.使用断言</h2><p>断言（Assertion）是一种调试程序的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p>
<ul>
<li>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>

  这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;= 0</code>，更加便于调试</li>
</ul>
<p>Java断言的特点是：<u><strong>断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段</strong></u></p>
<p>对于可恢复的程序错误，不应该使用断言。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该抛出异常并在上层捕获：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行</p>
<ul>
<li><p>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java -ea Main.java</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class="line">at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>还可以<strong>有选择地对特定的类</strong>启用断言，命令行参数是：<code>-ea:com.itranswarp.sample.Main</code>，表示只对<code>com.itranswarp.sample.Main</code>这个类启用断言</p>
</li>
<li><p>或者对<strong>特定地包启用断言</strong>，命令行参数是：<code>-ea:com.itranswarp.sample...</code>（注意结尾有3个<code>.</code>），表示对<code>com.itranswarp.sample</code>这个包启动断言</p>
</li>
</ul>
<h2 id="7-使用JDK-Logging"><a href="#7-使用JDK-Logging" class="headerlink" title="7.使用JDK Logging"></a>7.使用JDK Logging</h2><p>日志就是Logging，它的目的是为了取代<code>System.out.println()</code></p>
<p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p>
<ol>
<li>可以<strong>设置输出样式</strong>，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li>
<li>可以<strong>设置输出级别</strong>，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以<strong>被重定向到文件</strong>，这样可以在程序运行结束后查看日志；</li>
<li>可以<strong>按包名控制日志级别</strong>，只输出某些包打的日志；</li>
</ol>
<p>Java标准库内置了日志包<code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，得到类似如下的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure>
<ul>
<li>再仔细观察发现，4条日志，只打印了3条，<code>logger.fine()</code>没有打印。这是因为，<strong>日志的输出可以设定级别</strong>。</li>
</ul>
<p>JDK的Logging定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST<br>因为<strong>默认级别是INFO</strong>，因此，INFO级别以下的日志，不会被打印出来</li>
</ul>
<p>使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出</p>
<p>使用Java标准库内置的Logging有以下局限：</p>
<ol>
<li>Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</li>
<li>配置不太方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</li>
</ol>
<p>因此，Java标准库内置的Logging使用并不是非常广泛</p>
<h2 id="8-使用Commons-Logging"><a href="#8-使用Commons-Logging" class="headerlink" title="8.使用Commons Logging"></a>8.使用Commons Logging</h2><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块</p>
<p>Commons Logging的特色是，<u><strong>它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统</strong></u>。默认情况下，Commons Logging<strong>自动搜索并使用Log4j</strong>（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging</p>
<p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p>
<p>第一步，<strong>通过<code>LogFactory</code>获取<code>Log</code>类的实例</strong>； 第二步，<strong>使用<code>Log</code>实例的方法打日志</strong><br>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Commons Logging是一个第三方提供的库，所以，必须先把它<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">下载</a>下来</li>
<li>下载后，解压，找到<code>commons-logging-1.2.jar</code>这个文件，再把Java源码<code>Main.java</code>放到一个目录下</li>
<li>然后用<code>javac</code>编译<code>Main.java</code>，编译的时候要指定<code>classpath</code>，不然编译器找不到我们引用的<code>org.apache.commons.logging</code>包 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -cp commons-logging-1.2.jar Main.java</span><br></pre></td></tr></table></figure></li>
</ol>
<p>Commons Logging定义了6个日志级别：</p>
<ul>
<li>FATAL</li>
<li>ERROR</li>
<li>WARNING</li>
<li>INFO</li>
<li>DEBUG</li>
<li>TRACE</li>
</ul>
<p>默认级别是<code>INFO</code></p>
<p>使用Commons Logging时，如果在静态方法中引用<code>Log</code>，通常<strong>直接定义一个静态类型变量</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，Commons Logging的日志方法，例如<code>info()</code>，除了标准的<code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-使用Log4j"><a href="#9-使用Log4j" class="headerlink" title="9.使用Log4j"></a>9.使用Log4j</h2><p>真正的“日志实现”可以使用Log4j</p>
<p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log.info(&quot;User signed in.&quot;);</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │</span><br><span class="line">     └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br></pre></td></tr></table></figure>

<p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到<strong>不同的目的地</strong>：</p>
<ul>
<li>console：输出到屏幕；</li>
<li>file：输出到文件；</li>
<li>socket：通过网络输出到远程计算机；</li>
<li>jdbc：输出到数据库</li>
</ul>
<p>通过Filter来<strong>过滤</strong>哪些log需要被输出，哪些log不需要被输出<br>通过Layout来<strong>格式化</strong>日志信息</p>
<p>因为Log4j也是一个第三方库，我们需要从<a href="https://logging.apache.org/log4j/2.x/download.html">这里</a>下载Log4j，解压后，把以下3个jar包放到<code>classpath</code>中：</p>
<ul>
<li>log4j-api-2.x.jar</li>
<li>log4j-core-2.x.jar</li>
<li>log4j-jcl-2.x.jar</li>
</ul>
<p>因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的<code>commons-logging-1.2.jar</code>也放到<code>classpath</code>中。</p>
<h2 id="10-使用SLF4J和Logback"><a href="#10-使用SLF4J和Logback" class="headerlink" title="10.使用SLF4J和Logback"></a>10.使用SLF4J和Logback</h2><p>SLF4J类似于Commons Logging，也是一个<strong>日志接口</strong>，而Logback类似于Log4j，是一个<strong>日志的实现</strong></p>
<p>在Commons Logging中，我们要打印日志，有时候得这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure>
<ul>
<li>SLF4J的日志接口传入的是一个带占位符的字符串</li>
</ul>
<p>如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比一下Commons Logging和SLF4J的接口：</p>
<table>
<thead>
<tr>
<th>Commons Logging</th>
<th>SLF4J</th>
</tr>
</thead>
<tbody><tr>
<td>org.apache.commons.logging.Log</td>
<td>org.slf4j.Logger</td>
</tr>
<tr>
<td>org.apache.commons.logging.LogFactory</td>
<td>org.slf4j.LoggerFactory</td>
</tr>
<tr>
<td>&#x3D;&#x3D;不同之处就是Log变成了Logger，LogFactory变成了LoggerFactory&#x3D;&#x3D;</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA程序基础</title>
    <url>/2023/10/25/JAVA%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>变量和数据类型</li>
<li>整数运算</li>
<li>浮点数运算</li>
<li>字符和字符串</li>
<li>数组类型</li>
<li>流程控制</li>
<li>数组操作</li>
</ol>
<h2 id="1-变量和数据类型"><a href="#1-变量和数据类型" class="headerlink" title="1.变量和数据类型"></a>1.变量和数据类型</h2><ul>
<li>byte是<strong>最小</strong>储存单位 &#x3D;&#x3D; <strong>8</strong>位二进制数（8个bit） 0-255</li>
<li>一个字节是1byte，1024byte &#x3D; 1K，1024K &#x3D; 1M，1024M &#x3D; 1G，1024G &#x3D; 1T</li>
<li>int<strong>4</strong>字节，long<strong>8</strong>字节，float<strong>4</strong>字节，double<strong>8</strong>字节，char<strong>2</strong>字节</li>
<li>float类型要加上<strong>f</strong>，例如&#x3D;&#x3D;float f1 &#x3D; 3.14f&#x3D;&#x3D;   </li>
<li>理论上布尔类型只要1bit，但是JVM内部会把boolean表示为<strong>4</strong>字节整数</li>
<li>char用<strong>单</strong>引号且只有一个字符，String用<strong>双</strong>引号（String是引用类型）</li>
<li>引用类型类似于C的指针，指向某个对象在内存的<strong>位置</strong></li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>修饰的变量会变为常量，常量初始化后不可赋值</p>
<h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><p>省略变量类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br></pre></td></tr></table></figure>
<p>可以变为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>
<h2 id="2-整数运算"><a href="#2-整数运算" class="headerlink" title="2.整数运算"></a>2.整数运算</h2><ul>
<li>整数除法对于除数为0的情况运行会报错，<strong>编译不报错</strong></li>
<li>对<code>byte</code>和<code>short</code>类型进行移位时会先转化为<code>int</code></li>
<li>如果运算的类型不同，自动转化为<strong>大类型</strong></li>
<li>超出范围的强制转型会得到错误的结果</li>
</ul>
<h2 id="3-浮点数运算"><a href="#3-浮点数运算" class="headerlink" title="3.浮点数运算"></a>3.浮点数运算</h2><ul>
<li>浮点数在计算机无法精确表示，因此常常出错，只能保存个近似值（<strong>二进制</strong>）</li>
<li>浮点数在除数为0时不会报错，但会返回三个特殊值：NaN表示<strong>Not a Number</strong>、Infinity表示<strong>无穷大</strong>、-Infinity表示<strong>负无穷大</strong></li>
</ul>
<h2 id="4-字符和字符串"><a href="#4-字符和字符串" class="headerlink" title="4.字符和字符串"></a>4.字符和字符串</h2><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul>
<li>java在内存中使用Unicode表示字符，所以一个英文字符和一个中文字符都占<strong>两个</strong>字节</li>
<li>将<code>char</code>类型赋给<code>int</code>类型即可显示Unicode编码</li>
<li>还可以使用转义字符<code>\u</code>+Unicode编码表示一个字符<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意是十六进制:</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;，因为十六进制0041 = 十进制65</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="string">&#x27;\u4e2d&#x27;</span>; <span class="comment">// &#x27;中&#x27;，因为十六进制4e2d = 十进制20013</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><ul>
<li>从java13开始可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   SELECT * FROM</span></span><br><span class="line"><span class="string">                     users</span></span><br><span class="line"><span class="string">                   WHERE id &gt; 100</span></span><br><span class="line"><span class="string">                   ORDER BY name DESC</span></span><br><span class="line"><span class="string">                   &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述多行字符串实际上是5行，在最后一个<code>DESC</code>后面还有一个<code>\n</code>。如果我们不想在字符串末尾加一个<code>\n</code>，就需要这么写：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">           SELECT * FROM</span></span><br><span class="line"><span class="string">             users</span></span><br><span class="line"><span class="string">           WHERE id &gt; 100</span></span><br><span class="line"><span class="string">           ORDER BY name DESC&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
还需要注意到，多行字符串前面共同的空格会被去掉,即总是以最短的行首空格为基准。</li>
</ul>
<h4 id="不可变特性"><a href="#不可变特性" class="headerlink" title="不可变特性"></a>不可变特性</h4><ul>
<li>只会改变<strong>变量的指向</strong>，不会改变字符串</li>
<li>String[] 类型的对象是<strong>可变的</strong>，也就是说，可以修改数组中的元素值。</li>
<li>空字符串不等于<code>null</code></li>
</ul>
<h2 id="5-数组类型"><a href="#5-数组类型" class="headerlink" title="5.数组类型"></a>5.数组类型</h2><p>数组一旦创建后，大小就不可改变</p>
<h2 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6.流程控制"></a>6.流程控制</h2><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
<tr>
<td>%e</td>
<td>科学计数法</td>
</tr>
</tbody></table>
<ul>
<li>连续两个%%表示一个%字符本身</li>
</ul>
<p>有了<code>Scanner</code>对象后，用<code>scanner.nextLine()</code>读取字符串，用<code>scanner.nextInt()</code>读取输入的整数</p>
<ul>
<li><code>Scanner</code>会<strong>自动转换</strong>数据类型，因此不必手动转换</li>
</ul>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p><code>==</code>表示“引用是否相等”，或者说，是否<strong>指向</strong>同一个对象</p>
<p>要判断引用类型的<strong>变量内容</strong>是否相等，必须使用<code>equals()</code>方法</p>
<ul>
<li>执行语句<code>s1.equals(s2)</code>时，如果变量<code>s1</code>为<code>null</code>，会报<code>NullPointerException</code></li>
<li>要避免<code>NullPointerException</code>错误，可以利用短路运算符<code>&amp;&amp;</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s1 != <span class="literal">null</span> &amp;&amp; s1.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="switch判断"><a href="#switch判断" class="headerlink" title="switch判断"></a>switch判断</h3><p>如果没有匹配到任何<code>case</code>，那么<code>switch</code>语句不会执行任何语句。这时，可以给<code>switch</code>语句加一个<code>default</code>，当没有匹配到任何<code>case</code>时，执行<code>default</code></p>
<p><code>case</code>语句并**没有花括号<code>&#123;&#125;</code>**，而且，<code>case</code>语句具有“_穿透性_”，漏写<code>break</code>将导致意想不到的结果</p>
<ul>
<li>后续语句将<strong>全部执行</strong>，直到遇到<code>break</code>语句</li>
</ul>
<p>如果有几个<code>case</code>语句执行的是同一组语句块，可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">       System.out.println(<span class="string">&quot;Selected 2, 3&quot;</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p><code>case</code>匹配字符串时，是比较<strong>内容相等</strong></p>
<h2 id="7-数组操作"><a href="#7-数组操作" class="headerlink" title="7.数组操作"></a>7.数组操作</h2><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p><code>Arrays.toString()</code>用于快速打印数组内容</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的<code>Arrays.sort()</code>就可以排序</p>
<p>必须注意，对数组排序实际上<strong>修改了数组本身</strong></p>
<p>如果对一个字符串数组进行排序，原来的3个字符串在内存中均没有任何变化，但是<code>ns</code>数组的每个元素<strong>指向变化了</strong></p>
<ul>
<li>排序前，这个数组在内存中表示如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────────────────┐           │</span><br><span class="line">               │   │                      ▼           ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────▶│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                 ▲</span><br><span class="line">           └─────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>Arrays.sort(ns);</code>排序后，这个数组在内存中表示如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────┐                       │</span><br><span class="line">               │   │          ▼                       ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────▶│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                              ▲</span><br><span class="line">           └──────────────────────────────┘</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="冒泡排序-从小到大"><a href="#冒泡排序-从小到大" class="headerlink" title="冒泡排序(从小到大)"></a>冒泡排序(从小到大)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ns.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ns.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ns[j] &gt; ns[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换ns[j]和ns[j+1]:</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ns[j];</span><br><span class="line">                    ns[j] = ns[j+<span class="number">1</span>];</span><br><span class="line">                    ns[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组的每个数组元素的长度<strong>并不要求相同</strong>，例如，可以这么定义<code>ns</code>数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要打印一个二维数组，可以使用两层嵌套的for循环,或者使用Java标准库的<code>Arrays.deepToString()</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2023/10/25/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>什么是泛型</li>
<li>使用泛型</li>
<li>编写泛型</li>
<li>擦拭法</li>
<li>extends通配符</li>
<li>super通配符</li>
<li>泛型和反射</li>
</ol>
<h2 id="1-什么是泛型"><a href="#1-什么是泛型" class="headerlink" title="1.什么是泛型"></a>1.什么是泛型</h2><p>泛型就是<strong>定义一种模板</strong>，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>


<p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>要<strong>特别注意</strong>：不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code></p>
<p>&#x3D;&#x3D;ArrayList<Integer>和ArrayList<Number>两者完全没有继承关系&#x3D;&#x3D;</p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><h2 id="2-使用泛型"><a href="#2-使用泛型" class="headerlink" title="2.使用泛型"></a>2.使用泛型</h2><p>使用<code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code>Object</code></p>
<p>编译器如果能<strong>自动推断出泛型类型</strong>，就可以省略后面的泛型类型。例如，对于下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在<strong>接口</strong>中使用泛型</p>
<p><code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>String</code>本身已经实现了<code>Comparable&lt;String&gt;</code>接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    Person(String name, <span class="type">int</span> score) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="built_in">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以正确实现按<code>name</code>进行排序</p>
<h2 id="3-编写泛型"><a href="#3-编写泛型" class="headerlink" title="3.编写泛型"></a>3.编写泛型</h2><p>把特定类型<code>String</code>替换为<code>T</code>，并申明<code>&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><u><strong>泛型类型<code>&lt;T&gt;</code>不能用于静态方法</strong></u></p>
<p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用<strong>另一个类型</strong>即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="title function_">create</span><span class="params">(K first, K last)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h3><p>我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, K last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-擦拭法"><a href="#4-擦拭法" class="headerlink" title="4.擦拭法"></a>4.擦拭法</h2><p>Java语言的泛型实现方式是<strong>擦拭法（Type Erasure）</strong></p>
<ul>
<li>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的</li>
</ul>
<p>Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>
<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型</li>
</ul>
<p>Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，<u><strong>编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型</strong></u></p>
<p>Java泛型的<strong>局限</strong>:</p>
<ol>
<li><code>&lt;T&gt;</code><strong>不能是基本类型</strong>，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;<span class="type">int</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure></li>
<li>无法取得带泛型的<code>Class</code></li>
<li>无法判断带泛型的类型 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>不能实例化<code>T</code>类型</li>
</ol>
<h3 id="不恰当的覆写方法"><a href="#不恰当的覆写方法" class="headerlink" title="不恰当的覆写方法"></a>不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    public boolean equals(T t) &#123;</span><br><span class="line">        return this == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>换个方法名，避开与<code>Object.equals(Object)</code>的冲突就可以成功编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">same</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>一个类可以继承自一个泛型类</p>
<p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型</p>
<h2 id="5-extends通配符"><a href="#5-extends通配符" class="headerlink" title="5.extends通配符"></a>5.extends通配符</h2><p>假设我们定义了<code>Pair&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我们又针对<code>Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code>Pair&lt;Number&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PairHelper</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码是可以正常编译的。使用的时候，我们传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> PairHelper.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Number&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：传入的类型是<code>Pair&lt;Number&gt;</code>，实际参数类型是<code>(Integer, Integer)</code></p>
<p><u><strong>使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型</strong></u></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为<strong>上界通配符（Upper Bounds Wildcards）</strong>，即把泛型类型<code>T</code>的上界限定在<code>Number</code>了</li>
</ul>
<h2 id="6-super通配符"><a href="#6-super通配符" class="headerlink" title="6.super通配符"></a>6.super通配符</h2><h2 id="7-泛型和反射"><a href="#7-泛型和反射" class="headerlink" title="7.泛型和反射"></a>7.泛型和反射</h2>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2023/10/26/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自：<strong>《计算机网络》(谢希仁)</strong></p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的特性：</p>
<ol>
<li><strong>机械特性</strong>：指明接口所用的接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</li>
<li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的<strong>电压</strong>的范围</li>
<li><strong>功能特性</strong>：指明某条线上出现的某一电平的<strong>电压</strong>的意义</li>
<li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序</li>
</ol>
<p>数据在计算机内部多采用并行传输方式，但在通信线路上一般都是<strong>串行传输</strong>(经济因素)，即逐个比特按照时间顺序传输</p>
<h2 id="2-数据通信"><a href="#2-数据通信" class="headerlink" title="2. 数据通信"></a>2. 数据通信</h2><p>数据通信系统可划分为三个部分：<strong>源系统</strong>、<strong>传输系统</strong>、<strong>目的系统</strong></p>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.6349DelfGpekAnkd9XPNUQAAAA?w=310&h=155&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="数据通信系统模型 的图像结果"></p>
<p>源系统一般分为两个部分：</p>
<ul>
<li><strong>源点</strong>(source)：源点设备产生要传输的数据</li>
<li><strong>发送器</strong>：通常源点生成的数字比特流要通过发送器编码后才能在传输系统中进行传输，典型的发送器是<strong>调节器</strong></li>
</ul>
<p>目的系统一般也分为两个部分：</p>
<ul>
<li><strong>接收器</strong>：接受传输系统传送过来的信号，并<u>把它转换为能够被目的设备处理的信息</u></li>
<li><strong>终点</strong>(destination)：从接收器获取传送来的数字比特流，然后把信息输出</li>
</ul>
<p>模拟信号是连续的，数字信号是离散的<br>代表不同离散数值的基本波形成为<strong>码元</strong></p>
<ul>
<li>一个码元携带的信息量<strong>不固定</strong>，由调制方式和编码方式决定</li>
</ul>
<p>从通信的双方信息交互方式来看，有以下三种基本方式:</p>
<ol>
<li><strong>单工通信</strong>：只能由一个方向的通信而没有反方向的交互</li>
<li><strong>半双工通信</strong>：通信的双方都可以发送信息，但不能同时发送</li>
<li><strong>全双工通信</strong>：通信的双方可以同时发送和接收信息</li>
</ol>
<p>来自信源的信号成为<strong>基带信号</strong>，必须进行<strong>调制</strong><br>调制可分为两大类：</p>
<ul>
<li><strong>基带调制</strong>：仅仅对基带信号的波形进行变化<ul>
<li>这是把数字信号转换为另一种数字信号，因此成为<strong>编码</strong></li>
</ul>
</li>
<li><strong>带通调制</strong>：使用<strong>载波</strong>(carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并<u>转换为模拟信号</u><ul>
<li>经过调制的信号成为<strong>带通信号</strong></li>
</ul>
</li>
</ul>
<h3 id="编码和调制"><a href="#编码和调制" class="headerlink" title="编码和调制"></a>编码和调制</h3><p>常用编码方式如图<br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.uBw4xIfFNVIif77JCPqMaQHaEF?pid=ImgDet&rs=1" alt="计算机网络学习【入门】——（二）物理层_Leon595的博客-CSDN博客"></p>
<ul>
<li><strong>不归零制</strong>：正电平代表1，负电平代表0</li>
<li><strong>归零制</strong>：正脉冲代表1，负脉冲代表0</li>
<li><strong>曼彻斯特编码</strong>：位周期中心的向上跳变代表0，向下跳变代表1</li>
<li><strong>差分曼彻斯特编码</strong>：每一位的中心处始终有跳变，位开始边界有跳变为0，没有跳变为1</li>
</ul>
<p>从信号波形来看，曼彻斯特编码产生的信号频率比不归零制高<br>从自身同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率</p>
<ul>
<li><strong>曼彻斯特编码具有自同步能力</strong></li>
</ul>
<p>基本的带通调制方法如图<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.zOwL4AlFv9KhZvfPZOsHzwAAAA?w=298&h=149&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="最基本的三种调制方法 的图像结果"></p>
<ul>
<li><strong>调幅</strong>(AM)：载波的振幅随基带数字信号而变化</li>
<li><strong>调频</strong>(FM)：载波的频率随基带数字信号而变化</li>
<li><strong>调相</strong>(PM)：载波二点初始相位随基带数字信号而变化</li>
</ul>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>码元传输速率越高，信号传输距离越远，噪声干扰越大，传输媒体质量越差，在接收端的波形失真就越严重<br><img src="https://picture-pool.oss-cn-beijing.aliyuncs.com/006tNc79gy1g2w7as7a6oj30y00ak0uh.jpg" alt="计算机网络第二弹——物理层_信道和通信电路_ai-exception的博客-CSDN博客"></p>
<p>限制码元在信道上传输速率的因素：</p>
<ol>
<li><p><strong>信道能够通过的频率范围</strong></p>
<p> <strong>码间串扰</strong>：信号中的高频分量在传输时收到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，收到的信号波形就失去了码元之间的清晰界限</p>
<p> 为避免码间串扰，奈奎斯特(Nyquist)提出了<strong>奈氏准则</strong>，给出了在假定的理想条件下，<u><strong>码元的传输速率的上限值</strong></u></p>
<p> <strong>奈氏准则</strong>:理想低通信道下的极限数据传输率 &#x3D; 2W$\log_2V$(b&#x2F;s)</p>
<ul>
<li>其中W是<strong>理想低通信道的带宽</strong>(Hz), V表示每个码元离散电平的数目(<strong>有多少种不同的码元</strong>)</li>
</ul>
</li>
<li><p><strong>信噪比</strong><br> 信噪比就是信号的平均功率和噪声的平均功率之比，常记为<strong>S&#x2F;N</strong>,并用分贝(dB)作为度量单位</p>
<ul>
<li>信噪比(dB) &#x3D; $10log_{10}(S&#x2F;N)$(dB)</li>
</ul>
<p> 信息论的创始人香农(shannon)推导出了<strong>香农公式</strong>，推导出信道的极限传输速率</p>
<p> <strong>香农公式</strong>:C &#x3D; W$log_2(1 + S&#x2F;N)$（bit&#x2F;s）</p>
<ul>
<li>其中W为信道的带宽(Hz)， S为信道内锁传信号的平均功率，N为信道内部高斯噪声的功率</li>
</ul>
<p> 香农公式表明，<strong>信道的带宽或信道中的信噪比越大，信道的极限传输速率就越高</strong></p>
<p> 可以通过编码的方式<strong>让每一个码元携带更多比特的信息量</strong>，以提高信息传输速率</p>
</li>
</ol>
<h2 id="3-传输媒体"><a href="#3-传输媒体" class="headerlink" title="3. 传输媒体"></a>3. 传输媒体</h2><p>传输媒体可以分为<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p>
<ul>
<li>在非导引型传输媒体中电磁波的传输常称为无线传输</li>
</ul>
<h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><ol>
<li><strong>双绞线</strong>&#x2F;<del>双扭线</del><br>把两根互相绝缘的铜导线并排放在一起，然后用规则的方法<strong>绞合</strong>(twist)起来就构成了双绞线</li>
</ol>
<p>模拟传输和数字传输都可以使用双绞线</p>
<p><u>为了提高双绞线抗电磁干扰的能力</u>，可以在双绞线外面再加上一层由金属丝编制成的屏蔽层，也就是<strong>屏蔽双绞线STP</strong>(Shielded Twisted Pair)，价格也比<strong>无屏蔽双绞线UTP</strong>贵(Unshielded Twisted Pair)</p>
<ul>
<li>聚氯乙烯套层 -&gt; （屏蔽层）-&gt; 绝缘层 - &gt; 铜线</li>
</ul>
<table>
<thead>
<tr>
<th>绞合线类型</th>
<th>带宽</th>
<th>线缆特点</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td>16MHz</td>
<td>2对4芯双绞线</td>
<td>模拟电话，曾用于传统以太网(10Mbit&#x2F;s)</td>
</tr>
<tr>
<td>4</td>
<td>20MHz</td>
<td>4对8芯双绞线</td>
<td>曾用于令牌局域网</td>
</tr>
<tr>
<td>5</td>
<td>100MHz</td>
<td>与4类相比增加了绞合度</td>
<td>传输速率不超过100Mbit&#x2F;s的应用</td>
</tr>
<tr>
<td>5E(超5类)</td>
<td>125MHz</td>
<td>与5类相比衰减更小</td>
<td>传输速率不超过1Gbit&#x2F;s的应用</td>
</tr>
<tr>
<td>6</td>
<td>250MHz</td>
<td>与5类相比改善了串扰等性能</td>
<td>传输速率高于1Gbit&#x2F;s的应用</td>
</tr>
<tr>
<td>7</td>
<td>600MHz</td>
<td>使用屏蔽双绞线</td>
<td>传输速率不超过10Gbit&#x2F;s的应用</td>
</tr>
</tbody></table>
<p>现在最常用的是5类线</p>
<ol start="2">
<li><p><strong>同轴电缆</strong><br>同轴电缆由<u>内导体铜质导线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及保护塑料外层组成</u></p>
<p> 同轴电缆具有很好的抗干扰性，被广泛用于传输较高速率的数据</p>
<p> <img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.rlPy1N6-xI5h52Z3udFQTAHaDk?w=279&h=168&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="同轴电缆结构 的图像结果"></p>
<p> 同轴电缆的带宽取决于电缆的质量，目前高质量的同轴电缆带宽已接近1GHz</p>
</li>
<li><p><strong>光缆</strong><br>光纤通信就是<strong>利用光导纤维传递光脉冲来进行通信</strong></p>
<ul>
<li>一个光纤系统的传输带宽远远大于目前其他各种传输媒体的带宽</li>
</ul>
<p> <strong>光纤</strong>是光纤通信的传输媒体</p>
<p> <img src="https://pic4.zhimg.com/v2-016fc73f89c05c21da715e04c47ef50e_r.jpg" alt="光纤通信--光纤的结构及分类 - 知乎"></p>
<p> 从纤芯中射到纤芯表面的光线的<strong>入射角大于某个临界角度</strong>，就可产生全反射</p>
<p> <strong>多模光纤</strong>：存在多条不同角度入射的光线在一条光纤中传输<br> <strong>单模光纤</strong>：光纤的直径减少到只有一个光的波长，使光纤一直向前传播，而不会发生多次反射</p>
<p> <img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.3jq4e5woHaz5SSysAh4X6gHaDd?w=349&h=163&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="单模光纤和多模光纤的比较 的图像结果"></p>
<p> 光纤非常细，必须做成很结实的光缆<br> <img src="https://pic4.zhimg.com/v2-0811f0893ef97928616f36ad9b77ef9d_r.jpg" alt="通信用特种光缆的结构特点及应用场景 - 知乎"></p>
</li>
</ol>
<p>光纤不仅具有<strong>通信容量非常大</strong>的优点，而且还有一些其他的特点：</p>
<ul>
<li><strong>传输损耗小，中继距离长，对远距离传输特别经济</strong></li>
<li><strong>抗雷电和电磁干扰性能好</strong></li>
<li><strong>无串音干扰，保密性好</strong></li>
<li><strong>体积小，重量轻</strong></li>
</ul>
<h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><p><strong>低频LF</strong>：30kHz ~ 300kHz<br><strong>中频MF</strong>：300kHz ~ 3MHz<br><strong>高频HF</strong> ：3MHz ~ 30MHz</p>
<p>传统的微波通信主要有两种形式：</p>
<ol>
<li><strong>地面微波接力通信</strong> ：需要中继器将信号放大，可传输电话、电报、图像、数据等信息<ul>
<li>微波波段频率很高，其频带范围也很宽，因此通信信道容量很大（<u>卫星通信也是</u>）</li>
</ul>
</li>
<li><strong>卫星通信</strong><br>最大特点是<strong>通信距离远，通信费用与通信距离无关</strong>，但是<u>具有较大的传播时延</u></li>
</ol>
<h2 id="4-信道复用技术"><a href="#4-信道复用技术" class="headerlink" title="4. 信道复用技术"></a>4. 信道复用技术</h2><p>复用是通信技术中的基本概念<br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.RydtLD2-K6MuvBoPl_xfMAHaD7?w=320&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="频分复用示意图 的图像结果"></p>
<p>最基本的复用就是<strong>频分复用FDM</strong>(Frequency Division Multiplexing)和<strong>时分复用TDM</strong>(Time Division Multiplexing)</p>
<p>频分复用的所有用户<strong>在同样的时间内占用不同的带宽资源</strong></p>
<ul>
<li>这里的带宽指的是频率带宽而不是数据的发送速率</li>
</ul>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.wvj4XDg1aWNnVs78I99GKgHaEv?w=275&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="频分复用示意图 的图像结果"></p>
<p>时分复用把时间划分成一段段等长的<strong>时分复用帧(TDM帧)</strong></p>
<ul>
<li>TDM信号也称为等时信号</li>
</ul>
<p>时分复用的所有用户<strong>在不同的时间占用同样的频带宽度</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.YAE6Nth5Kqhl5j6p9iKF3AAAAA?w=244&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="时分复用示意图 的图像结果"></p>
<p>当用户暂时无数据发送时，在时分复用帧中分配给该用户的时隙只能处于空闲状态，这会导致复用后信道利用率不高<br><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.cRgewliFh4GaK0N7yHWK7gAAAA?pid=ImgDet&rs=1" alt="现代通信技术之交换技术基础_Leslie_Waong的博客-CSDN博客"></p>
<p>复用器和分用器总是成对使用，两者之间是用户共享的高速信道</p>
<p><strong>统计时分复用STDM</strong>(Statistic TDM)<br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.M6aX1Sh1rfNXXjwKwpSmbQHaDZ?pid=ImgDet&rs=1" alt="【计算机网络】信道复用技术_diligentyang的博客-CSDN博客"><br>STDM帧不是固定分配时隙，而是<strong>按需动态分配时隙</strong></p>
<ul>
<li>一个用户所占用的时隙并不是周期性地出现，因此又称为<strong>异步时分复用</strong></li>
</ul>
<p><strong>波分复用WDM</strong>(Wavelength Division Multiplexing)就是光的频分复用</p>
<ul>
<li>现在已经能在一根光纤上复用几十路甚至更多路数的光载波信号，于是使用了<strong>密集波分复用DWDM</strong>(Dense Wavelength Division Multiplexing)这一名词</li>
</ul>
<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.WZZa3GJsMhJwwq9Rp5MUrAHaEC?w=320&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="波分复用示意图 的图像结果"><br>波分复用的复用器可称为<strong>合波器</strong>，解复用器（分用器）又称为<strong>分波器</strong></p>
<p><strong>码分复用CDM</strong>(Code Division Multiplexing)是一种共享信道的方法，其实人们更常用的名词是<strong>码分多址CDMA</strong>(Code Division Multiple Access),每一个用户可以在同样的时间使用同样的频带进行通信</p>
<p>在CDMA中，每一个比特时间再划分为m个短的间隙，成为<strong>码片(chip)</strong>,通常m的值是64或128</p>
<p>了实现多用户同时通信而互补干扰，要求每个发送信号的站都使用不同的<strong>码片</strong>，也就是说使用CDMA的<strong>每一个站都被指派了一个唯一的mbit的码片序列</strong></p>
<blockquote>
<p>一个站如果要发送比特1，则发送他自己的mbit码片序列<br> 一个站如果要发送比特0，则发送自己的mbit码片序列的反码</p>
</blockquote>
<p>为了方便，我们按惯例将码片序列中的0写为-1，将1写为+1，这种通信方法称为<strong>直接序列扩频DSSS</strong>(Dienct Sequence Spread spectrum)</p>
<p>对于码片的挑选有以下原则：</p>
<ol>
<li><strong>分配给每个站的码片序列必须各不相同</strong></li>
<li><strong>分配给每个站的码片序列必须相互正交（规格化内积为零）</strong></li>
</ol>
<p>规格化内积计算公式：$S \cdot T &#x3D; \frac{1}{m}\sum_{i &#x3D; 1}^m{S_iT_i}&#x3D;0$</p>
<ol>
<li><strong>任何一个码片向量和自己的码片反码的向量的内积为-1</strong></li>
<li><strong>任何一个码片向量和自己的码片向量的内积为1</strong></li>
</ol>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2023/10/25/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>正则表达式简介</li>
<li>匹配规则</li>
<li>复杂匹配股则</li>
<li>分组匹配</li>
<li>非贪婪匹配</li>
<li>搜索和替换</li>
</ol>
<h2 id="1-正则表达式简介"><a href="#1-正则表达式简介" class="headerlink" title="1.正则表达式简介"></a>1.正则表达式简介</h2><p>正则表达式可以用字符串来<strong>描述规则</strong>，并用来匹配字符串</p>
<p>例如，判断手机号，我们用正则表达式<code>\d&#123;11&#125;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidMobileNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要判断用户输入的年份是否是<code>20##</code>年，我们先写出规则如下：</p>
<p>一共有4个字符，分别是：<code>2</code>，<code>0</code>，<code>0~9任意数字</code>，<code>0~9任意数字</code>。</p>
<p>对应的正则表达式就是：<code>20\d\d</code>，其中<u><strong><code>\d</code>表示任意一个数字</strong></u>。</p>
<p>把正则表达式转换为Java字符串就变成了<code>20\\d\\d</code>，注意Java字符串用<code>\\</code>表示<code>\</code></p>
<h2 id="2-匹配规则"><a href="#2-匹配规则" class="headerlink" title="2.匹配规则"></a>2.匹配规则</h2><p>正则表达式的匹配规则是<strong>从左到右</strong>按规则匹配</p>
<ul>
<li><p>对于正则表达式<code>abc</code>来说，它只能精确地匹配字符串<code>&quot;abc&quot;</code>，不能匹配<code>&quot;ab&quot;</code>，<code>&quot;Abc&quot;</code>，<code>&quot;abcd&quot;</code>等其他任何字符串。</p>
</li>
<li><p>如果正则表达式有特殊字符，那就需要<strong>用<code>\</code>转义</strong>。例如，正则表达式<code>a\&amp;c</code>，其中<code>\&amp;</code>是用来匹配特殊字符<code>&amp;</code>的，它能精确匹配字符串<code>&quot;a&amp;c&quot;</code>，但不能匹配<code>&quot;ac&quot;</code>、<code>&quot;a-c&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>等。</p>
</li>
<li><p><u><strong>两个<code>\\</code>实际上表示的是一个<code>\</code></strong></u></p>
</li>
</ul>
<h3 id="匹配任意字符"><a href="#匹配任意字符" class="headerlink" title="匹配任意字符"></a>匹配任意字符</h3><p>我们可以用<code>.</code>匹配一个任意字符</p>
<ul>
<li><code>.</code>匹配一个字符且仅限一个字符</li>
</ul>
<h3 id="匹配数字"><a href="#匹配数字" class="headerlink" title="匹配数字"></a>匹配数字</h3><p>如果我们只想匹配<code>0</code>~&#96;9<code>这样的数字，可以用</code>\d&#96;匹配</p>
<ul>
<li><code>\d</code>仅限单个数字字符</li>
</ul>
<h3 id="匹配常用字符"><a href="#匹配常用字符" class="headerlink" title="匹配常用字符"></a>匹配常用字符</h3><p>用<code>\w</code>可以匹配一个<strong>字母、数字或下划线</strong>，w的意思是word</p>
<h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><p>用<code>\s</code>可以匹配一个空格字符，注意空格字符<strong>不但包括空格，还包括tab字符</strong>（在Java中用<code>\t</code>表示）</p>
<h3 id="匹配非数字"><a href="#匹配非数字" class="headerlink" title="匹配非数字"></a>匹配非数字</h3><p><code>\D</code>则匹配一个非数字</p>
<p>类似的，<code>\W</code>可以匹配<code>\w</code>不能匹配的字符，<code>\S</code>可以匹配<code>\s</code>不能匹配的字符，这几个正好是反着来的</p>
<h3 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h3><p>修饰符*可以匹配任意个字符，包括0个字符</p>
<p>我们用<code>A\d*</code>可以匹配：</p>
<ul>
<li><code>A</code>：因为<code>\d*</code>可以匹配0个数字；</li>
<li><code>A0</code>：因为<code>\d*</code>可以匹配1个数字<code>0</code>；</li>
<li><code>A380</code>：因为<code>\d*</code>可以匹配多个数字<code>380</code></li>
</ul>
<p>修饰符<code>+</code>可以匹配至少一个字符</p>
<p>修饰符<code>?</code>可以匹配0个或一个字符</p>
<p><u><strong>修饰符<code>&#123;n&#125;</code>可以精确指定n个字符</strong></u></p>
<ul>
<li>如果我们想指定匹配n~m个字符怎么办？用修饰符<code>&#123;n,m&#125;</code>就可以</li>
<li>如果<strong>没有上限</strong>，那么修饰符<code>&#123;n,&#125;</code>就可以匹配至少n个字符</li>
</ul>
<h3 id="单个字符匹配规则"><a href="#单个字符匹配规则" class="headerlink" title="单个字符匹配规则"></a>单个字符匹配规则</h3><table>
<thead>
<tr>
<th>正则表达式</th>
<th>规则</th>
<th>可以匹配</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>指定字符</td>
<td>A</td>
</tr>
<tr>
<td>\u845c</td>
<td>指定Unicode字符</td>
<td>和</td>
</tr>
<tr>
<td>.</td>
<td>任意字符</td>
<td>a , b , &amp; , 0</td>
</tr>
<tr>
<td>\d</td>
<td>数字0~9</td>
<td>0~9</td>
</tr>
<tr>
<td>\w</td>
<td>大小写字母，数字和下划线</td>
<td>a<del>z , A</del>Z , 0~9</td>
</tr>
<tr>
<td>\s</td>
<td>空格、Tab键</td>
<td>空格、Tab</td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
<td>a , A , &amp; , _ , …</td>
</tr>
<tr>
<td>\W</td>
<td>非\w</td>
<td>&amp; , @ , 中 , …</td>
</tr>
<tr>
<td>\S</td>
<td>非\s</td>
<td>a , A , &amp; , _ , …</td>
</tr>
</tbody></table>
<h3 id="多个字符的匹配规则"><a href="#多个字符的匹配规则" class="headerlink" title="多个字符的匹配规则"></a>多个字符的匹配规则</h3><table>
<thead>
<tr>
<th>正则表达式</th>
<th>规则</th>
<th>可以匹配</th>
</tr>
</thead>
<tbody><tr>
<td>A*</td>
<td>任意个数字符</td>
<td>空，A ，AA , …</td>
</tr>
<tr>
<td>A+</td>
<td>至少一个字符</td>
<td>A ，AA , …</td>
</tr>
<tr>
<td>A?</td>
<td>0个或1个字符</td>
<td>空 ， A</td>
</tr>
<tr>
<td>\d</td>
<td>数字0~9</td>
<td>0~9</td>
</tr>
<tr>
<td>A{3}</td>
<td>指定个数字符</td>
<td>AAA</td>
</tr>
<tr>
<td>A{2,}</td>
<td>至少n个字符</td>
<td>AA , AAA , …</td>
</tr>
<tr>
<td>A{0,3}</td>
<td>最多n个字符</td>
<td>空 ， A ，AA , AAA</td>
</tr>
</tbody></table>
<h2 id="3-复杂匹配规则"><a href="#3-复杂匹配规则" class="headerlink" title="3.复杂匹配规则"></a>3.复杂匹配规则</h2><h3 id="匹配开头和结尾"><a href="#匹配开头和结尾" class="headerlink" title="匹配开头和结尾"></a>匹配开头和结尾</h3><p>用正则表达式进行多行匹配时，我们用<code>^</code>表示开头，<code>$</code>表示结尾。例如，<code>^A\d&#123;3&#125;$</code>，可以匹配<code>&quot;A001&quot;</code>、<code>&quot;A380&quot;</code>。</p>
<h3 id="匹配指定范围"><a href="#匹配指定范围" class="headerlink" title="匹配指定范围"></a>匹配指定范围</h3><p>使用<code>[...]</code>可以匹配<strong>范围内</strong>的字符，例如，<code>[123456789]</code>可以匹配<code>1</code>~&#96;9<code>，这样就可以写出上述电话号码的规则：</code>[1-9]\d{6,7}&#96;</p>
<p>要匹配大小写不限的十六进制数，比如<code>1A2b3c</code>，我们可以这样写：<code>[0-9a-fA-F]</code>，它表示一共可以匹配以下任意范围的字符：</p>
<ul>
<li><code>0-9</code>：字符<code>0</code>~&#96;9&#96;；</li>
<li><code>a-f</code>：字符<code>a</code>~&#96;f&#96;；</li>
<li><code>A-F</code>：字符<code>A</code>~&#96;F&#96;。</li>
</ul>
<p><code>[...]</code>还有一种排除法，即<strong>不包含指定范围的字符</strong>。假设我们要匹配任意字符，但不包括数字，可以写<code>[^1-9]&#123;3&#125;</code></p>
<h3 id="或规则匹配"><a href="#或规则匹配" class="headerlink" title="或规则匹配"></a>或规则匹配</h3><p>用<code>|</code>连接的两个正则规则是<strong>或规则</strong>，例如，<code>AB|CD</code>表示可以匹配<code>AB</code>或<code>CD</code></p>
<h3 id="使用括号"><a href="#使用括号" class="headerlink" title="使用括号"></a>使用括号</h3><p>现在我们想要匹配字符串<code>learn java</code>、<code>learn php</code>和<code>learn go</code>，可以<strong>把公共部分提出来</strong>，然后用<code>(...)</code>把子规则括起来表示成<code>learn\\s(java|php|go)</code></p>
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>规则</th>
<th>可以匹配</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>开头</td>
<td>字符串开头</td>
</tr>
<tr>
<td>$</td>
<td>结尾</td>
<td>字符串结尾</td>
</tr>
<tr>
<td>[ABC]</td>
<td>[…]内任意字符</td>
<td>A,B,C</td>
</tr>
<tr>
<td>[A-F0-9xy]</td>
<td>指定范围的字符</td>
<td>A，…，F，0，…9,x,y</td>
</tr>
<tr>
<td>[^A-F]</td>
<td>指定范围外的任意字符</td>
<td>非A-F</td>
</tr>
<tr>
<td>&#96;&#96;&#96;AB</td>
<td>CD</td>
<td>EF&#96;&#96;&#96;</td>
</tr>
</tbody></table>
<h2 id="4-分组匹配"><a href="#4-分组匹配" class="headerlink" title="4.分组匹配"></a>4.分组匹配</h2><p><code>(...)</code>还有一个重要作用，就是分组匹配</p>
<p>提取匹配的子串正确的方法是<u><strong>用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为<code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code></strong></u></p>
<p><strong>按括号提取子串</strong>必须引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">g1</span> <span class="operator">=</span> m.group(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">g2</span> <span class="operator">=</span> m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>传入0会得到整个字串</li>
</ul>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><p>但是反复使用<code>String.matches()</code>对同一个正则表达式进行<strong>多次匹配效率较低</strong>，因为每次都会创建出一样的<code>Pattern</code>对象</p>
<p>完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        psattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matche(); <span class="comment">// false</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">whole</span> <span class="operator">=</span> matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">area</span> <span class="operator">=</span> matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-非贪婪匹配"><a href="#5-非贪婪匹配" class="headerlink" title="5.非贪婪匹配"></a>5.非贪婪匹配</h2><p>正则表达式默认使用<strong>贪婪匹配</strong>：任何一个规则，它总是尽可能多地向后匹配，因此，<code>\d+</code>总是会把后面的<code>0</code>包含进来</p>
<ul>
<li>(\d+)(0*) 在规则<code>\d+</code>后面加个<code>?</code>即可表示<strong>非贪婪匹配</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d+?)(0*)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-搜索与替换"><a href="#6-搜索与替换" class="headerlink" title="6.搜索与替换"></a>6.搜索与替换</h2><h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p><code>String.split()</code>方法传入的正是正则表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a b c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a b  c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a, b ;; c&quot;</span>.split(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们获取到<code>Matcher</code>对象后，不需要调用<code>matches()</code>方法（因为匹配整个串肯定返回false），而是反复调用<code>find()</code>方法，在整个串中搜索能匹配上<code>\\wo\\w</code>规则的子串，并打印出来。这种方式比<code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是<code>o</code>，前后两个必须是字符<code>[A-Za-z0-9_]</code></p>
<h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><p>使用正则表达式替换字符串可以直接调用<code>String.replaceAll()</code>，它的<strong>第一个参数是正则表达式，第二个参数是待替换的字符串</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个<code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用<code>replaceAll()</code>的时候，我们传入的第二个参数可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s([a-z]&#123;4&#125;)\\s&quot;</span>, <span class="string">&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的运行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它实际上把任何4字符单词的前后用<code>&lt;b&gt;xxxx&lt;/b&gt;</code>括起来。实现替换的关键就在于<code>&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</code>，它用匹配的分组子串<code>([a-z]&#123;4&#125;)</code>替换了<code>$1</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/2023/10/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自：<strong>《计算机网络》(谢希仁)</strong></p>
<h2 id="1-互联网概述"><a href="#1-互联网概述" class="headerlink" title="1. 互联网概述"></a>1. 互联网概述</h2><p>互联网（internet）把许多网络通过路由器连接在一起</p>
<ul>
<li>与网络相连的计算机常称为<strong>主机</strong></li>
</ul>
<p>区分：Internet是专有名词<strong>互联网&#x2F;因特网</strong>！！！</p>
<ul>
<li>Internet使用<strong>TCP&#x2F;IP协议</strong>作为通信规则，前身是美国的ARPANET</li>
</ul>
<p><strong>ISP</strong>(Internet Service Provider): <strong>互联网服务提供商</strong></p>
<p>ISP分为不同层次：主干ISP、地区ISP、本地ISP</p>
<ul>
<li>根据<u>提供服务的覆盖面积大小和所拥有的IP地址数目不同</u>划分</li>
</ul>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.Rq78nZwCRn0oeQ43K_DAjQHaEa?w=254&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="基于isp的三层结构的因特网 的图像结果"></p>
<p><strong>WWW</strong>(World Wide Web)：<strong>万维网</strong></p>
<p><strong>ISOC</strong>(Internet Society):<strong>互联网协会</strong></p>
<ul>
<li>对互联网进行全面管理以及在世界范围内促进其发展和使用</li>
</ul>
<p><strong>IAB</strong>(Internet Architecture Board):<strong>互联网体系结构委员会</strong></p>
<ul>
<li>负责管理互联网有关协议的开发</li>
<li>包括<strong>互联网工程部IETF</strong>(Internet Research Task Force)和<strong>互联网研究部IRTF</strong>(Internet Research Steering Group)</li>
</ul>
<p>指定互联网标准要经过以下三个阶段：</p>
<ol>
<li><strong>互联网草案</strong>(Internet Draft)——六个月有效期</li>
<li><strong>建议标准</strong>(Proposed Standard)——成为RFC文档</li>
<li><strong>互联网标准</strong>(Internet Standard)——正式标准</li>
</ol>
<h2 id="2-互联网组成"><a href="#2-互联网组成" class="headerlink" title="2. 互联网组成"></a>2. 互联网组成</h2><p>从工作方式看，可以分为两部分：</p>
<ol>
<li><strong>边缘部分</strong>——由所有连接在互联网上的主机组成</li>
<li><strong>核心部分</strong>——由大量网络和连接这些网络的路由器组成</li>
</ol>
<h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><p><strong>客户-服务器方式</strong>(client-to-server)<br>客户是服务请求方，服务器是服务提供方</p>
<ul>
<li>客户程序必须知道服务器程序的地址，反之不用</li>
<li>服务器程序可<strong>同时处理</strong>多个请求<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.m3zNhmq24fpND7vwFDaRVAHaDM?w=272&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="边缘部分核心部分 的图像结果"></li>
</ul>
<p><strong>对等连接方式</strong>(peer to peer,简写<strong>P2P</strong>)<br>每一台主机既是客户又是服务器<br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.5_g9pTBgCTWXdzDV3M5w1AHaEV?w=262&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="边缘部分核心部分 的图像结果"></p>
<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p>起特殊作用的是<strong>路由器(router)</strong>,这是一种专用计算机(但不叫主机)</p>
<ul>
<li>实现<strong>分组交换(packet switching)<strong>的关键构件，其任务是</strong>转发收到的分组</strong></li>
</ul>
<p><strong>电路交换</strong>三个步骤：<strong>建立连接</strong>-&gt;<strong>通话</strong>-&gt;<strong>释放连接</strong></p>
<ul>
<li>在通话的全部时间内，通话的两个用户始终占有端到端的通信资源</li>
<li>传输效率低</li>
</ul>
<p><strong>分组交换</strong>采用<strong>存储转发</strong>技术</p>
<p>要发送的整块数据成为一个<strong>报文</strong>(message),发送报文前先把较长的报文分成一个个较小的等长的数据段，每个数据段前面加上一些由<u>必要的控制信息</u>组成的<strong>首部</strong>(head)，就构成了一个<strong>分组</strong>(packet)</p>
<p>分组是在互联网中传送的数据单元</p>
<p>主机和路由器的区别：</p>
<ol>
<li><strong>主机是为用户进行信息处理的</strong></li>
<li><strong>路由器是用来转发分组的，即进行分组交换</strong></li>
</ol>
<p>分组转发的有点：</p>
<ol>
<li><strong>高效</strong> ：在分组传输的过程中动态分配传输带宽</li>
<li><strong>灵活</strong>：为每一个分组独立地选择最合适的转发路由</li>
<li><strong>迅速</strong> ：可以不先建立连接就能向其他主机发送分组</li>
<li><strong>可靠</strong>：保证可靠性的网络协议；分布式多路由的分组交换网，使网络由很好的生存性</li>
</ol>
<p>分组在各路由器存储转发时需要排队，会产生一定的<strong>时延</strong></p>
<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.BiRp_iE3q9jwba1ujRgQ-AHaES?w=299&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="电路交换 报文交换 分组交换 的图像结果"></p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>按照网络的作用范围进行分类：</p>
<ol>
<li><strong>广域网 WAN</strong>(Wide Area Network)</li>
</ol>
<ul>
<li>互联网的核心部分</li>
</ul>
<ol start="2">
<li><del><strong>域域网 MAN</strong>(Metropolitan Area Network)</del></li>
<li><strong>局域网 LAN</strong>(Local Area Network)</li>
<li><strong>个人区域网 PAN</strong>(Personal Area Network)</li>
</ol>
<ul>
<li>也常成为<strong>无线个人区域网 WPAN</strong>(Wreless PAN)</li>
</ul>
<p>按照网络的使用者来进行分类</p>
<ol>
<li><strong>公用网</strong>(public network)</li>
<li><strong>专有网</strong>(private network)</li>
</ol>
<h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ol>
<li><strong>速率</strong>：<br>网络技术中的速率指的是<strong>数据的传送速率</strong>，也成为<strong>数据率</strong>或者<strong>比特率</strong>，单位是bit&#x2F;s</li>
</ol>
<ul>
<li>k &#x3D; $10^3$  M &#x3D; $10^6$ G &#x3D; $10^9$</li>
</ul>
<ol start="2">
<li><p><strong>带宽</strong>：<br>指某个<strong>信号具有的频带宽度&#x2F;频带范围</strong>，单位是Hz<br>但是在计算机网络中，带宽常常指<strong>单位时间内网络中的某信道所能通过的“最高数据率”</strong>，这里带宽的单位是bit&#x2F;s</p>
</li>
<li><p><strong>吞吐量</strong><br>表示在单位时间内通过某个网络( 信道、接口 )的实际数据量</p>
</li>
<li><p><strong>时延</strong>(delay)<br>指数据从网络&#x2F;链路 的一端传送到另一端所需的时间</p>
<ul>
<li><strong>发送时延</strong>是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间，<del>因此也叫做<strong>传输时延</strong></del> <ul>
<li>发送时延 &#x3D; 数据帧长度(bit) &#x2F; 发送速率(bit&#x2F;s)</li>
</ul>
</li>
<li><strong>传播时延</strong>是电磁波在信道中传播一定距离需要花费的时间<ul>
<li>传播时延 &#x3D; 信道长度(m) &#x2F; 电磁波在信道上的传播速率(m&#x2F;s)</li>
</ul>
</li>
</ul>
<p> 发送时延在机器内部的发送器中， 与<strong>传输信道长度无关</strong><br> 而传播时延在机器外部的传输信道媒体上</p>
<ul>
<li><del><strong>处理时延</strong></del> </li>
<li><strong><del>排队时延</del></strong></li>
</ul>
</li>
</ol>
<p><strong>对于高速网络链路，我们提高的仅是数据的发送速率而不是比特在链路上的传播速率</strong></p>
<ul>
<li><strong>提高数据的发送速率只是减少了数据的发送时延</strong></li>
</ul>
<ol start="5">
<li><p><strong>时延宽带积</strong><br>时延宽带积 &#x3D; 传播时延 x 带宽</p>
<ul>
<li>因此又称为<strong>以比特位单位的链路长度</strong></li>
</ul>
</li>
<li><p><strong>往返时间RTT</strong><br>RTT不包括发送时间</p>
</li>
<li><p><strong>利用率</strong><br>分为信道利用率和网络利用率 </p>
<ul>
<li><strong>信道利用率</strong>指出某信道有百分之几的时间是被利用的</li>
<li><strong>网络利用率</strong>是全网络的信道利用率的加权平均值</li>
</ul>
<p> 信道和网络利用率过高会产生非常大的时延</p>
</li>
</ol>
<h2 id="2-计算机网络体系"><a href="#2-计算机网络体系" class="headerlink" title="2. 计算机网络体系"></a>2. 计算机网络体系</h2><p>美国的IBM公司宣布了<strong>系统网络体系结构SNA</strong>(System Network Architecture),这个著名的网络标准就是按照分层的办法制定的</p>
<p>国际标准化组织ISO提出了<strong>开放系统互连基本参考模型(OSI&#x2F;RM)</strong>(Open System Interconnection Reference Model),简称<strong>OSI</strong></p>
<p>得到最广泛应用的是<strong>TCP&#x2F;IP</strong>,其为事实上的国际标准</p>
<p><strong>网络协议(network protocol)</strong>: 为进行网络中的数据交换而建立的规则、标准或约定，由三个要素组成：</p>
<ol>
<li><strong>语法</strong>：数据与控制信息的结构或格式</li>
<li><strong>语义</strong>：需要发出何种控制信息，完成何种动作以及做出何种响应</li>
<li><strong>同步</strong>：事件实现顺序的详细说明</li>
</ol>
<p>分层的好处：</p>
<ol>
<li><strong>各层之间是独立的</strong></li>
<li><strong>灵活性好</strong></li>
<li><strong>结构上可分隔开</strong></li>
<li><strong>易于实现和维护</strong></li>
<li><strong>能促进标准化工作</strong></li>
</ol>
<p>通常来说各层要完成的功能由以下一些：</p>
<ul>
<li><strong>差错控制</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>分段和重装</strong> </li>
<li><strong>复用和分用</strong></li>
<li><strong>连接的建立和释放</strong></li>
</ul>
<p><strong>计算机网络的各层以及协议的几何就是网络的体系结构</strong>（<u>计算机网络的体系结构就是这个计算机网络以及构件所应完成的功能的精确定义</u>）</p>
<p>TCP&#x2F;IP是一个四层的体系结构，包含应用层、运输层、网际层、网络接口层</p>
<p>学习的时候常常采用一种五层协议体系结构，包含<strong>应用层、运输层、网络层、数据链路层、物理层</strong></p>
<ol>
<li><p><strong>应用层</strong>(application)：<br> <u>通过应用进程间的交互来完成特定的网络应用</u>，应用层协议定义的是<u>应用进程间通信和交互的规则</u>，我们把应用层交互的数据单元成为<strong>报文</strong></p>
</li>
<li><p><strong>运输层</strong>(transport)：<br> . <u>向两台主机进程之间的通信提供通用的数据传输服务</u>，运输层有分用服用功能</p>
<ul>
<li><strong>传输控制协议TCP</strong>: 提供<u>面向连接的、可靠的</u>数据传输服务，其数据传输单位是<strong>报文段</strong>(segment)</li>
<li><strong>用户数据报协议UDP</strong>: 提供<u>无连接的、尽最大努力的数据传输服务(不保证数据传输的可靠性)</u>，其数据传输单位是<strong>用户数据报</strong></li>
</ul>
</li>
<li><p><strong>网络层</strong>(network)：<br> <u>为分组交换网上的不同主机提供通信服务</u>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成<strong>分组</strong>或<strong>包</strong>进行传送。由于网络层使用IP协议，因此分组也可叫做<strong>IP数据报</strong>，简称<strong>数据报</strong>(不同于UDP)</p>
<ul>
<li>无论哪一层传送的数据单元，都可笼统地用<strong>分组</strong>来表示</li>
</ul>
</li>
<li><p><strong>数据链路层</strong>(data link)：<br> <u>将网络层交下来地IP数据报组装成<strong>帧</strong>(frame),在两个相邻结点间的链路上传送帧，还能检测所受到的帧有没有差错(<strong>可靠协议</strong>)</p>
<ul>
<li>每一帧都包括数据和必要的<strong>控制信息</strong></li>
</ul>
</li>
<li><p><strong>物理层</strong>(physical)：<br> 数据的单位是<strong>比特</strong>。物理层要考虑用多大的电压代表“1”和“0”，以及接收方如何识别出发送方所发送的比特，还要确定连接电缆的插头应当由多少根引脚以及各引脚应如何连接</p>
<ul>
<li><strong>传递信息所利用的一些物理媒介，比如双绞线、同轴电缆、光纤等并不在物理层协议之内</strong></li>
</ul>
</li>
</ol>
<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.Hjk_e100vUeMrSztC6TN-QHaDp?w=327&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="数据在各层之间的传递过程 的图像结果"></p>
<p>OSI模型把对等层次之间传送的数据单位成为该层地<strong>协议数据单元PDU</strong>(Protocol Data Unit)</p>
<p><strong>协议是控制两个对等实体(或多个实体)进行通信的规则的集合</strong></p>
<p>在协议的控制下，<u>两个对等实体间的通信使得本层能够向上一层提供服务</u>，要实现本层协议，还需要使用下面一层所提供的服务</p>
<p>OSI把层与层之间交换的数据的单位成为<strong>服务数据单元SDU</strong>(Service Data Unit),它可以和PDU不一样</p>
<p><strong>TCP&#x2F;IP体系结构</strong>：<br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.3ecsYu-PTfzEhcQnDPbWjgAAAA?w=197&h=132&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="TCP/IP体系结构 的图像结果"></p>
<p>TCP&#x2F;IP协议可以<strong>为各式各样的应用提供服务</strong>，同时TCP&#x2F;IP协议也<strong>允许IP协议在各式各样的网络构成的互联网上运行</strong><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.TrBY3slvUtRUihT72Q8krwAAAA?w=245&h=180&c=7&r=0&o=5&dpr=1.5&pid=1.7" alt="TCP/IP体系结构 的图像结果"></p>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象基础</title>
    <url>/2023/10/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li>方法</li>
<li>构造方法</li>
<li>方法重载</li>
<li>继承</li>
<li>多态</li>
<li>抽象类</li>
<li>接口</li>
<li>静态字段和静态方法</li>
<li>包</li>
<li>作用域</li>
<li>内部类</li>
<li>classpath和jar</li>
<li>class版本</li>
<li>模块</li>
</ol>
<h2 id="1-方法"><a href="#1-方法" class="headerlink" title="1.方法"></a>1.方法</h2><p>一个<code>class</code>可以包含多个<code>field</code>。但是，直接把<code>field</code>用<code>public</code>暴露给外部可能会<strong>破坏封装性</strong>。为了避免外部代码直接去访问<code>field</code>，我们可以用<code>private</code>修饰<code>field</code>，拒绝外部访问</p>
<ul>
<li>所以我们需要使用方法（<code>method</code>）来让外部代码可以<strong>间接修改</strong></li>
</ul>
<p>所以，一个类通过定义方法，就可以给外部代码暴露一些操作的<strong>接口</strong>，同时，内部自己保证逻辑一致性。</p>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 方法返回类型 方法名(方法参数列表) &#123;</span><br><span class="line">    若干方法语句;</span><br><span class="line">    <span class="keyword">return</span> 方法返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>private方法<br>定义<code>private</code>方法的理由是<strong>内部方法</strong>是可以调用<code>private</code>方法的</p>
</li>
<li><p>this变量<br>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向<strong>当前实例</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 前面的this不可少，少了就变成局部变量name了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><ul>
<li><strong>基本类型</strong>参数的传递，是调用方值的复制。双方各自的后续修改，互不影响</li>
<li><strong>引用类型</strong>参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</li>
</ul>
<h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h2><p>创建实例的时候，实际上是通过构造方法来<strong>初始化</strong>实例的。</p>
<ul>
<li>构造方法的名称就是类名</li>
<li>和普通方法相比，构造方法<strong>没有返回值</strong>（也没有<code>void</code>），调用构造方法，必须用<code>new</code>操作符。</li>
<li>任何<code>class</code><strong>都有</strong>构造方法</li>
<li>如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来</li>
</ul>
<p>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用<u>默认值</u>，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code></p>
<ul>
<li>也可以对字段直接进行初始化</li>
</ul>
<p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p>
<p> <strong>1.先初始化字段<br> 2.执行构造方法的代码进行初始化</strong></p>
<p>一个构造方法可以调用其他构造方法，这样做的目的是<strong>便于代码复用</strong>。调用其他构造方法的语法是<code>this(…)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unnamed&quot;</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-方法重载-Overload"><a href="#3-方法重载-Overload" class="headerlink" title="3.方法重载(Overload)"></a>3.方法重载(Overload)</h2><p>方法名相同，但各自的参数不同</p>
<p>方法重载的<strong>返回值类型</strong>通常都是相同的。</p>
<p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h2><p>子类自动获得了父类的所有字段，严禁定义与父类<strong>重名</strong>的字段！</p>
<p>任何类，除了<code>Object</code>，都会继承自某个类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│  Object   │</span><br><span class="line">└───────────┘</span><br><span class="line">      ▲</span><br><span class="line">      │</span><br><span class="line">┌───────────┐</span><br><span class="line">│  Person   │</span><br><span class="line">└───────────┘</span><br><span class="line">      ▲</span><br><span class="line">      │</span><br><span class="line">┌───────────┐</span><br><span class="line">│  Student  │</span><br><span class="line">└───────────┘</span><br></pre></td></tr></table></figure>

<p>Java只允许一个class继承自一个类，因此，一个类<strong>有且仅有一个</strong>父类。只有<code>Object</code>特殊，它没有父类。</p>
<p>继承有个特点，就是子类<strong>无法访问</strong>父类的<code>private</code>字段或者<code>private</code>方法。</p>
<ul>
<li>为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问</li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">super</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p>
<p>在Java中，任何<code>class</code>的构造方法，**第一行语句必须是调用父类的<u>构造方法</u>**。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code></p>
<ul>
<li><strong>这里的<code>super()</code>是无参数构造方法</strong></li>
<li>如果父类没有默认的构造方法，子类就必须<strong>显式调用<code>super()</code>并给出参数</strong>以便让编译器定位到父类的一个合适的构造方法</li>
</ul>
<p>子类<strong>不会继承</strong>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的</p>
<h3 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h3><p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Rect, Circle, Triangle &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。</li>
</ul>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>如果<code>Student</code>是从<code>Person</code>继承下来的，那，一个引用类型为<code>Person</code>的变量，<strong>能</strong>指向<code>Student</code>类型的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br></pre></td></tr></table></figure>
<ul>
<li>这种把一个子类类型安全地变为父类类型的赋值，被称为<strong>向上转型</strong>（upcasting）</li>
</ul>
<p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> p; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure>

<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>如果把一个父类类型强制转型为子类类型，就是<strong>向下转型</strong>（downcasting）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1; <span class="comment">// ok，因为p1确实指向Student实例</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) p2; <span class="comment">// runtime error! ClassCastException!子类功能比父类多，多的功能无法凭空变出来。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</li>
</ul>
<p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以<strong>先判断</strong>一个实例究竟是不是某种类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>具有has关系不应该使用继承，而是<strong>使用组合</strong>，即<code>Student</code>可以持有一个<code>Book</code>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，继承是is关系，组合是has关系。</p>
<h2 id="5-多态"><a href="#5-多态" class="headerlink" title="5.多态"></a>5.多态</h2><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为<strong>重写</strong>（Override）</p>
<p><strong><u>Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</u></strong></p>
<p>&#x3D;&#x3D;<u>Java的实例方法调用是基于运行时的<strong>实际类型</strong>的动态调用，而非变量的声明类型。</u>&#x3D;&#x3D;</p>
<ul>
<li>多态是指，针对某个类型的方法调用，其真正执行的方法<strong>取决于运行时期实际类型的方法</strong></li>
<li>多态的特性就是，<strong>运行期</strong>才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。</li>
</ul>
<h3 id="重写Object方法"><a href="#重写Object方法" class="headerlink" title="重写Object方法"></a>重写Object方法</h3><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>
<ul>
<li><code>toString()</code>：把instance输出为<code>String</code>；</li>
<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>
<li><code>hashCode()</code>：计算一个instance的哈希值。<br>在有必要的情况下，我们可以重写这些方法</li>
</ul>
<h3 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h3><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code></p>
<ul>
<li>如果一个类不希望任何其他类继承自它，那么可以把这个<strong>类本身</strong>标记为<code>final</code></li>
</ul>
<p>可以在构造方法中初始化final字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改</li>
</ul>
<h2 id="6-抽象类"><a href="#6-抽象类" class="headerlink" title="6.抽象类"></a>6.抽象类</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是<strong>让子类去重写它</strong>，那么，可以把父类的方法声明为抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化</li>
<li>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它</li>
</ul>
<p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<p>抽象类可以<strong>强迫</strong>子类实现其定义的抽象方法，否则编译会报错</p>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不关心Person变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure>
<p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同样不关心新的子类是如何实现run()方法的：</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">e.run();</span><br></pre></td></tr></table></figure>
<p>这种尽量引用高层类型，<strong>避免引用实际子类型</strong>的方式，称之为面向抽象编程</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li><p>上层代码只<strong>定义规范</strong>（例如：<code>abstract class Person</code>）；</p>
</li>
<li><p>不需要子类就可以实现业务逻辑（正常编译）；</p>
</li>
<li><p>具体的业务逻辑由不同的子类实现，<strong>调用者并不关心</strong>。</p>
</li>
</ul>
<h2 id="7-接口"><a href="#7-接口" class="headerlink" title="7.接口"></a>7.接口</h2><p>如果一个抽象类没有字段，所有方法<strong>全部都是抽象方法</strong>，就可以把该抽象类改写为接口：<code>interface</code></p>
<p>在Java中，使用<code>interface</code>可以声明一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓<code>interface</code>，就是比抽象类还要抽象的<strong>纯抽象</strong>接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符<strong>不需要写出来</strong>（写不写效果都一样）</p>
<p>一个类可以实现<strong>多个</strong><code>interface</code>（区别于继承）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意区分术语：</p>
<ul>
<li>Java的接口特指<code>interface</code>的定义，表示<strong>一个接口类型和一组方法签名</strong></li>
<li>编程接口<strong>泛指接口规范</strong>，如方法签名，数据格式，网络协议等。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody><tr>
<td>继承</td>
<td>只能extends一个class</td>
<td>可以implements多个interface</td>
</tr>
<tr>
<td>字段</td>
<td>可以定义实例字段</td>
<td>不能定义实例字段</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以定义抽象方法</td>
<td>可以定义抽象方法</td>
</tr>
<tr>
<td>非抽象方法</td>
<td>可以定义非抽象方法</td>
<td>可以定义default方法</td>
</tr>
</tbody></table>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个<code>interface</code>可以继承自另一个<code>interface</code><br><code>interface</code>继承自<code>interface</code>要使用<code>extends</code>，它相当于<strong>扩展</strong>了接口的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>一般来说，<strong>公共逻辑</strong>适合放在<code>abstract class</code>中，<strong>具体逻辑</strong>放到各个子类，而接口层次代表<strong>抽象程度</strong></p>
<p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为<strong>接口比抽象类更抽象</strong></p>
<h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现类可以不必覆写<code>default</code>方法。<br><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改<strong>全部子类</strong>。</p>
<ul>
<li>当类实现接口时，类要实现接口中<strong>所有方法</strong></li>
</ul>
<p>如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法<strong>无法访问</strong>字段，而抽象类的普通方法可以访问实例字段。</p>
<h2 id="8-静态字段和静态方法"><a href="#8-静态字段和静态方法" class="headerlink" title="8.静态字段和静态方法"></a>8.静态字段和静态方法</h2><h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p>实例字段在每个实例中都有自己的一个<strong>独立“空间”</strong><br>静态字段只有一个<strong>共享“空间”</strong>，所有实例都会共享该字段。</p>
<p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：<strong>所有</strong>实例的静态字段都被修改了，原因是<u><strong>静态字段并不属于实例</strong></u></p>
<ul>
<li>实例可以访问静态字段，但它们指向的都是一个<strong>共享</strong>的静态字段</li>
<li>在java程序中，实例对象并<strong>没有静态字段</strong><ul>
<li>实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象</li>
<li>推荐用<strong>类名</strong>来访问静态字段</li>
<li>可以把静态字段理解为描述<code>class</code><strong>本身</strong>的字段  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person.number = 99;</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>调用静态方法则不需要实例变量，通过<strong>类名</strong>就可以调用</p>
<p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它<strong>只能访问静态字段</strong></p>
<ul>
<li>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告</li>
</ul>
<p>静态方法经常用于<strong>工具类</strong>。例如：</p>
<ul>
<li><p>Arrays.sort()</p>
</li>
<li><p>Math.random()</p>
</li>
</ul>
<p>静态方法也经常用于<strong>辅助方法</strong></p>
<ul>
<li>注意到Java程序的入口<code>main()</code>也是静态方法。</li>
</ul>
<h3 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h3><p><code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型</p>
<ul>
<li>实际上，因为<code>interface</code>的字段<strong>只能</strong>是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-包"><a href="#9-包" class="headerlink" title="9.包"></a>9.包</h2><p>Java定义了一种名字空间，称之为<strong>包</strong>：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，<u><strong>真正的完整类名是<code>包名.类名</code></strong></u></p>
<ul>
<li>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</li>
<li>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</li>
<li>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</li>
<li>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</li>
</ul>
<p>在Java虚拟机执行的时候，<u><strong>JVM只看完整类名</strong></u>，因此，只要包名不同，类就不同</p>
<ul>
<li><u><strong>包可以是多层结构</strong></u>，用<code>.</code>隔开。例如：<code>java.util</code></li>
</ul>
<p>要特别注意：<u><strong>包没有父子关系</strong></u>。java.util和java.util.zip是不同的包，&#x3D;&#x3D;两者没有任何继承关系&#x3D;&#x3D;</p>
<p>没有定义包名的<code>class</code>，它使用的是<strong>默认包</strong>，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<ul>
<li>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包</li>
</ul>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>位于同一个包的类，可以访问<strong>包作用域</strong>的字段和方法</p>
<ul>
<li><strong>不用</strong><code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域</li>
</ul>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法</p>
<ol>
<li><del>直接写出完整类名</del>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名(<strong>最常用</strong>)<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的<u><strong>所有</strong><code>class</code></u>都导入进来（&#x3D;&#x3D;但不包括子包的<code>class</code>&#x3D;&#x3D;）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包</li>
</ul>
<p>3.<del><code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法</del></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于调用System.out.println(…)</span></span><br><span class="line">        out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Java编译器最终编译出的<code>.class</code>文件只使用<strong>完整类名</strong></p>
<p>在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li><p>如果是完整类名，就直接根据<strong>完整类名</strong>查找这个<code>class</code>；</p>
</li>
<li><p>如果是简单类名，按下面的顺序依次查找：</p>
<ul>
<li><p>查找当前<code>package</code>是否存在这个<code>class</code>；</p>
</li>
<li><p>查找<code>import</code>的包是否包含这个<code>class</code>；</p>
</li>
<li><p>查找<code>java.lang</code>包是否包含这个<code>class</code>。</p>
</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则<strong>编译报错</strong></p>
<p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p>
<ul>
<li><p>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</p>
</li>
<li><p>默认自动<code>import java.lang.*</code>。</p>
</li>
</ul>
<p>注意：<u><strong>自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入</strong></u></p>
<p>如果有两个<code>class</code>名称相同,只能<code>import</code>其中一个，另一个必须写完整类名</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免名字冲突，我们需要确定<strong>唯一</strong>的包名</p>
<ul>
<li>推荐的做法是<u><strong>使用倒置的域名来确保唯一性</strong></u></li>
<li>子包就可以根据功能自行命名</li>
</ul>
<p>要注意不要和<code>java.lang</code>包的类重名<br>要注意也不要和<strong>JDK常用类</strong>重名</p>
<h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><p>假设我们创建了如下的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">work</span><br><span class="line">├── bin</span><br><span class="line">└── src</span><br><span class="line">    └── com</span><br><span class="line">        └── itranswarp</span><br><span class="line">            ├── sample</span><br><span class="line">            │   └── Main.java</span><br><span class="line">            └── world</span><br><span class="line">                └── Person.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，<code>bin</code>目录用于存放编译后的<code>class</code>文件，<code>src</code>目录按<strong>包结构</strong>存放Java源码</p>
<p>首先，<strong>确保</strong>当前目录是<code>work</code>目录，即存放<code>src</code>和<code>bin</code>的父目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">bin src</span><br></pre></td></tr></table></figure>
<p>然后，<strong>编译</strong><code>src</code>目录下的所有Java文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javac -d ./bin src/**/*.java</span><br></pre></td></tr></table></figure>
<ul>
<li>命令行<code>-d</code><strong>指定</strong>输出的<code>class</code>文件存放<code>bin</code>目录，后面的参数<code>src/**/*.java</code>表示<code>src</code>目录下的所有<code>.java</code>文件，包括<strong>任意深度</strong>的子目录。</li>
<li>注意：Windows不支持<code>**</code>这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有<code>.java</code>文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\work&gt; javac -d bin src\com\itranswarp\sample\Main.java src\com\itranswarp\world\Persion.java</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果编译无误，则<code>javac</code>命令<strong>没有任何输出</strong>。可以在<code>bin</code>目录下看到如下<code>class</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin</span><br><span class="line">└── com</span><br><span class="line">    └── itranswarp</span><br><span class="line">        ├── sample</span><br><span class="line">        │   └── Main.class</span><br><span class="line">        └── world</span><br><span class="line">            └── Person.class</span><br></pre></td></tr></table></figure>
<p>现在，我们就可以直接运行<code>class</code>文件了。根据当前目录的位置<strong>确定classpath</strong>，例如，当前目录仍为<code>work</code>，则classpath为<code>bin</code>或者<code>./bin</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ java -cp bin com.itranswarp.sample.Main </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<h2 id="10-作用域"><a href="#10-作用域" class="headerlink" title="10.作用域"></a>10.作用域</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他<strong>任何类</strong>访问</p>
<p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的<strong>权限</strong></p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>定义为<code>private</code>的<code>field</code>、<code>method</code><strong>无法</strong>被其他类访问、</p>
<ul>
<li><code>private</code>访问权限被限定在<code>class</code>的<strong>内部</strong>，而且<u><strong>与方法声明顺序无关</strong></u></li>
<li>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，<strong>嵌套类</strong>拥有访问<code>private</code>的权限<ul>
<li>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类</li>
</ul>
</li>
</ul>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p><code>protected</code>作用于<strong>继承关系</strong>。</p>
<p>定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</p>
<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法</p>
<ul>
<li>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code></li>
<li>注意，包名必须<strong>完全一致</strong>，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包</li>
</ul>
<h2 id="11-内部类"><a href="#11-内部类" class="headerlink" title="11.内部类"></a>11.内部类</h2><h3 id="Inner-class"><a href="#Inner-class" class="headerlink" title="Inner class"></a>Inner class</h3><p>有一种类，它被定义在另一个类的内部，所以称为内部类（Nested Class）。</p>
<ul>
<li>Inner Class的实例<strong>不能单独存在</strong>，必须依附于一个Outer Class的实例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h3><p>还有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在<strong>方法内部</strong>，通过匿名类（Anonymous Class）来定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">asyncHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的<strong>匿名类</strong>，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法</li>
<li>如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code></li>
</ul>
<p>除了接口外，匿名类也完全可以继承自普通类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#125;; <span class="comment">// 匿名类!</span></span><br><span class="line">        HashMap&lt;String, String&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(map3.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h3><p>一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">StaticNested</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNested</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个<strong>完全独立</strong>的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。</p>
<h2 id="12-classpath和jar"><a href="#12-classpath和jar" class="headerlink" title="12.classpath和jar"></a>12.classpath和jar</h2><h3 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h3><p><code>classpath</code>是JVM用到的一个<strong>环境变量</strong>，它用来<u><strong>指示JVM如何搜索<code>class</code></strong></u></p>
<ul>
<li><strong>编译后</strong>的<code>.class</code>文件才是真正可以被JVM执行的字节码</li>
</ul>
<p><code>classpath</code>就是<strong>一组目录的集合</strong>，它设置的搜索路径与操作系统相关</p>
<ul>
<li>在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\work\project1\bin;C:\shared;&quot;D:\My 	Documents\project1\bin&quot;</span><br></pre></td></tr></table></figure></li>
<li>在Linux系统上，用<code>:</code>分隔  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</span><br></pre></td></tr></table></figure></li>
</ul>
<p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会<strong>依次查找</strong>：</p>
<ul>
<li><p>&lt;当前目录&gt;\abc\xyz\Hello.class</p>
</li>
<li><p>C:\work\project1\bin\abc\xyz\Hello.class</p>
</li>
<li><p>C:\shared\abc\xyz\Hello.class<br>注意到<code>.</code>代表<strong>当前目录</strong></p>
</li>
</ul>
<p>如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>
<p><code>classpath</code>的设定方法有两种：</p>
<ul>
<li><p><del>在系统环境变量中设置<code>classpath</code>环境变量</del></p>
<ul>
<li><u><strong>污染整个系统环境</strong></u></li>
</ul>
</li>
<li><p>在<strong>启动JVM时</strong>设置<code>classpath</code>变量</p>
<ul>
<li>给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure></li>
<li>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即<strong>当前目录</strong>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java abc.xyz.Hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是<u><strong>当前工程的<code>bin</code>目录和引入的jar包</strong></u></p>
<ul>
<li>&#x3D;&#x3D;不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！&#x3D;&#x3D;</li>
</ul>
<p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p>
<p>如果指定的<code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错</p>
<h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>jar包可以把<code>package</code>组织的目录层级，以及各个目录下的<strong>所有文件</strong>（包括<code>.class</code>文件和其他文件）都打成一个jar文件</p>
<p>jar包里的第一层目录，不能是<code>bin</code></p>
<ul>
<li>Windows中应该是这样<br><a href="https://www.liaoxuefeng.com/files/attachments/1261393208671488/l">https://www.liaoxuefeng.com/files/attachments/1261393208671488/l</a></li>
<li>有问题的长这样<br><a href="https://www.liaoxuefeng.com/files/attachments/1261391527906784/l">https://www.liaoxuefeng.com/files/attachments/1261391527906784/l</a></li>
</ul>
<p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息</p>
<p>JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure>
<h2 id="13-class版本"><a href="#13-class版本" class="headerlink" title="13.class版本"></a>13.class版本</h2><p>我们通常说的Java 8，Java 11，Java 17，是指<strong>JDK</strong>的版本，也就是<strong>JVM</strong>的版本，更确切地说，就是<code>java.exe</code>这个程序的版本</p>
<ul>
<li>而每个版本的JVM，它能执行的<strong>class文件版本</strong>也不同</li>
<li>只要看到<code>UnsupportedClassVersionError</code>就表示当前要加载的class文件版本超过了JVM的能力，必须使用<strong>更高版本</strong>的JVM才能运行</li>
</ul>
<p>指定编译输出有两种方式，一种是在<code>javac</code>命令行中用参数<code>--release</code>设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javac --release 11 Main.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>参数<code>--release 11</code>表示源码兼容Java 11，编译的class输出版本为<strong>Java 11兼容</strong>，即class版本55。</li>
</ul>
<p>第二种方式是用参数<code>--source</code>指定<strong>源码版本</strong>，用参数<code>--target</code>指定<strong>输出class版本</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javac --source 9 --target 11 Main.java</span><br></pre></td></tr></table></figure>
<ul>
<li>上述命令如果使用Java 17的JDK编译，它会把源码视为<strong>Java 9兼容版本</strong>，并输出class为Java 11兼容版本</li>
</ul>
<p>注意<code>--release</code>参数和<code>--source --target</code>参数只能<strong>二选一</strong>，不能同时设置<br>指定版本如果<strong>低于</strong>当前的JDK版本，会有一些潜在的问题</p>
<p>&#x3D;&#x3D;如果使用–release 11则会在编译时检查该方法是否在Java 11中存在&#x3D;&#x3D;</p>
<p>如果运行时的JVM版本是Java 11，则编译时也最好使用Java 11，而不是用高版本的JDK编译输出低版本的class</p>
<p>如果使用<code>javac</code>编译时不指定任何版本参数，那么相当于使用<code>--release 当前版本</code>编译，即源码版本和输出版本均为<strong>当前版本</strong></p>
<p>在开发阶段，多个版本的JDK可以同时安装，当前使用的JDK版本可由<code>JAVA_HOME</code>环境变量切换</p>
<p>在编译的时候，如果用<code>--source</code>或<code>--release</code>指定源码版本，则使用指定的源码版本检查语法</p>
<h2 id="14-模块"><a href="#14-模块" class="headerlink" title="14.模块"></a>14.模块</h2><p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的<strong>Java标准库</strong>，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M</p>
<p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;注意：JVM自带的标准库<u><strong>rt.jar</strong></u>不要写到classpath中，写了反而会干扰JVM的正常运行&#x3D;&#x3D;</p>
<ul>
<li>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code>ClassNotFoundException</code></li>
<li>jar只是用于存放class的容器，它并<strong>不关心</strong>class之间的依赖</li>
</ul>
<p>如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种<strong>自带依赖关系</strong>的<u>class容器</u>就是模块</p>
<p>从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>
<ul>
<li>java.base.jmod</li>
<li>java.compiler.jmod</li>
<li>java.datatransfer.jmod</li>
<li>java.desktop.jmod</li>
<li>…</li>
</ul>
<p>这些<code>.jmod</code>文件每一个都是一个模块，<u><strong>模块名就是文件名</strong></u></p>
<ul>
<li>模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code></li>
<li>模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了</li>
</ul>
<p>所有的模块<strong>都</strong>直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“<strong>根模块</strong>”，好比所有的类都是从<code>Object</code>直接或间接继承而来</p>
<p><strong>模块支持多版本</strong>，即在同一个模块中可以为不同的JVM提供不同的版本</p>
<h3 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h3><p>以<code>oop-module</code>工程为例，它的目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">├── build.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure>
<p>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是<strong>模块的描述文件</strong></p>
<ul>
<li><p>在这个模块中，它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">	<span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。<u><strong>花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名</strong></u>。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块</p>
</li>
<li><p>当我们使用模块声明了依赖关系后，才能使用引入的模块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.XMLConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Greeting</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line">		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是<strong>声明依赖关系</strong></p>
</li>
</ul>
<h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><p>1.我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure>
<p>如果编译成功，现在项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">│   ├── com</span><br><span class="line">│   │   └── itranswarp</span><br><span class="line">│   │       └── sample</span><br><span class="line">│   │           ├── Greeting.class</span><br><span class="line">│   │           └── Main.class</span><br><span class="line">│   └── module-info.class</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure>

<p>2.我们需要把bin目录下的<strong>所有class文件先打包成jar</strong>，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure>
<p>3.继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure>
<p>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块</p>
<h3 id="运行模块"><a href="#运行模块" class="headerlink" title="运行模块"></a>运行模块</h3><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要<strong>指定模块名</strong>。试试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java --module-path hello.jmod --module hello.world</span><br></pre></td></tr></table></figure>
<p>结果是一个错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error occurred during initialization of boot layer</span><br><span class="line">java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</span><br></pre></td></tr></table></figure>
<p>原因是<u><strong><code>.jmod</code>不能被放入<code>--module-path</code>中</strong></u>。换成<code>.jar</code>就没问题了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java --module-path hello.jar --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure>
<p>那我们辛辛苦苦创建的<code>hello.jmod</code>有什么用？答案是我们可以用它来<strong>打包JRE</strong></p>
<h3 id="打包JRE"><a href="#打包JRE" class="headerlink" title="打包JRE"></a>打包JRE</h3><p>JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉</p>
<ul>
<li>并不是说把系统安装的JRE给删掉部分模块，而是<strong>复制</strong>一份JRE，但<u><strong>只带上用到的模块</strong></u><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure></li>
<li>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录</li>
</ul>
<p>在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE</p>
<p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是<u><strong>b模块明确地导出了可以访问的包</strong></u></p>
<p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml &#123;</span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>只有它声明的导出的包，外部代码才被允许访问</strong>。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> java.base;</span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，<strong>模块进一步隔离了代码的访问权限</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
</search>
