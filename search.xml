<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA程序基础</title>
    <url>/2023/10/25/JAVA%E2%80%94%E2%80%94JAVA%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h2 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h2><ul>
<li>byte是<strong>最小</strong>储存单位 == <strong>8</strong>位二进制数（8个bit） 0-255</li>
<li>一个字节是1byte，1024byte = 1K，1024K = 1M，1024M = 1G，1024G = 1T</li>
<li>int<strong>4</strong>字节，long<strong>8</strong>字节，float<strong>4</strong>字节，double<strong>8</strong>字节，char<strong>2</strong>字节</li>
<li>float类型要加上<strong>f</strong>，例如==float f1 = 3.14f==   </li>
<li>理论上布尔类型只要1bit，但是JVM内部会把boolean表示为<strong>4</strong>字节整数</li>
<li>char用<strong>单</strong>引号且只有一个字符，String用<strong>双</strong>引号（String是引用类型）</li>
<li>引用类型类似于C的指针，指向某个对象在内存的<strong>位置</strong></li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>修饰的变量会变为常量，常量初始化后不可赋值</p>
<h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><p>省略变量类型，例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br></pre></td></tr></table></figure><br>可以变为<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure></p>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><ul>
<li>整数除法对于除数为0的情况运行会报错，<strong>编译不报错</strong></li>
<li>对<code>byte</code>和<code>short</code>类型进行移位时会先转化为<code>int</code></li>
<li>如果运算的类型不同，自动转化为<strong>大类型</strong></li>
<li>超出范围的强制转型会得到错误的结果</li>
</ul>
<h2 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h2><ul>
<li>浮点数在计算机无法精确表示，因此常常出错，只能保存个近似值（<strong>二进制</strong>）</li>
<li>浮点数在除数为0时不会报错，但会返回三个特殊值：NaN表示<strong>Not a Number</strong>、Infinity表示<strong>无穷大</strong>、-Infinity表示<strong>负无穷大</strong></li>
</ul>
<h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul>
<li>java在内存中使用Unicode表示字符，所以一个英文字符和一个中文字符都占<strong>两个</strong>字节</li>
<li>将<code>char</code>类型赋给<code>int</code>类型即可显示Unicode编码</li>
<li>还可以使用转义字符<code>\u</code>+Unicode编码表示一个字符<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意是十六进制:</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0041&#x27;</span>; <span class="comment">// &#x27;A&#x27;，因为十六进制0041 = 十进制65</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="string">&#x27;\u4e2d&#x27;</span>; <span class="comment">// &#x27;中&#x27;，因为十六进制4e2d = 十进制20013</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3></li>
<li>从java13开始可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                   SELECT * FROM</span></span><br><span class="line"><span class="string">                     users</span></span><br><span class="line"><span class="string">                   WHERE id &gt; 100</span></span><br><span class="line"><span class="string">                   ORDER BY name DESC</span></span><br><span class="line"><span class="string">                   &quot;&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述多行字符串实际上是5行，在最后一个<code>DESC</code>后面还有一个<code>\n</code>。如果我们不想在字符串末尾加一个<code>\n</code>，就需要这么写：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">           SELECT * FROM</span></span><br><span class="line"><span class="string">             users</span></span><br><span class="line"><span class="string">           WHERE id &gt; 100</span></span><br><span class="line"><span class="string">           ORDER BY name DESC&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
还需要注意到，多行字符串前面共同的空格会被去掉,即总是以最短的行首空格为基准。<h4 id="不可变特性"><a href="#不可变特性" class="headerlink" title="不可变特性"></a>不可变特性</h4></li>
<li>只会改变<strong>变量的指向</strong>，不会改变字符串</li>
<li>String[] 类型的对象是<strong>可变的</strong>，也就是说，可以修改数组中的元素值。</li>
<li>空字符串不等于<code>null</code></li>
</ul>
<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p>数组一旦创建后，大小就不可改变</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><div class="table-container">
<table>
<thead>
<tr>
<th>占位符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%x</td>
<td>十六进制整数</td>
</tr>
<tr>
<td>%e</td>
<td>科学计数法</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>连续两个%%表示一个%字符本身</li>
</ul>
<p>有了<code>Scanner</code>对象后，用<code>scanner.nextLine()</code>读取字符串，用<code>scanner.nextInt()</code>读取输入的整数</p>
<ul>
<li><code>Scanner</code>会<strong>自动转换</strong>数据类型，因此不必手动转换</li>
</ul>
<h3 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h3><p><code>==</code>表示“引用是否相等”，或者说，是否<strong>指向</strong>同一个对象</p>
<p>要判断引用类型的<strong>变量内容</strong>是否相等，必须使用<code>equals()</code>方法</p>
<ul>
<li>执行语句<code>s1.equals(s2)</code>时，如果变量<code>s1</code>为<code>null</code>，会报<code>NullPointerException</code></li>
<li>要避免<code>NullPointerException</code>错误，可以利用短路运算符<code>&amp;&amp;</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s1 != <span class="literal">null</span> &amp;&amp; s1.equals(<span class="string">&quot;hello&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="switch判断"><a href="#switch判断" class="headerlink" title="switch判断"></a>switch判断</h3><p>如果没有匹配到任何<code>case</code>，那么<code>switch</code>语句不会执行任何语句。这时，可以给<code>switch</code>语句加一个<code>default</code>，当没有匹配到任何<code>case</code>时，执行<code>default</code></p>
<p><code>case</code>语句并<strong>没有花括号<code>&#123;&#125;</code></strong>，而且，<code>case</code>语句具有“_穿透性_”，漏写<code>break</code>将导致意想不到的结果</p>
<ul>
<li>后续语句将<strong>全部执行</strong>，直到遇到<code>break</code>语句</li>
</ul>
<p>如果有几个<code>case</code>语句执行的是同一组语句块，可以这么写<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">       System.out.println(<span class="string">&quot;Selected 2, 3&quot;</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>case</code>匹配字符串时，是比较<strong>内容相等</strong></p>
<h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p><code>Arrays.toString()</code>用于快速打印数组内容</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的<code>Arrays.sort()</code>就可以排序</p>
<p>必须注意，对数组排序实际上<strong>修改了数组本身</strong></p>
<p>如果对一个字符串数组进行排序，原来的3个字符串在内存中均没有任何变化，但是<code>ns</code>数组的每个元素<strong>指向变化了</strong></p>
<ul>
<li>排序前，这个数组在内存中表示如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────────────────┐           │</span><br><span class="line">               │   │                      ▼           ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────▶│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                 ▲</span><br><span class="line">           └─────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>Arrays.sort(ns);</code>排序后，这个数组在内存中表示如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────┐                       │</span><br><span class="line">               │   │          ▼                       ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────▶│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                              ▲</span><br><span class="line">           └──────────────────────────────┘</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="冒泡排序-从小到大"><a href="#冒泡排序-从小到大" class="headerlink" title="冒泡排序(从小到大)"></a>冒泡排序(从小到大)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ns.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ns.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ns[j] &gt; ns[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换ns[j]和ns[j+1]:</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ns[j];</span><br><span class="line">                    ns[j] = ns[j+<span class="number">1</span>];</span><br><span class="line">                    ns[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组的每个数组元素的长度<strong>并不要求相同</strong>，例如，可以这么定义<code>ns</code>数组：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] ns = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">    &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>要打印一个二维数组，可以使用两层嵌套的for循环,或者使用Java标准库的<code>Arrays.deepToString()</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA核心类</title>
    <url>/2023/10/25/JAVA%E2%80%94%E2%80%94JAVA%E6%A0%B8%E5%BF%83%E7%B1%BB/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure><br>Java提供了<code>&quot;...&quot;</code>这种<strong>字符串字面量</strong>表示方法</p>
<p>Java字符串的一个重要特点就是<strong>字符串不可变</strong>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的</p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想<u><strong>比较字符串的内容是否相同</strong></u>。必须使用<code>equals()</code>方法而不能用<code>==</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的</p>
<ul>
<li>所以，这种<code>==</code>比较返回<code>true</code>纯属巧合</li>
</ul>
<p>换一种写法，<code>==</code>比较就会失败<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><u><strong>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法</strong></u></p>
<p><code>String</code>类还提供了多种方法来搜索子串、提取子串。常用的方法有：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否包含子串:</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意到<code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>实现的一个接口</li>
</ul>
<p><strong>搜索</strong>子串的更多的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>提取</strong>子串的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="去除首尾空白字符"><a href="#去除首尾空白字符" class="headerlink" title="去除首尾空白字符"></a>去除首尾空白字符</h3><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;  \tHello\r\n &quot;</span>.trim(); <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>==注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串==</li>
</ul>
<p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u3000Hello\u3000&quot;</span>.strip(); <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripLeading(); <span class="comment">// &quot;Hello &quot;</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.stripTrailing(); <span class="comment">// &quot; Hello&quot;</span></span><br></pre></td></tr></table></figure></p>
<p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure></p>
<h3 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h3><p>1.根据字符或字符串替换<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure><br>2.通过正则表达式替换<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>上面的代码通过正则表达式，把匹配的子串统一替换为<code>&quot;,&quot;</code></li>
</ul>
<h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果你不确定用啥占位符，那就始终用<code>%s</code>，因为<u><strong><code>%s</code>可以显示任何数据类型</strong></u></p>
<p>要查看完整的格式化语法，请参考<a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Formatter.html#syntax">JDK文档</a></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>要把任意基本类型或引用类型转换为字符串，可以使用<strong>静态方法</strong><code>valueOf()</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="literal">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure><br>把字符串转换为<code>int</code>类型<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure><br>把字符串转换为<code>boolean</code>类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><br>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的<strong>系统变量</strong>转换为<code>Integer</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br></pre></td></tr></table></figure></p>
<h3 id="转换为char"><a href="#转换为char" class="headerlink" title="转换为char[]"></a>转换为char[]</h3><p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure></p>
<p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会<strong>复制</strong>一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为<u><strong>这是两个不同的数组</strong></u></li>
<li>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用</li>
</ul>
<p>例如，下面的代码设计了一个<code>Score</code>类保存一组学生的成绩<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] scores = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">88</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">66</span> &#125;;</span><br><span class="line">        <span class="type">Score</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(scores);</span><br><span class="line">        s.printScores();</span><br><span class="line">        scores[<span class="number">2</span>] = <span class="number">99</span>;</span><br><span class="line">        s.printScores();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] scores;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(<span class="type">int</span>[] scores)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scores = scores;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printScores</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Arrays.toString(scores));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于<code>Score</code>内部直接引用了外部传入的<code>int[]</code>数组，这会造成外部代码对<code>int[]</code>数组的修改，影响到<code>Score</code>类的字段</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用<strong>一个字节</strong>，编码范围从<code>0</code>到<code>127</code>，最高位始终为<code>0</code>，称为<code>ASCII</code>编码。例如，字符<code>&#39;A&#39;</code>的编码是<code>0x41</code>，字符<code>&#39;1&#39;</code>的编码是<code>0x31</code></p>
<p><code>GB2312</code>标准使用<strong>两个字节</strong>表示一个汉字，其中第一个字节的最高位始终为<code>1</code>，以便和<code>ASCII</code>编码区分开。例如，汉字<code>&#39;中&#39;</code>的<code>GB2312</code>编码是<code>0xd6d0</code>。</p>
<p>为了<strong>统一全球所有语言的编码</strong>，全球统一码联盟发布了<code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p>
<p><code>Unicode</code>编码需要<strong>两个或者更多字节</strong>表示</p>
<p>英文字符<code>&#39;A&#39;</code>的<code>ASCII</code>编码和<code>Unicode</code>编码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         ┌────┐</span><br><span class="line">ASCII:   │ 41 │</span><br><span class="line">         └────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 00 │ 41 │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>英文字符的<code>Unicode</code>编码就是简单地在前面添加一个<code>00</code>字节</strong></li>
</ul>
<p>中文字符<code>&#39;中&#39;</code>的<code>GB2312</code>编码和<code>Unicode</code>编码：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         ┌────┬────┐</span><br><span class="line">GB2312:  │ d6 │ d0 │</span><br><span class="line">         └────┴────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 4e │ 2d │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure></p>
<p>因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，<u>包含大量英文的文本会浪费空间</u>，所以，出现了<code>UTF-8</code>编码，它是一种<strong>变长编码</strong>，用来把固定长度的<code>Unicode</code>编码变成<strong>1～4字节</strong>的变长编码。通过<code>UTF-8</code>编码，英文字符<code>&#39;A&#39;</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>&#39;中&#39;</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code></p>
<p><code>UTF-8</code>编码的另一个好处是<strong>容错能力强</strong>。如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码</p>
<p><code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="type">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure><br>==注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组==</p>
<p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] b = ...</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示</strong></p>
<h3 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h3><p>早期JDK版本的<code>String</code>总是以<code>char[]</code>存储<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>较新的JDK版本的<code>String</code>则以<code>byte[]</code>存储<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder; <span class="comment">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则，每两个<code>byte</code>存储一个字符，这样做的目的是为了<strong>节省内存</strong>，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符</li>
</ul>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个<strong>可变对象</strong>，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，<strong>不会创建新的临时对象</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><br><code>StringBuilder</code>还可以进行链式操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>进行链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法</li>
</ul>
<p>==注意：对于普通的字符串<code>+</code>操作，并<strong>不需要</strong>我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作==</p>
<h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><p>很多时候，我们拼接的字符串像这样：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sb.append(name).append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意去掉最后的&quot;, &quot;:</span></span><br><span class="line">        sb.delete(sb.length() - <span class="number">2</span>, sb.length());</span><br><span class="line">        sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用<strong>分隔符</strong>拼接数组的需求很常见，所以Java标准库还提供了一个<code>StringJoiner</code>来干这个事：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用<code>StringJoiner</code>的结果少了前面的<code>&quot;Hello &quot;</code>和结尾的<code>&quot;!&quot;</code>！遇到这种情况，需要给<code>StringJoiner</code>指定“开头”和“结尾”<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="type">var</span> <span class="variable">sj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="String-join"><a href="#String-join" class="headerlink" title="String,join()"></a>String,join()</h3><p><code>String</code>还提供了一个<strong>静态方法</strong><code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span> String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure></p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的<strong>包装类</strong>（Wrapper Class）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>定义好了<code>Integer</code>类，我们就可以把<code>int</code>和<code>Integer</code>互相转换<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">99</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> n2.intValue();</span><br></pre></td></tr></table></figure></p>
<p>因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型<br>|基本类型|对应的引用类型<br>|—-|—-|<br>|boolean|java.lang.Boolean|<br>|byte|java.lang.Byte|<br>|short|java.lang.Short|<br>|int|java.lang.Integer|<br>|long|java.lang.Long|<br>|float|java.lang.Float|<br>|double|java.lang.Double|<br>|char|java.lang.Character|</p>
<p>我们可以直接使用，不需要自己定义<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n3</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Auto-Boxing"><a href="#Auto-Boxing" class="headerlink" title="Auto Boxing"></a>Auto Boxing</h3><p>Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure><br>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为<strong>自动装箱</strong>（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为<strong>自动拆箱</strong>（Auto Unboxing）</p>
<ul>
<li>==注意：自动装箱和自动拆箱只发生在<strong>编译阶段</strong>，目的是为了少写代码==</li>
<li><strong>自动拆箱</strong>执行时可能会报<code>NullPointerException</code></li>
<li>装箱和拆箱会影响<strong>代码的执行效率</strong>，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的</li>
</ul>
<h3 id="不变类"><a href="#不变类" class="headerlink" title="不变类"></a>不变类</h3><p>所有的包装类型都是不变类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因此，一旦创建了<code>Integer</code>对象，该对象就是<strong>不变</strong>的</p>
<p>对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是<strong>引用类型</strong>，必须使用<code>equals()</code>比较</p>
<p>我们自己创建<code>Integer</code>的时候，以下两种方法：</p>
<ul>
<li><del>方法1：<code>Integer n = new Integer(100);</code></del></li>
<li>方法2：<code>Integer n = Integer.valueOf(100);</code></li>
</ul>
<p>我们把能创建“新”对象的静态方法称为<strong>静态工厂方法</strong></p>
<ul>
<li><code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存</li>
</ul>
<p>==创建新对象时，优先选用静态工厂方法而不是new操作符==</p>
<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的<strong>静态方法</strong><code>parseInt()</code>可以把字符串解析成一个整数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure><br><code>Integer</code>还可以把整数格式化为指定进制的字符串：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// &quot;100&quot;,表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// &quot;2s&quot;,表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// &quot;1100100&quot;,表示为2进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们经常使用的<code>System.out.println(n);</code>是依靠核心库自动把整数格式化为<strong>10进制</strong>输出并显示在屏幕上，使用<code>Integer.toHexString(n)</code>则通过核心库自动把整数格式化为<strong>16进制</strong></p>
<p>这里我们注意到程序设计的一个重要原则：<strong>数据的存储和显示要分离</strong></p>
<p>ava的包装类型还定义了一些有用的<strong>静态变量</strong></p>
<p>// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">t</span> <span class="operator">=</span> Boolean.TRUE;</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">f</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line"><span class="comment">// int可表示的最大/最小值:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MIN_VALUE; <span class="comment">// -2147483648</span></span><br><span class="line"><span class="comment">// long类型占用的bit和byte数量:</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sizeOfLong</span> <span class="operator">=</span> Long.SIZE; <span class="comment">// 64 (bits)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bytesOfLong</span> <span class="operator">=</span> Long.BYTES; <span class="comment">// 8 (bytes)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>最后，所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向上转型为Number:</span></span><br><span class="line"><span class="type">Number</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">999</span>);</span><br><span class="line"><span class="comment">// 获取byte, int, long, float, double:</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> num.byteValue();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.intValue();</span><br><span class="line"><span class="type">long</span> <span class="variable">ln</span> <span class="operator">=</span> num.longValue();</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> num.floatValue();</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> num.doubleValue();</span><br></pre></td></tr></table></figure></p>
<h3 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h3><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型</p>
<ul>
<li>无符号整型和有符号整型的转换在Java中就需要借助<strong>包装类型的静态方法</strong>完成<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        System.out.println(Byte.toUnsignedInt(x)); <span class="comment">// 255</span></span><br><span class="line">        System.out.println(Byte.toUnsignedInt(y)); <span class="comment">// 127</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
类似的，可以把一个<code>short</code>按unsigned转换为<code>int</code>，把一个<code>int</code>按unsigned转换为<code>long</code></li>
</ul>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>如果读写方法符合以下这种命名规范：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> Type <span class="title function_">getXyz</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setXyz</span><span class="params">(Type value)</span></span><br></pre></td></tr></table></figure><br>那么这种<code>class</code>被称为<code>JavaBean</code></p>
<p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 写方法:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChild</span><span class="params">(<span class="type">boolean</span> value)</span></span><br></pre></td></tr></table></figure></p>
<p>我们通常把一组对应的<u><strong>读方法（<code>getter</code>）和写方法（<code>setter</code>）</strong></u>称为<strong>属性</strong>（<code>property</code>）。例如，<code>name</code>属性：</p>
<ul>
<li>对应的读方法是<code>String getName()</code></li>
<li>对应的写方法是<code>setName(String)</code></li>
</ul>
<p>只有<code>getter</code>的属性称为<strong>只读属性</strong>（read-only）<br>只有<code>setter</code>的属性称为<strong>只写属性</strong>（write-only）</p>
<ul>
<li><u>只读属性很常见，只写属性不常见</u></li>
<li>属性只需要定义<code>getter</code>和<code>setter</code>方法，<strong>不一定需要对应的字段</strong></li>
</ul>
<p>例如，<code>child</code>只读属性定义如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.age; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; <span class="built_in">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isChild</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt;= <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出，<code>getter</code>和<code>setter</code>也是一种<strong>数据封装</strong>的方法</p>
<h3 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h3><p>JavaBean主要用来<strong>传递数据</strong>，即把一组数据组合成一个JavaBean便于传输<br>JavaBean可以方便地被<strong>IDE工具</strong>分析，生成读写属性的代码，主要用在图形界面的可视化设计中<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>点击右键，在弹出的菜单中选择<u><strong>“Source”，“Generate Getters and Setters”</strong></u>，在弹出的对话框中选中需要生成<code>getter</code>和<code>setter</code>方法的字段，点击确定即可由IDE自动完成所有方法代码</p>
<h3 id="枚举JavaBean属性"><a href="#枚举JavaBean属性" class="headerlink" title="枚举JavaBean属性"></a>枚举JavaBean属性</h3><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">BeanInfo</span> <span class="variable">info</span> <span class="operator">=</span> Introspector.getBeanInfo(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行上述代码，可以列出所有的属性，以及对应的读写方法</p>
<ul>
<li>==注意<code>class</code>属性是从<code>Object</code>继承的<code>getClass()</code>方法带来的==</li>
</ul>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>为了让编译器能<strong>自动检查</strong>某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>enum</code>常量本身带有<strong>类型信息</strong>，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (day == Weekday.SUN) &#123; <span class="comment">// Compile error: bad operand types for binary operator &#x27;==&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不可能引用到非枚举的值，因为无法通过编译</li>
<li><strong>不同类型</strong>的枚举不能互相比较或者赋值，因为类型不符<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Weekday</span> <span class="variable">x</span> <span class="operator">=</span> Weekday.SUN; <span class="comment">// ok!</span></span><br><span class="line"><span class="type">Weekday</span> <span class="variable">y</span> <span class="operator">=</span> Color.RED; <span class="comment">// Compile error: incompatible types</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="enum的比较"><a href="#enum的比较" class="headerlink" title="enum的比较"></a>enum的比较</h3><p>使用<code>enum</code>定义的枚举类是一种引用类型<br>引用类型比较，要始终使用<code>equals()</code>方法，<u><strong>但<code>enum</code>类型可以例外</strong></u></p>
<ul>
<li>这是因为<code>enum</code>类型的每个常量在JVM中只有一个<strong>唯一实例</strong>，所以可以直接用<code>==</code>比较<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.FRI) &#123; <span class="comment">// ok!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (day.equals(Weekday.SUN)) &#123; <span class="comment">// ok, but more code!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="enum类型"><a href="#enum类型" class="headerlink" title="enum类型"></a>enum类型</h3><p><code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且<strong>无法被继承</strong></li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例</li>
<li>定义的每个实例都是引用类型的<strong>唯一实例</strong></li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句</li>
</ul>
<p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例，因此，这些实例有一些方法：</p>
<ul>
<li><h3 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h3>  返回常量名，例如：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String s = Weekday.SUN.name(); // &quot;SUN&quot;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="ordinal"><a href="#ordinal" class="headerlink" title="ordinal()"></a>ordinal()</h3>  返回定义的常量的顺序，从0开始计数，例如：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int n = Weekday.MON.ordinal(); // 1</span><br></pre></td></tr></table></figure>
  改变枚举常量<strong>定义的顺序</strong>就会导致<code>ordinal()</code>返回值发生变化</li>
</ul>
<p>如果在代码中编写了类似<code>if(x.ordinal()==1)</code>这样的语句，就要保证<code>enum</code>的枚举顺序不能变。<strong>新增的常量必须放在最后</strong>。</p>
<p>实现enum和int之间的转化：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Weekday</span><span class="params">(<span class="type">int</span> dayValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<code>int</code>值</li>
</ul>
<p>==注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！==</p>
<p>==注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！==</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Weekday</span> <span class="variable">day</span> <span class="operator">=</span> Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="纪录类"><a href="#纪录类" class="headerlink" title="纪录类"></a>纪录类</h2><p>假设我们希望定义一个<code>Point</code>类，有<code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了保证不变类的比较，还需要正确覆写<code>equals()</code>和<code>hashCode()</code>方法，这样才能在集合类中正常使用。</p>
<h3 id="record"><a href="#record" class="headerlink" title="record"></a>record</h3><p>把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><br>把上述定义改写为class，相当于以下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>换句话说，使用<code>record</code>关键字，可以<strong>一行写出一个不变类</strong></p>
<ul>
<li>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意到方法<code>public Point &#123;...&#125;</code>被称为<strong>Compact Constructor</strong>，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Point</span> <span class="keyword">extends</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>作为<code>record</code>的<code>Point</code>仍然可以添加<strong>静态方法</strong>。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title function_">of</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Point</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>如果我们使用的整数范围<strong>超过了<code>long</code>型</strong>怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示<strong>任意大小</strong>的整数。<code>BigInteger</code>内部用一个<code>int[]</code><strong>数组</strong>来模拟一个非常大的整数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure></p>
<p>对<code>BigInteger</code>做运算的时候，只能使用<strong>实例方法</strong>，例如，加法运算：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">sum</span> <span class="operator">=</span> i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>BigInteger</code>不会有范围限制，但缺点是<strong>速度比较慢</strong></li>
</ul>
<p>也可以把<code>BigInteger</code>转换成<code>long</code>型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure><br>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code></p>
<p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是<strong>不可变类</strong>，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p>
<ul>
<li>转换为<code>byte</code>：<code>byteValue()</code></li>
<li>转换为<code>short</code>：<code>shortValue()</code></li>
<li>转换为<code>int</code>：<code>intValue()</code></li>
<li>转换为<code>long</code>：<code>longValue()</code></li>
<li>转换为<code>float</code>：<code>floatValue()</code></li>
<li>转换为<code>double</code>：<code>doubleValue()</code></li>
</ul>
<p>如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。</p>
<p>如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常</p>
<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个<strong>任意大小且精度完全准确</strong>的浮点数</p>
<p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></p>
<p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但<strong>去掉了末尾0</strong>的<code>BigDecimal</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d4</span> <span class="operator">=</span> d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0</li>
</ul>
<p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456789&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d4</span> <span class="operator">=</span> d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure><br>还可以对BigDecimal做除法的同时求余数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">n</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12.345&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.12&quot;</span>);</span><br><span class="line">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">        System.out.println(dr[<span class="number">0</span>]); <span class="comment">// 102</span></span><br><span class="line">        System.out.println(dr[<span class="number">1</span>]); <span class="comment">// 0.105</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是<strong>商和余数</strong>，其中商总是整数，余数不会大于除数</li>
</ul>
<h3 id="比较BigDecimal"><a href="#比较BigDecimal" class="headerlink" title="比较BigDecimal"></a>比较BigDecimal</h3><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等</p>
<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于</p>
<ul>
<li>==总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！==</li>
</ul>
<p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimal</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;BigDecimal&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>求绝对值：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br></pre></td></tr></table></figure><br>取最大或最小值：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure><br>计算xy次方：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br></pre></td></tr></table></figure><br>计算√x：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br></pre></td></tr></table></figure><br>计算ex次方：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.389...</span></span><br></pre></td></tr></table></figure><br>计算以e为底的对数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br></pre></td></tr></table></figure><br>计算以10为底的对数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><br>三角函数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.sin(<span class="number">3.14</span>); <span class="comment">// 0.00159...</span></span><br><span class="line">Math.cos(<span class="number">3.14</span>); <span class="comment">// -0.9999...</span></span><br><span class="line">Math.tan(<span class="number">3.14</span>); <span class="comment">// -0.0015...</span></span><br><span class="line">Math.asin(<span class="number">1.0</span>); <span class="comment">// 1.57079...</span></span><br><span class="line">Math.acos(<span class="number">1.0</span>); <span class="comment">// 0.0</span></span><br></pre></td></tr></table></figure><br>Math还提供了几个数学常量：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure><br>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现，计算如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间在[MIN, MAX)的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.random(); <span class="comment">// x的范围是[0,1)</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> x * (max - min) + min; <span class="comment">// y的范围是[10,50)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">long</span>) y; <span class="comment">// n的范围是[10,50)的整数</span></span><br><span class="line">        System.out.println(y);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java标准库还提供了一个<code>StrictMath</code>，它提供了和<code>Math</code>几乎一模一样的方法</p>
<ul>
<li><code>StrictMath</code>保证所有平台计算结果都是<strong>完全相同</strong>的，而<code>Math</code>会尽量针对平台优化计算速度</li>
</ul>
<h3 id="HexFormat"><a href="#HexFormat" class="headerlink" title="HexFormat"></a>HexFormat</h3><p>要将<code>byte[]</code>数组转换为十六进制字符串，可以用<code>formatHex()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HexFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line">        <span class="type">HexFormat</span> <span class="variable">hf</span> <span class="operator">=</span> HexFormat.of();</span><br><span class="line">        <span class="type">String</span> <span class="variable">hexData</span> <span class="operator">=</span> hf.formatHex(data); <span class="comment">// 48656c6c6f</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果要定制转换格式，则使用定制的<code>HexFormat</code>实例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分隔符为空格，添加前缀0x，大写字母:</span></span><br><span class="line"><span class="type">HexFormat</span> <span class="variable">hf</span> <span class="operator">=</span> HexFormat.ofDelimiter(<span class="string">&quot; &quot;</span>).withPrefix(<span class="string">&quot;0x&quot;</span>).withUpperCase();</span><br><span class="line">hf.formatHex(<span class="string">&quot;Hello&quot;</span>.getBytes())); <span class="comment">// 0x48 0x65 0x6C 0x6C 0x6F</span></span><br></pre></td></tr></table></figure><br>从十六进制字符串到<code>byte[]</code>数组转换，使用<code>parseHex()</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bs = HexFormat.of().parseHex(<span class="string">&quot;48656c6c6f&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的<br>要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果不给定种子，就使用<strong>系统当前时间戳</strong>作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同</li>
</ul>
<p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 51, 80, 41, 28, 55...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>前面我们使用的<code>Math.random()</code>实际上内部调用了<code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子</li>
</ul>
<h3 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h3><p>。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建<strong>安全的随机数</strong>的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><br><code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法</p>
<p>实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">sr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sr = SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            sr = <span class="keyword">new</span> <span class="title class_">SecureRandom</span>(); <span class="comment">// 获取普通的安全随机数生成器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">        sr.nextBytes(buffer); <span class="comment">// 用安全随机数填充buffer</span></span><br><span class="line">        System.out.println(Arrays.toString(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>SecureRandom</code>的安全性是通过<strong>操作系统</strong>提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”</p>
<p>==需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！==</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2023/10/25/JAVA%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h2 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h2><p>调用方如何获知调用失败的信息？有两种方法：</p>
<p>方法一：<strong>约定返回错误码</strong><br>例如，处理一个文件，如果返回<code>0</code>，表示成功，返回其他整数，表示约定的错误码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> processFile(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// file not found:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// no read permission:</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>因为使用<code>int</code>类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</li>
</ul>
<p>方法二：在语言层面上提供一个<strong>异常处理机制</strong></p>
<p>Java内置了一套异常处理机制，总是使用<strong>异常</strong>来表示错误</p>
<p>异常是一种<code>class</code>，因此它本身带有类型信息。<br><u><strong>异常可以在任何地方抛出，但只需要在上层捕获</strong></u>，这样就和方法调用分离了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为Java的异常是<code>class</code>，它的继承关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class="line">         └─────────────────────┘ └─────────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从继承关系可知：<code>Throwable</code>是异常体系的<strong>根</strong>，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示<strong>严重的错误</strong>，程序对此一般无能为力，例如：</p>
<ul>
<li><code>OutOfMemoryError</code>：<strong>内存耗尽</strong></li>
<li><code>NoClassDefFoundError</code>：<strong>无法加载某个Class</strong></li>
<li><code>StackOverflowError</code>：<strong>栈溢出</strong></li>
</ul>
<p>而<code>Exception</code>则是<strong>运行时的错误</strong>，<u>它可以被捕获并处理</u></p>
<p>某些异常是<strong>应用程序逻辑处理</strong>的一部分，应该捕获并处理。例如：</p>
<ul>
<li><code>NumberFormatException</code>：<strong>数值类型的格式错误</strong></li>
<li><code>FileNotFoundException</code>：<strong>未找到文件</strong></li>
<li><code>SocketException</code>：<strong>读取网络失败</strong></li>
</ul>
<p>还有一些异常是<strong>程序逻辑编写不对</strong>造成的，应该修复程序本身。例如：</p>
<ul>
<li><code>NullPointerException</code>：<strong>对某个<code>null</code>的对象调用方法或字段</strong></li>
<li><code>IndexOutOfBoundsException</code>：<strong>数组索引越界</strong></li>
</ul>
<p><code>Exception</code>又分为两大类：</p>
<ol>
<li><strong><code>RuntimeException</code>以及它的子类</strong></li>
<li><strong>非<code>RuntimeException</code></strong>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>
</ol>
<p>Java规定：</p>
<ul>
<li><p>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为<strong>Checked Exception</strong>。</p>
</li>
<li><p>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</p>
</li>
</ul>
<p>==注意：编译器对RuntimeException及其子类<strong>不做强制捕获要求</strong>，不是指应用程序本身不应该捕获并处理RuntimeException。是否需要捕获，具体问题具体分析==</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果我们不捕获<code>UnsupportedEncodingException</code>，会出现编译失败的问题</li>
<li>编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且<strong>准确地指出</strong>需要捕获的语句是<code>return s.getBytes(&quot;GBK&quot;);</code></li>
<li>意思是说，像<code>UnsupportedEncodingException</code>这样的Checked Exception，必须被捕获</li>
</ul>
<p>这是因为<code>String.getBytes(String)</code>方法定义是：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在方法定义的时候，使用<code>throws Xxx</code>表示该方法<strong>可能抛出</strong>的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错</li>
</ul>
<p>在<code>toGBK()</code>方法中，因为调用了<code>String.getBytes(String)</code>方法，就必须捕获<code>UnsupportedEncodingException</code></p>
<p>我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>，就可以让<code>toGBK()</code>方法通过编译器检查<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用<code>return s.getBytes(&quot;GBK&quot;);</code>的问题，而是<code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在<code>main()</code>方法中，调用<code>toGBK()</code>，没有捕获它声明的可能抛出的<code>UnsupportedEncodingException</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>可见，只要是方法声明的Checked Exception，<u><strong>不在调用层捕获，也必须在更高的调用层捕获</strong></u>。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会</p>
</li>
<li><p>如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">       System.out.println(Arrays.toString(bs));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">       <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">       <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代价就是一旦发生异常，程序会立刻退出</li>
</ul>
</li>
</ul>
<p>还有一些童鞋喜欢在<code>toGBK()</code>内部“消化”异常：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 什么也不干</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><br>这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要<strong>先把异常记录下来</strong>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈<h2 id="捕获异常-1"><a href="#捕获异常-1" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="多catch语句"><a href="#多catch语句" class="headerlink" title="多catch语句"></a>多catch语句</h3>VM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后_不再继续匹配<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>子类必须写在前面</strong></li>
</ul>
<h3 id="finally语句"><a href="#finally语句" class="headerlink" title="finally语句"></a>finally语句</h3><p><code>finally</code>语句块保证有无错误都会执行<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意<code>finally</code>有几个特点：</p>
<ol>
<li><code>finally</code>语句<strong>不是必须</strong>的，可写可不写；</li>
<li><code>finally</code>总是<strong>最后执行</strong>。</li>
</ol>
<p>可以没有<code>catch</code>，只使用<code>try ... finally</code>结构<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为方法声明了可能抛出的异常，所以可以不写<code>catch</code></p>
<h3 id="捕获多种异常"><a href="#捕获多种异常" class="headerlink" title="捕获多种异常"></a>捕获多种异常</h3><p>如果某些异常的处理逻辑相同，但是异常<u><strong>本身不存在继承关系</strong></u>，那么就得编写多条<code>catch</code>子句;</p>
<ul>
<li>若处理<code>IOException</code>和<code>NumberFormatException</code>的代码是相同的，我们可以把它两用<code>|</code>合并到一起   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><h3 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h3>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到<strong>上层</strong>调用方法，直到遇到某个<code>try ... catch</code>被捕获为止<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        Integer.parseInt(<span class="literal">null</span>); <span class="comment">// 会抛出NumberFormatException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过<code>printStackTrace()</code>可以打印出<strong>方法的调用栈</strong>，类似：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NumberFormatException: <span class="literal">null</span></span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">614</span>)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">770</span>)</span><br><span class="line">    at Main.process2(Main.java:<span class="number">16</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">12</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure><br><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在<code>java.lang.Integer.parseInt</code>方法中被抛出的，<strong>从下往上</strong>看，调用层次依次是：</p>
<ol>
<li><code>main()</code>调用<code>process1()</code>；</li>
<li><code>process1()</code>调用<code>process2()</code>；</li>
<li><code>process2()</code>调用<code>Integer.parseInt(String)</code>；</li>
<li><code>Integer.parseInt(String)</code>调用<code>Integer.parseInt(String, int)</code></li>
</ol>
<h3 id="抛出异常-1"><a href="#抛出异常-1" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>抛出异常分两步：</p>
<ol>
<li>创建某个<code>Exception</code>的实例；</li>
<li>用<code>throw</code>语句抛出。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型<strong>“转换”</strong>了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果在<code>main()</code>中捕获<code>IllegalArgumentException</code>，我们看看打印的异常栈：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>打印出的异常栈类似：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:<span class="number">15</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这说明新的异常<u><strong>丢失了原始异常信息</strong></u>，我们已经看不到原始异常<code>NullPointerException</code>的信息了</li>
</ul>
<p>为了能追踪到完整的异常栈，在构造异常的时候，<u><strong>把原始的<code>Exception</code>实例传进去</strong></u>，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行上述代码，打印出的异常栈类似：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:<span class="number">15</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:<span class="number">20</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意到<code>Caused by: Xxx</code>，说明捕获的<code>IllegalArgumentException</code>并不是造成问题的根源，根源在于<code>NullPointerException</code>，是在<code>Main.process2()</code>方法抛出的</li>
</ul>
<p>在代码中<strong>获取原始异常</strong>可以使用<code>Throwable.getCause()</code>方法。如果返回<code>null</code>，说明已经是“根异常”了</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>Java标准库定义的常用异常包括：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure></p>
<p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p>
<p>一个常见的做法是自定义一个<code>BaseException</code>作为<strong>“根异常”</strong>，然后，派生出各种业务类型的异常。</p>
<p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义的<code>BaseException</code>应该提供多个构造方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h2><p><code>NullPointerException</code>即<u><strong>空指针异常</strong></u>，俗称NPE</p>
<p>如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code>，这个异常通常是由<strong>JVM</strong>抛出的，例如<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h2><p>断言（Assertion）是一种调试程序的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p>
<ul>
<li><p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>  这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;= 0</code>，更加便于调试</p>
</li>
</ul>
<p>Java断言的特点是：<u><strong>断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段</strong></u></p>
<p>对于可恢复的程序错误，不应该使用断言。例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>应该抛出异常并在上层捕获：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JVM默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行</p>
<ul>
<li><p>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ java -ea Main.java</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class="line">at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
<li>还可以<strong>有选择地对特定的类</strong>启用断言，命令行参数是：<code>-ea:com.itranswarp.sample.Main</code>，表示只对<code>com.itranswarp.sample.Main</code>这个类启用断言</li>
<li>或者对<strong>特定地包启用断言</strong>，命令行参数是：<code>-ea:com.itranswarp.sample...</code>（注意结尾有3个<code>.</code>），表示对<code>com.itranswarp.sample</code>这个包启动断言<h2 id="使用JDK-Logging"><a href="#使用JDK-Logging" class="headerlink" title="使用JDK Logging"></a>使用JDK Logging</h2>日志就是Logging，它的目的是为了取代<code>System.out.println()</code></li>
</ul>
<p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p>
<ol>
<li>可以<strong>设置输出样式</strong>，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li>
<li>可以<strong>设置输出级别</strong>，禁止某些级别输出。例如，只输出错误日志；</li>
<li>可以<strong>被重定向到文件</strong>，这样可以在程序运行结束后查看日志；</li>
<li>可以<strong>按包名控制日志级别</strong>，只输出某些包打的日志；</li>
</ol>
<p>Java标准库内置了日志包<code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行上述代码，得到类似如下的输出：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar <span class="number">02</span>, <span class="number">2019</span> <span class="number">6</span>:<span class="number">32</span>:<span class="number">13</span> PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure></p>
<ul>
<li>再仔细观察发现，4条日志，只打印了3条，<code>logger.fine()</code>没有打印。这是因为，<strong>日志的输出可以设定级别</strong>。</li>
</ul>
<p>JDK的Logging定义了7个日志级别，从严重到普通：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST<br>因为<strong>默认级别是INFO</strong>，因此，INFO级别以下的日志，不会被打印出来</li>
</ul>
<p>使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出</p>
<p>使用Java标准库内置的Logging有以下局限：</p>
<ol>
<li>Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</li>
<li>配置不太方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</li>
</ol>
<p>因此，Java标准库内置的Logging使用并不是非常广泛</p>
<h2 id="使用Commons-Logging"><a href="#使用Commons-Logging" class="headerlink" title="使用Commons Logging"></a>使用Commons Logging</h2><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块</p>
<p>Commons Logging的特色是，<u><strong>它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统</strong></u>。默认情况下，Commons Logging<strong>自动搜索并使用Log4j</strong>（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging</p>
<p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p>
<p>第一步，<strong>通过<code>LogFactory</code>获取<code>Log</code>类的实例</strong>； 第二步，<strong>使用<code>Log</code>实例的方法打日志</strong><br>示例代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Commons Logging是一个第三方提供的库，所以，必须先把它<a href="https://commons.apache.org/proper/commons-logging/download_logging.cgi">下载</a>下来</li>
<li>下载后，解压，找到<code>commons-logging-1.2.jar</code>这个文件，再把Java源码<code>Main.java</code>放到一个目录下</li>
<li>然后用<code>javac</code>编译<code>Main.java</code>，编译的时候要指定<code>classpath</code>，不然编译器找不到我们引用的<code>org.apache.commons.logging</code>包 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac -cp commons-logging-1.2.jar Main.java</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Commons Logging定义了6个日志级别：</p>
<ul>
<li>FATAL</li>
<li>ERROR</li>
<li>WARNING</li>
<li>INFO</li>
<li>DEBUG</li>
<li>TRACE</li>
</ul>
<p>默认级别是<code>INFO</code></p>
<p>使用Commons Logging时，如果在静态方法中引用<code>Log</code>，通常<strong>直接定义一个静态类型变量</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，Commons Logging的日志方法，例如<code>info()</code>，除了标准的<code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Log4j"><a href="#使用Log4j" class="headerlink" title="使用Log4j"></a>使用Log4j</h2><p>真正的“日志实现”可以使用Log4j</p>
<p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">log.info(&quot;User signed in.&quot;);</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │</span><br><span class="line">     └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br></pre></td></tr></table></figure>
<p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到<strong>不同的目的地</strong>：</p>
<ul>
<li>console：输出到屏幕；</li>
<li>file：输出到文件；</li>
<li>socket：通过网络输出到远程计算机；</li>
<li>jdbc：输出到数据库</li>
</ul>
<p>通过Filter来<strong>过滤</strong>哪些log需要被输出，哪些log不需要被输出<br>通过Layout来<strong>格式化</strong>日志信息</p>
<p>因为Log4j也是一个第三方库，我们需要从<a href="https://logging.apache.org/log4j/2.x/download.html">这里</a>下载Log4j，解压后，把以下3个jar包放到<code>classpath</code>中：</p>
<ul>
<li>log4j-api-2.x.jar</li>
<li>log4j-core-2.x.jar</li>
<li>log4j-jcl-2.x.jar</li>
</ul>
<p>因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的<code>commons-logging-1.2.jar</code>也放到<code>classpath</code>中。</p>
<h2 id="使用SLF4J和Logback"><a href="#使用SLF4J和Logback" class="headerlink" title="使用SLF4J和Logback"></a>使用SLF4J和Logback</h2><p>SLF4J类似于Commons Logging，也是一个<strong>日志接口</strong>，而Logback类似于Log4j，是一个<strong>日志的实现</strong></p>
<p>在Commons Logging中，我们要打印日志，有时候得这么写：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure><br>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure></p>
<ul>
<li>SLF4J的日志接口传入的是一个带占位符的字符串</li>
</ul>
<p>如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对比一下Commons Logging和SLF4J的接口：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Commons Logging</th>
<th>SLF4J</th>
</tr>
</thead>
<tbody>
<tr>
<td>org.apache.commons.logging.Log</td>
<td>org.slf4j.Logger</td>
</tr>
<tr>
<td>org.apache.commons.logging.LogFactory</td>
<td>org.slf4j.LoggerFactory</td>
</tr>
</tbody>
</table>
</div>
<p>==不同之处就是Log变成了Logger，LogFactory变成了LoggerFactory==</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2023/10/25/JAVA%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h2 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h2><p>正则表达式可以用字符串来<strong>描述规则</strong>，并用来匹配字符串</p>
<p>例如，判断手机号，我们用正则表达式<code>\d&#123;11&#125;</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidMobileNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要判断用户输入的年份是否是<code>20##</code>年，我们先写出规则如下：</p>
<p>一共有4个字符，分别是：<code>2</code>，<code>0</code>，<code>0~9任意数字</code>，<code>0~9任意数字</code>。</p>
<p>对应的正则表达式就是：<code>20\d\d</code>，其中<u><strong><code>\d</code>表示任意一个数字</strong></u>。</p>
<p>把正则表达式转换为Java字符串就变成了<code>20\\d\\d</code>，注意Java字符串用<code>\\</code>表示<code>\</code></p>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><p>正则表达式的匹配规则是<strong>从左到右</strong>按规则匹配</p>
<ul>
<li><p>对于正则表达式<code>abc</code>来说，它只能精确地匹配字符串<code>&quot;abc&quot;</code>，不能匹配<code>&quot;ab&quot;</code>，<code>&quot;Abc&quot;</code>，<code>&quot;abcd&quot;</code>等其他任何字符串。</p>
</li>
<li><p>如果正则表达式有特殊字符，那就需要<strong>用<code>\</code>转义</strong>。例如，正则表达式<code>a\&amp;c</code>，其中<code>\&amp;</code>是用来匹配特殊字符<code>&amp;</code>的，它能精确匹配字符串<code>&quot;a&amp;c&quot;</code>，但不能匹配<code>&quot;ac&quot;</code>、<code>&quot;a-c&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>等。</p>
</li>
<li><p><u><strong>两个<code>\\</code>实际上表示的是一个<code>\</code></strong></u></p>
</li>
</ul>
<h3 id="匹配任意字符"><a href="#匹配任意字符" class="headerlink" title="匹配任意字符"></a>匹配任意字符</h3><p>我们可以用<code>.</code>匹配一个任意字符</p>
<ul>
<li><code>.</code>匹配一个字符且仅限一个字符</li>
</ul>
<h3 id="匹配数字"><a href="#匹配数字" class="headerlink" title="匹配数字"></a>匹配数字</h3><p>如果我们只想匹配<code>0</code>~<code>9</code>这样的数字，可以用<code>\d</code>匹配</p>
<ul>
<li><code>\d</code>仅限单个数字字符</li>
</ul>
<h3 id="匹配常用字符"><a href="#匹配常用字符" class="headerlink" title="匹配常用字符"></a>匹配常用字符</h3><p>用<code>\w</code>可以匹配一个<strong>字母、数字或下划线</strong>，w的意思是word</p>
<h3 id="匹配空白字符"><a href="#匹配空白字符" class="headerlink" title="匹配空白字符"></a>匹配空白字符</h3><p>用<code>\s</code>可以匹配一个空格字符，注意空格字符<strong>不但包括空格，还包括tab字符</strong>（在Java中用<code>\t</code>表示）</p>
<h3 id="匹配非数字"><a href="#匹配非数字" class="headerlink" title="匹配非数字"></a>匹配非数字</h3><p><code>\D</code>则匹配一个非数字</p>
<p>类似的，<code>\W</code>可以匹配<code>\w</code>不能匹配的字符，<code>\S</code>可以匹配<code>\s</code>不能匹配的字符，这几个正好是反着来的</p>
<h3 id="重复匹配"><a href="#重复匹配" class="headerlink" title="重复匹配"></a>重复匹配</h3><p>修饰符*可以匹配任意个字符，包括0个字符</p>
<p>我们用<code>A\d*</code>可以匹配：</p>
<ul>
<li><code>A</code>：因为<code>\d*</code>可以匹配0个数字；</li>
<li><code>A0</code>：因为<code>\d*</code>可以匹配1个数字<code>0</code>；</li>
<li><code>A380</code>：因为<code>\d*</code>可以匹配多个数字<code>380</code></li>
</ul>
<p>修饰符<code>+</code>可以匹配至少一个字符</p>
<p>修饰符<code>?</code>可以匹配0个或一个字符</p>
<p><u><strong>修饰符<code>&#123;n&#125;</code>可以精确指定n个字符</strong></u></p>
<ul>
<li>如果我们想指定匹配n~m个字符怎么办？用修饰符<code>&#123;n,m&#125;</code>就可以</li>
<li>如果<strong>没有上限</strong>，那么修饰符<code>&#123;n,&#125;</code>就可以匹配至少n个字符</li>
</ul>
<h3 id="单个字符匹配规则"><a href="#单个字符匹配规则" class="headerlink" title="单个字符匹配规则"></a>单个字符匹配规则</h3><div class="table-container">
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>规则</th>
<th>可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>指定字符</td>
<td>A</td>
</tr>
<tr>
<td>\u845c</td>
<td>指定Unicode字符</td>
<td>和</td>
</tr>
<tr>
<td>.</td>
<td>任意字符</td>
<td>a , b , &amp; , 0</td>
</tr>
<tr>
<td>\d</td>
<td>数字0~9</td>
<td>0~9</td>
</tr>
<tr>
<td>\w</td>
<td>大小写字母，数字和下划线</td>
<td>a~z , A~Z , 0~9</td>
</tr>
<tr>
<td>\s</td>
<td>空格、Tab键</td>
<td>空格、Tab</td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
<td>a , A , &amp; , _ , …</td>
</tr>
<tr>
<td>\W</td>
<td>非\w</td>
<td>&amp; , @ , 中 , …</td>
</tr>
<tr>
<td>\S</td>
<td>非\s</td>
<td>a , A , &amp; , _ , …</td>
</tr>
</tbody>
</table>
</div>
<h3 id="多个字符的匹配规则"><a href="#多个字符的匹配规则" class="headerlink" title="多个字符的匹配规则"></a>多个字符的匹配规则</h3><div class="table-container">
<table>
<thead>
<tr>
<th>正则表达式</th>
<th>规则</th>
<th>可以匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>A*</td>
<td>任意个数字符</td>
<td>空，A ，AA , …</td>
</tr>
<tr>
<td>A+</td>
<td>至少一个字符</td>
<td>A ，AA , …</td>
</tr>
<tr>
<td>A?</td>
<td>0个或1个字符</td>
<td>空 ， A</td>
</tr>
<tr>
<td>\d</td>
<td>数字0~9</td>
<td>0~9</td>
</tr>
<tr>
<td>A{3}</td>
<td>指定个数字符</td>
<td>AAA</td>
</tr>
<tr>
<td>A{2,}</td>
<td>至少n个字符</td>
<td>AA , AAA , …</td>
</tr>
<tr>
<td>A{0,3}</td>
<td>最多n个字符</td>
<td>空 ， A ，AA , AAA</td>
</tr>
</tbody>
</table>
</div>
<h2 id="复杂匹配规则"><a href="#复杂匹配规则" class="headerlink" title="复杂匹配规则"></a>复杂匹配规则</h2><h3 id="匹配开头和结尾"><a href="#匹配开头和结尾" class="headerlink" title="匹配开头和结尾"></a>匹配开头和结尾</h3><p>用正则表达式进行多行匹配时，我们用<code>^</code>表示开头，<script type="math/tex">`表示结尾。例如，`^A\d{3}</script>，可以匹配<code>&quot;A001&quot;</code>、<code>&quot;A380&quot;</code>。</p>
<h3 id="匹配指定范围"><a href="#匹配指定范围" class="headerlink" title="匹配指定范围"></a>匹配指定范围</h3><p>使用<code>[...]</code>可以匹配<strong>范围内</strong>的字符，例如，<code>[123456789]</code>可以匹配<code>1</code>~<code>9</code>，这样就可以写出上述电话号码的规则：<code>[1-9]\d&#123;6,7&#125;</code></p>
<p>要匹配大小写不限的十六进制数，比如<code>1A2b3c</code>，我们可以这样写：<code>[0-9a-fA-F]</code>，它表示一共可以匹配以下任意范围的字符：</p>
<ul>
<li><code>0-9</code>：字符<code>0</code>~<code>9</code>；</li>
<li><code>a-f</code>：字符<code>a</code>~<code>f</code>；</li>
<li><code>A-F</code>：字符<code>A</code>~<code>F</code>。</li>
</ul>
<p><code>[...]</code>还有一种排除法，即<strong>不包含指定范围的字符</strong>。假设我们要匹配任意字符，但不包括数字，可以写<code>[^1-9]&#123;3&#125;</code></p>
<h3 id="或规则匹配"><a href="#或规则匹配" class="headerlink" title="或规则匹配"></a>或规则匹配</h3><p>用<code>|</code>连接的两个正则规则是<strong>或规则</strong>，例如，<code>AB|CD</code>表示可以匹配<code>AB</code>或<code>CD</code></p>
<h3 id="使用括号"><a href="#使用括号" class="headerlink" title="使用括号"></a>使用括号</h3><p>现在我们想要匹配字符串<code>learn java</code>、<code>learn php</code>和<code>learn go</code>，可以<strong>把公共部分提出来</strong>，然后用<code>(...)</code>把子规则括起来表示成<code>learn\\s(java|php|go)</code><br>|正则表达式|规则|可以匹配|<br>|—-|—-|—-|<br>|^|开头|字符串开头|<br>|$|结尾|字符串结尾|<br>|[ABC]|[…]内任意字符|A,B,C|<br>|[A-F0-9xy]|指定范围的字符|A，…，F，0，…9,x,y|<br>|<sup><a href="#fn_A-F" id="reffn_A-F">A-F</a></sup>|指定范围外的任意字符|非A-F|<br>|<code>AB|CD|EF</code>|AB或CD或EF|AB,CD,EF|</p>
<h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><p><code>(...)</code>还有一个重要作用，就是分组匹配</p>
<p>提取匹配的子串正确的方法是<u><strong>用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为<code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code></strong></u></p>
<p><strong>按括号提取子串</strong>必须引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">g1</span> <span class="operator">=</span> m.group(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">g2</span> <span class="operator">=</span> m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>传入0会得到整个字串</li>
</ul>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><p>但是反复使用<code>String.matches()</code>对同一个正则表达式进行<strong>多次匹配效率较低</strong>，因为每次都会创建出一样的<code>Pattern</code>对象</p>
<p>完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        psattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matche(); <span class="comment">// false</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">whole</span> <span class="operator">=</span> matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">area</span> <span class="operator">=</span> matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h2><p>正则表达式默认使用<strong>贪婪匹配</strong>：任何一个规则，它总是尽可能多地向后匹配，因此，<code>\d+</code>总是会把后面的<code>0</code>包含进来</p>
<ul>
<li>(\d+)(0<em>) 在规则<code>\d+</code>后面加个<code>?</code>即可表示<em>*非贪婪匹配</em></em><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\d+?)(0*)&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="搜索与替换"><a href="#搜索与替换" class="headerlink" title="搜索与替换"></a>搜索与替换</h2><h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><p><code>String.split()</code>方法传入的正是正则表达式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;a b c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a b  c&quot;</span>.split(<span class="string">&quot;\\s&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span></span><br><span class="line"><span class="string">&quot;a, b ;; c&quot;</span>.split(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>); <span class="comment">// &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="搜索字符串"><a href="#搜索字符串" class="headerlink" title="搜索字符串"></a>搜索字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们获取到<code>Matcher</code>对象后，不需要调用<code>matches()</code>方法（因为匹配整个串肯定返回false），而是反复调用<code>find()</code>方法，在整个串中搜索能匹配上<code>\\wo\\w</code>规则的子串，并打印出来。这种方式比<code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是<code>o</code>，前后两个必须是字符<code>[A-Za-z0-9_]</code></p>
<h3 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h3><p>使用正则表达式替换字符串可以直接调用<code>String.replaceAll()</code>，它的<strong>第一个参数是正则表达式，第二个参数是待替换的字符串</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个<code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用<code>replaceAll()</code>的时候，我们传入的第二个参数可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的子串<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> s.replaceAll(<span class="string">&quot;\\s([a-z]&#123;4&#125;)\\s&quot;</span>, <span class="string">&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</span>);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述代码的运行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">the quick brown fox jumps &lt;b&gt;over&lt;/b&gt; the &lt;b&gt;lazy&lt;/b&gt; dog.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它实际上把任何4字符单词的前后用<code>&lt;b&gt;xxxx&lt;/b&gt;</code>括起来。实现替换的关键就在于<code>&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</code>，它用匹配的分组子串<code>([a-z]&#123;4&#125;)</code>替换了<code>$1</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2023/10/25/JAVA%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>泛型就是<strong>定义一种模板</strong>，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>要<strong>特别注意</strong>：不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code></p>
<p>==ArrayList<Integer>和ArrayList<Number>两者完全没有继承关系==</p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><h2 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h2><p>使用<code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code>Object</code></p>
<p>编译器如果能<strong>自动推断出泛型类型</strong>，就可以省略后面的泛型类型。例如，对于下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在<strong>接口</strong>中使用泛型</p>
<p><code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>String</code>本身已经实现了<code>Comparable&lt;String&gt;</code>接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    Person(String name, <span class="type">int</span> score) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="built_in">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，可以正确实现按<code>name</code>进行排序</p>
<h2 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h2><p>把特定类型<code>String</code>替换为<code>T</code>，并申明<code>&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><u><strong>泛型类型<code>&lt;T&gt;</code>不能用于静态方法</strong></u></p>
<p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用<strong>另一个类型</strong>即可<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; Pair&lt;K&gt; <span class="title function_">create</span><span class="params">(K first, K last)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多个泛型类型"><a href="#多个泛型类型" class="headerlink" title="多个泛型类型"></a>多个泛型类型</h3><p>我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, K&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, K last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> K <span class="title function_">getLast</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="擦拭法"><a href="#擦拭法" class="headerlink" title="擦拭法"></a>擦拭法</h2><p>Java语言的泛型实现方式是<strong>擦拭法（Type Erasure）</strong></p>
<ul>
<li>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的</li>
</ul>
<p>Java使用擦拭法实现泛型，导致了：</p>
<ul>
<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>
<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型</li>
</ul>
<p>Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，<u><strong>编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型</strong></u></p>
<p>Java泛型的<strong>局限</strong>:</p>
<ol>
<li><code>&lt;T&gt;</code><strong>不能是基本类型</strong>，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;<span class="type">int</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure></li>
<li>无法取得带泛型的<code>Class</code></li>
<li>无法判断带泛型的类型 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>不能实例化<code>T</code>类型</li>
</ol>
<h3 id="不恰当的覆写方法"><a href="#不恰当的覆写方法" class="headerlink" title="不恰当的覆写方法"></a>不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">    public boolean equals(T t) &#123;</span><br><span class="line">        return this == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>换个方法名，避开与<code>Object.equals(Object)</code>的冲突就可以成功编译：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">same</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>一个类可以继承自一个泛型类</p>
<p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型</p>
<h2 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h2><p>假设我们定义了<code>Pair&lt;T&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，我们又针对<code>Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code>Pair&lt;Number&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PairHelper</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码是可以正常编译的。使用的时候，我们传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> PairHelper.add(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Number&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：传入的类型是<code>Pair&lt;Number&gt;</code>，实际参数类型是<code>(Integer, Integer)</code></p>
<p><u><strong>使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型</strong></u><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Pair&lt;Integer&gt; p = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> add(p);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">last</span> <span class="operator">=</span> p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为<strong>上界通配符（Upper Bounds Wildcards）</strong>，即把泛型类型<code>T</code>的上界限定在<code>Number</code>了</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP</title>
    <url>/2023/11/21/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94DHCP/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>动态主机配置协议DHPC服务器可以是服务器</p>
<ol>
<li>一个协议软件在使用前先作正确协议配置，具体配置内容取决于协议</li>
</ol>
<ol>
<li><p>连接到因特网的计算机协议软件需要配置的项目：</p>
<ul>
<li><p>IP地址</p>
</li>
<li><p>子网掩码</p>
</li>
<li><p>默认路由器的IP地址</p>
</li>
<li><p>域名服务器的IP地址</p>
</li>
</ul>
</li>
<li><p><strong>DHCP可以高效地分配IP地址</strong></p>
<ul>
<li><p>局域网的网络协议</p>
</li>
<li><p>使用UDP来实现</p>
</li>
</ul>
</li>
</ol>
<h2 id="DHCP报文类型"><a href="#DHCP报文类型" class="headerlink" title="DHCP报文类型"></a>DHCP报文类型</h2><ul>
<li><p><strong>DHCP Discoevr</strong>：发现</p>
</li>
<li><p><strong>DHCP Offer</strong>：提供</p>
</li>
<li><p><strong>DHCP Request</strong>：告知决定</p>
</li>
<li><p><strong>DHCP ACK</strong>：租约确认</p>
</li>
<li><p><strong>DHCP NCK</strong>：租约不确认</p>
</li>
<li><p><strong>DHCP Release</strong>：释放租约</p>
</li>
<li><p><strong>DHCP Decline</strong>：收到ACK后，Client告诉服务器不接受</p>
</li>
<li><p><strong>DHCP Inform</strong>：客户端向服务器端请求详细信息</p>
</li>
</ul>
<h2 id="DHCP报文结构"><a href="#DHCP报文结构" class="headerlink" title="DHCP报文结构"></a>DHCP报文结构</h2><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/23-1676528328433-435.png" alt=""></p>
<ol>
<li><p><strong>OP</strong>：报文类型</p>
<ul>
<li>1请求，2应答</li>
</ul>
</li>
<li><p><strong>HTYPE</strong>：硬件地址类型</p>
</li>
</ol>
<ul>
<li>1表示10M以太网地址</li>
</ul>
<ol>
<li><p><strong>HLEN</strong>：以太网地址长度</p>
<ul>
<li>10M为6</li>
</ul>
</li>
<li><p><strong>Hops</strong>：是否使用代理服务器进行处理</p>
</li>
</ol>
<h2 id="DHCP过程"><a href="#DHCP过程" class="headerlink" title="DHCP过程"></a>DHCP过程</h2><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/16-1676528328433-428.png" alt=""></p>
<ol>
<li><p>Client先<strong>广播</strong>Discover报文，然后Server返回一个Offer报文</p>
</li>
<li><p>Client选择<strong>优先返回</strong>的Offer来优先服务</p>
</li>
<li><p>Client广播Request报文，告知到底谁服务了谁，然后Server返回一个ACK报文</p>
</li>
<li><p>时间到了之后可以选择Release或者续租</p>
</li>
</ol>
<p><strong>A和B的信息不对称不同步</strong></p>
<ul>
<li><p>局域网的地址B分配完成了而A不知道</p>
</li>
<li><p><strong>广播里面会携带分配的地址信息，告知A进行同步</strong></p>
</li>
</ul>
<h3 id="发现阶段"><a href="#发现阶段" class="headerlink" title="发现阶段"></a>发现阶段</h3><p>广播携带的地址是<strong>MAC地址</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec06/17.png" alt=""></p>
<h3 id="响应阶段"><a href="#响应阶段" class="headerlink" title="响应阶段"></a>响应阶段</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec06/18.png" alt=""></p>
<h3 id="选择阶段"><a href="#选择阶段" class="headerlink" title="选择阶段"></a>选择阶段</h3><p>所有的Server进行<strong>同步</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec06/19.png" alt=""></p>
<h3 id="租约确认阶段"><a href="#租约确认阶段" class="headerlink" title="租约确认阶段"></a>租约确认阶段</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec06/20.png" alt=""></p>
<h3 id="租期续约"><a href="#租期续约" class="headerlink" title="租期续约"></a>租期续约</h3><p>在租期中，DHCP Client直接向为其提供IP地址的DHCP Server发送DHCP Request消息，收到回应的DHCP ACK消息后，<strong>DHCP Client根据所提供的新的租期以及其它更新的TCP/IP参数更新自己的配置</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec06/21.png" alt=""></p>
<h3 id="租期释放"><a href="#租期释放" class="headerlink" title="租期释放"></a>租期释放</h3><p>当DHCP Client不再需要使用分配IP地址时，就会<strong>主动</strong>向DHCP Server发送Realease报文，DHCP Server会释放被绑定的租期</p>
<ul>
<li>到时间后Server会主动询问，<strong>没有应答会自动释放</strong></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2020-Internet-computing/img/lec06/22.png" alt=""></p>
<h2 id="DHCP欺骗及防范"><a href="#DHCP欺骗及防范" class="headerlink" title="DHCP欺骗及防范"></a>DHCP欺骗及防范</h2><h3 id="欺骗原理"><a href="#欺骗原理" class="headerlink" title="欺骗原理"></a>欺骗原理</h3><p><strong>非授权</strong>的DHCP服务器先应答，客户端最后获得的网络参数即是非授权的</p>
<ul>
<li>恶意服务器把自己作为默认网关</li>
</ul>
<p>在实际应用DHCP的网络中，基本上都会采用<strong>DHCP中继</strong>，因此<u>本网络的非授权DHCP服务器一般都会先于其余网络的授权DHCP服务器的应答</u></p>
<ul>
<li>网络传输有延迟</li>
</ul>
<h3 id="欺骗攻击"><a href="#欺骗攻击" class="headerlink" title="欺骗攻击"></a>欺骗攻击</h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/24-1676528328434-436.png" alt=""></p>
<ol>
<li><p>首先PC发出请求</p>
</li>
<li><p>然后将DHCP请求发送出去</p>
</li>
<li><p>伪装者收到后，DHCP伪装者给出应答</p>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/25-1676528328434-437.png" alt=""></p>
<ol>
<li><p>DHCP Server也会给出应答，但是可能比伪装者慢</p>
</li>
<li><p>这样子A收到的就是伪装者的报文</p>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/26-1676528328434-438.png" alt=""></p>
<ol>
<li><p>A发出去的网关就是B，所以A上网的请求就发送给B，B转发给默认网关上网，然后返回信息给B</p>
</li>
<li><p>B再把返回的信息给A</p>
</li>
<li><p><strong>很隐蔽的安全问题</strong></p>
</li>
<li><p>除了服务器不应该启动DHCP进程</p>
</li>
</ol>
<h3 id="DHCP欺骗防范"><a href="#DHCP欺骗防范" class="headerlink" title="DHCP欺骗防范"></a>DHCP欺骗防范</h3><p>在交换机上启用DHCP Snooping功能DHCP Snooping技术通过建立和维护DHCP Snooping绑定表过滤不可信任的DHCP信息：比如B的DHCP不能通过认证，交换机拒绝进行转发</p>
<ol>
<li><p>在交换机的全局配置模式启用DHCP Snooping：</p>
<p> <code>switch (config) # ip dncp snooping</code></p>
</li>
<li><p>在交换机的全局配置模式中开启需要启用DHCP Snooping的VLAN：</p>
<p> <code>switch (config) # ip dhcp snooping vlan vlan号</code></p>
</li>
<li><p>在端口配置子模式中将授权DHCP服务器所连的端口设为新人端口（缺省都是非信任的端口）：就是连接到DHCP Server的端口：</p>
<p> <code>switch (config-if) # ip dhcp snooping trust</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象基础</title>
    <url>/2023/10/25/JAVA%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自廖雪峰的官方网站： <a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com/</a></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>一个<code>class</code>可以包含多个<code>field</code>。但是，直接把<code>field</code>用<code>public</code>暴露给外部可能会<strong>破坏封装性</strong>。为了避免外部代码直接去访问<code>field</code>，我们可以用<code>private</code>修饰<code>field</code>，拒绝外部访问</p>
<ul>
<li>所以我们需要使用方法（<code>method</code>）来让外部代码可以<strong>间接修改</strong></li>
</ul>
<p>所以，一个类通过定义方法，就可以给外部代码暴露一些操作的<strong>接口</strong>，同时，内部自己保证逻辑一致性。</p>
<h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 方法返回类型 方法名(方法参数列表) &#123;</span><br><span class="line">    若干方法语句;</span><br><span class="line">    <span class="keyword">return</span> 方法返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>private方法<br>定义<code>private</code>方法的理由是<strong>内部方法</strong>是可以调用<code>private</code>方法的</p>
</li>
<li><p>this变量<br>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向<strong>当前实例</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 前面的this不可少，少了就变成局部变量name了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><ul>
<li><strong>基本类型</strong>参数的传递，是调用方值的复制。双方各自的后续修改，互不影响</li>
<li><strong>引用类型</strong>参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>创建实例的时候，实际上是通过构造方法来<strong>初始化</strong>实例的。</p>
<ul>
<li>构造方法的名称就是类名</li>
<li>和普通方法相比，构造方法<strong>没有返回值</strong>（也没有<code>void</code>），调用构造方法，必须用<code>new</code>操作符。</li>
<li>任何<code>class</code><strong>都有</strong>构造方法</li>
<li>如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来</li>
</ul>
<p>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用<u>默认值</u>，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code></p>
<ul>
<li>也可以对字段直接进行初始化</li>
</ul>
<p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p>
<p> <strong>1.先初始化字段<br> 2.执行构造方法的代码进行初始化</strong></p>
<p>一个构造方法可以调用其他构造方法，这样做的目的是<strong>便于代码复用</strong>。调用其他构造方法的语法是<code>this(…)</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;Unnamed&quot;</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法重载-Overload"><a href="#方法重载-Overload" class="headerlink" title="方法重载(Overload)"></a>方法重载(Overload)</h2><p>方法名相同，但各自的参数不同</p>
<p>方法重载的<strong>返回值类型</strong>通常都是相同的。</p>
<p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>子类自动获得了父类的所有字段，严禁定义与父类<strong>重名</strong>的字段！</p>
<p>任何类，除了<code>Object</code>，都会继承自某个类。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────┐</span><br><span class="line">│  Object   │</span><br><span class="line">└───────────┘</span><br><span class="line">      ▲</span><br><span class="line">      │</span><br><span class="line">┌───────────┐</span><br><span class="line">│  Person   │</span><br><span class="line">└───────────┘</span><br><span class="line">      ▲</span><br><span class="line">      │</span><br><span class="line">┌───────────┐</span><br><span class="line">│  Student  │</span><br><span class="line">└───────────┘</span><br></pre></td></tr></table></figure></p>
<p>Java只允许一个class继承自一个类，因此，一个类<strong>有且仅有一个</strong>父类。只有<code>Object</code>特殊，它没有父类。</p>
<p>继承有个特点，就是子类<strong>无法访问</strong>父类的<code>private</code>字段或者<code>private</code>方法。</p>
<ul>
<li>为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问</li>
</ul>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="built_in">super</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p>
<p>在Java中，任何<code>class</code>的构造方法，<strong>第一行语句必须是调用父类的<u>构造方法</u></strong>。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code></p>
<ul>
<li><strong>这里的<code>super()</code>是无参数构造方法</strong></li>
<li>如果父类没有默认的构造方法，子类就必须<strong>显式调用<code>super()</code>并给出参数</strong>以便让编译器定位到父类的一个合适的构造方法</li>
</ul>
<p>子类<strong>不会继承</strong>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的</p>
<h3 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h3><p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Rect, Circle, Triangle &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。</li>
</ul>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>如果<code>Student</code>是从<code>Person</code>继承下来的，那，一个引用类型为<code>Person</code>的变量，<strong>能</strong>指向<code>Student</code>类型的实例<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这种把一个子类类型安全地变为父类类型的赋值，被称为<strong>向上转型</strong>（upcasting）</li>
</ul>
<p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> p; <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure>
<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>如果把一个父类类型强制转型为子类类型，就是<strong>向下转型</strong>（downcasting）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(); <span class="comment">// upcasting, ok</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> (Student) p1; <span class="comment">// ok，因为p1确实指向Student实例</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> (Student) p2; <span class="comment">// runtime error! ClassCastException!子类功能比父类多，多的功能无法凭空变出来。</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</li>
</ul>
<p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以<strong>先判断</strong>一个实例究竟是不是某种类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">n</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>具有has关系不应该使用继承，而是<strong>使用组合</strong>，即<code>Student</code>可以持有一个<code>Book</code>实例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Book book;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因此，继承是is关系，组合是has关系。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为<strong>重写</strong>（Override）</p>
<p><strong><u>Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</u></strong></p>
<p>==<u>Java的实例方法调用是基于运行时的<strong>实际类型</strong>的动态调用，而非变量的声明类型。</u>==</p>
<ul>
<li>多态是指，针对某个类型的方法调用，其真正执行的方法<strong>取决于运行时期实际类型的方法</strong></li>
<li>多态的特性就是，<strong>运行期</strong>才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。</li>
</ul>
<h3 id="重写Object方法"><a href="#重写Object方法" class="headerlink" title="重写Object方法"></a>重写Object方法</h3><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>
<ul>
<li><code>toString()</code>：把instance输出为<code>String</code>；</li>
<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>
<li><code>hashCode()</code>：计算一个instance的哈希值。<br>在有必要的情况下，我们可以重写这些方法</li>
</ul>
<h3 id="调用super"><a href="#调用super" class="headerlink" title="调用super"></a>调用super</h3><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code></p>
<ul>
<li>如果一个类不希望任何其他类继承自它，那么可以把这个<strong>类本身</strong>标记为<code>final</code></li>
</ul>
<p>可以在构造方法中初始化final字段：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是<strong>让子类去重写它</strong>，那么，可以把父类的方法声明为抽象方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化</li>
<li>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它</li>
</ul>
<p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></p>
<p>抽象类可以<strong>强迫</strong>子类实现其定义的抽象方法，否则编译会报错</p>
<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不关心Person变量的具体子类型:</span></span><br><span class="line">s.run();</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><br>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同样不关心新的子类是如何实现run()方法的：</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">e.run();</span><br></pre></td></tr></table></figure><br>这种尽量引用高层类型，<strong>避免引用实际子类型</strong>的方式，称之为面向抽象编程</p>
<p>面向抽象编程的本质就是：</p>
<ul>
<li><p>上层代码只<strong>定义规范</strong>（例如：<code>abstract class Person</code>）；</p>
</li>
<li><p>不需要子类就可以实现业务逻辑（正常编译）；</p>
</li>
<li><p>具体的业务逻辑由不同的子类实现，<strong>调用者并不关心</strong>。</p>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>如果一个抽象类没有字段，所有方法<strong>全部都是抽象方法</strong>，就可以把该抽象类改写为接口：<code>interface</code></p>
<p>在Java中，使用<code>interface</code>可以声明一个接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所谓<code>interface</code>，就是比抽象类还要抽象的<strong>纯抽象</strong>接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符<strong>不需要写出来</strong>（写不写效果都一样）</p>
<p>一个类可以实现<strong>多个</strong><code>interface</code>（区别于继承）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123; <span class="comment">// 实现了两个interface</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意区分术语：</p>
<ul>
<li>Java的接口特指<code>interface</code>的定义，表示<strong>一个接口类型和一组方法签名</strong></li>
<li>编程接口<strong>泛指接口规范</strong>，如方法签名，数据格式，网络协议等。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>abstract class</th>
<th>interface</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承</td>
<td>只能extends一个class</td>
<td>可以implements多个interface</td>
</tr>
<tr>
<td>字段</td>
<td>可以定义实例字段</td>
<td>不能定义实例字段</td>
</tr>
<tr>
<td>抽象方法</td>
<td>可以定义抽象方法</td>
<td>可以定义抽象方法</td>
</tr>
<tr>
<td>非抽象方法</td>
<td>可以定义非抽象方法</td>
<td>可以定义default方法</td>
</tr>
</tbody>
</table>
</div>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>一个<code>interface</code>可以继承自另一个<code>interface</code><br><code>interface</code>继承自<code>interface</code>要使用<code>extends</code>，它相当于<strong>扩展</strong>了接口的方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>一般来说，<strong>公共逻辑</strong>适合放在<code>abstract class</code>中，<strong>具体逻辑</strong>放到各个子类，而接口层次代表<strong>抽象程度</strong></p>
<p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为<strong>接口比抽象类更抽象</strong></p>
<h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现类可以不必覆写<code>default</code>方法。<br><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改<strong>全部子类</strong>。</p>
<ul>
<li>当类实现接口时，类要实现接口中<strong>所有方法</strong></li>
</ul>
<p>如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法<strong>无法访问</strong>字段，而抽象类的普通方法可以访问实例字段。</p>
<h2 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h2><h3 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h3><p>实例字段在每个实例中都有自己的一个<strong>独立“空间”</strong><br>静态字段只有一个<strong>共享“空间”</strong>，所有实例都会共享该字段。</p>
<p>对于静态字段，无论修改哪个实例的静态字段，效果都是一样的：<strong>所有</strong>实例的静态字段都被修改了，原因是<u><strong>静态字段并不属于实例</strong></u></p>
<ul>
<li>实例可以访问静态字段，但它们指向的都是一个<strong>共享</strong>的静态字段</li>
<li>在java程序中，实例对象并<strong>没有静态字段</strong><ul>
<li>实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为<code>类名.静态字段</code>来访问静态对象</li>
<li>推荐用<strong>类名</strong>来访问静态字段</li>
<li>可以把静态字段理解为描述<code>class</code><strong>本身</strong>的字段<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Person.number = 99;</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>调用静态方法则不需要实例变量，通过<strong>类名</strong>就可以调用</p>
<p>因为静态方法属于<code>class</code>而不属于实例，因此，静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它<strong>只能访问静态字段</strong></p>
<ul>
<li>通常情况下，通过实例变量访问静态字段和静态方法，会得到一个编译警告</li>
</ul>
<p>静态方法经常用于<strong>工具类</strong>。例如：</p>
<ul>
<li><p>Arrays.sort()</p>
</li>
<li><p>Math.random()</p>
</li>
</ul>
<p>静态方法也经常用于<strong>辅助方法</strong></p>
<ul>
<li>注意到Java程序的入口<code>main()</code>也是静态方法。</li>
</ul>
<h3 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h3><p><code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型</p>
<ul>
<li>实际上，因为<code>interface</code>的字段<strong>只能</strong>是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MALE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">FEMALE</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>Java定义了一种名字空间，称之为<strong>包</strong>：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，<u><strong>真正的完整类名是<code>包名.类名</code></strong></u></p>
<ul>
<li>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</li>
<li>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</li>
<li>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</li>
<li>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</li>
</ul>
<p>在Java虚拟机执行的时候，<u><strong>JVM只看完整类名</strong></u>，因此，只要包名不同，类就不同</p>
<ul>
<li><u><strong>包可以是多层结构</strong></u>，用<code>.</code>隔开。例如：<code>java.util</code></li>
</ul>
<p>要特别注意：<u><strong>包没有父子关系</strong></u>。java.util和java.util.zip是不同的包，==两者没有任何继承关系==</p>
<p>没有定义包名的<code>class</code>，它使用的是<strong>默认包</strong>，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<ul>
<li>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包</li>
</ul>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><p>位于同一个包的类，可以访问<strong>包作用域</strong>的字段和方法</p>
<ul>
<li><strong>不用</strong><code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域</li>
</ul>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法</p>
<ol>
<li><del>直接写出完整类名</del><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名(<strong>最常用</strong>)<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的<u><strong>所有</strong><code>class</code></u>都导入进来（==但不包括子包的<code>class</code>==）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包</li>
</ul>
<p>3.<del><code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法</del><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于调用System.out.println(…)</span></span><br><span class="line">        out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java编译器最终编译出的<code>.class</code>文件只使用<strong>完整类名</strong></p>
<p>在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li><p>如果是完整类名，就直接根据<strong>完整类名</strong>查找这个<code>class</code>；</p>
</li>
<li><p>如果是简单类名，按下面的顺序依次查找：</p>
<ul>
<li><p>查找当前<code>package</code>是否存在这个<code>class</code>；</p>
</li>
<li><p>查找<code>import</code>的包是否包含这个<code>class</code>；</p>
</li>
<li><p>查找<code>java.lang</code>包是否包含这个<code>class</code>。</p>
</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则<strong>编译报错</strong></p>
<p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p>
<ul>
<li><p>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</p>
</li>
<li><p>默认自动<code>import java.lang.*</code>。</p>
</li>
</ul>
<p>注意：<u><strong>自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入</strong></u></p>
<p>如果有两个<code>class</code>名称相同,只能<code>import</code>其中一个，另一个必须写完整类名</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>为了避免名字冲突，我们需要确定<strong>唯一</strong>的包名</p>
<ul>
<li>推荐的做法是<u><strong>使用倒置的域名来确保唯一性</strong></u></li>
<li>子包就可以根据功能自行命名</li>
</ul>
<p>要注意不要和<code>java.lang</code>包的类重名<br>要注意也不要和<strong>JDK常用类</strong>重名</p>
<h3 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h3><p>假设我们创建了如下的目录结构：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">work</span><br><span class="line">├── bin</span><br><span class="line">└── src</span><br><span class="line">    └── com</span><br><span class="line">        └── itranswarp</span><br><span class="line">            ├── sample</span><br><span class="line">            │   └── Main.java</span><br><span class="line">            └── world</span><br><span class="line">                └── Person.java</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>bin</code>目录用于存放编译后的<code>class</code>文件，<code>src</code>目录按<strong>包结构</strong>存放Java源码</p>
<p>首先，<strong>确保</strong>当前目录是<code>work</code>目录，即存放<code>src</code>和<code>bin</code>的父目录：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">bin src</span><br></pre></td></tr></table></figure><br>然后，<strong>编译</strong><code>src</code>目录下的所有Java文件：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javac -d ./bin src/**/*.java</span><br></pre></td></tr></table></figure></p>
<ul>
<li>命令行<code>-d</code><strong>指定</strong>输出的<code>class</code>文件存放<code>bin</code>目录，后面的参数<code>src/**/*.java</code>表示<code>src</code>目录下的所有<code>.java</code>文件，包括<strong>任意深度</strong>的子目录。</li>
<li>注意：Windows不支持<code>**</code>这种搜索全部子目录的做法，所以在Windows下编译必须依次列出所有<code>.java</code>文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\work&gt; javac -d bin src\com\itranswarp\sample\Main.java src\com\itranswarp\world\Persion.java</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果编译无误，则<code>javac</code>命令<strong>没有任何输出</strong>。可以在<code>bin</code>目录下看到如下<code>class</code>文件：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin</span><br><span class="line">└── com</span><br><span class="line">    └── itranswarp</span><br><span class="line">        ├── sample</span><br><span class="line">        │   └── Main.class</span><br><span class="line">        └── world</span><br><span class="line">            └── Person.class</span><br></pre></td></tr></table></figure><br>现在，我们就可以直接运行<code>class</code>文件了。根据当前目录的位置<strong>确定classpath</strong>，例如，当前目录仍为<code>work</code>，则classpath为<code>bin</code>或者<code>./bin</code>：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ java -cp bin com.itranswarp.sample.Main </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他<strong>任何类</strong>访问</p>
<p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的<strong>权限</strong></p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>定义为<code>private</code>的<code>field</code>、<code>method</code><strong>无法</strong>被其他类访问、</p>
<ul>
<li><code>private</code>访问权限被限定在<code>class</code>的<strong>内部</strong>，而且<u><strong>与方法声明顺序无关</strong></u></li>
<li>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，<strong>嵌套类</strong>拥有访问<code>private</code>的权限<ul>
<li>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类</li>
</ul>
</li>
</ul>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p><code>protected</code>作用于<strong>继承关系</strong>。</p>
<p>定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</p>
<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法</p>
<ul>
<li>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code></li>
<li>注意，包名必须<strong>完全一致</strong>，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="Inner-class"><a href="#Inner-class" class="headerlink" title="Inner class"></a>Inner class</h3><p>有一种类，它被定义在另一个类的内部，所以称为内部类（Nested Class）。</p>
<ul>
<li>Inner Class的实例<strong>不能单独存在</strong>，必须依附于一个Outer Class的实例<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h3>还有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在<strong>方法内部</strong>，通过匿名类（Anonymous Class）来定义<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">asyncHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="built_in">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的<strong>匿名类</strong>，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法</li>
<li>如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code></li>
</ul>
<p>除了接口外，匿名类也完全可以继承自普通类<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;&#125;; <span class="comment">// 匿名类!</span></span><br><span class="line">        HashMap&lt;String, String&gt; map3 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                put(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">                put(<span class="string">&quot;B&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(map3.get(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h3><p>一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.<span class="type">StaticNested</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticNested</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个<strong>完全独立</strong>的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。</p>
<h2 id="classpath和jar"><a href="#classpath和jar" class="headerlink" title="classpath和jar"></a>classpath和jar</h2><h3 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h3><p><code>classpath</code>是JVM用到的一个<strong>环境变量</strong>，它用来<u><strong>指示JVM如何搜索<code>class</code></strong></u></p>
<ul>
<li><strong>编译后</strong>的<code>.class</code>文件才是真正可以被JVM执行的字节码</li>
</ul>
<p><code>classpath</code>就是<strong>一组目录的集合</strong>，它设置的搜索路径与操作系统相关</p>
<ul>
<li>在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\work\project1\bin;C:\shared;&quot;D:\My 	Documents\project1\bin&quot;</span><br></pre></td></tr></table></figure></li>
<li>在Linux系统上，用<code>:</code>分隔  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会<strong>依次查找</strong>：</p>
<ul>
<li><p>&lt;当前目录&gt;\abc\xyz\Hello.class</p>
</li>
<li><p>C:\work\project1\bin\abc\xyz\Hello.class</p>
</li>
<li><p>C:\shared\abc\xyz\Hello.class<br>注意到<code>.</code>代表<strong>当前目录</strong></p>
</li>
</ul>
<p>如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>
<p><code>classpath</code>的设定方法有两种：</p>
<ul>
<li><p><del>在系统环境变量中设置<code>classpath</code>环境变量</del></p>
<ul>
<li><u><strong>污染整个系统环境</strong></u></li>
</ul>
</li>
<li><p>在<strong>启动JVM时</strong>设置<code>classpath</code>变量</p>
<ul>
<li>给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure></li>
<li>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即<strong>当前目录</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java abc.xyz.Hello</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是<u><strong>当前工程的<code>bin</code>目录和引入的jar包</strong></u></p>
<ul>
<li>==不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！==</li>
</ul>
<p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p>
<p>如果指定的<code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错</p>
<h3 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h3><p>jar包可以把<code>package</code>组织的目录层级，以及各个目录下的<strong>所有文件</strong>（包括<code>.class</code>文件和其他文件）都打成一个jar文件</p>
<p>jar包里的第一层目录，不能是<code>bin</code></p>
<ul>
<li>Windows中应该是这样<br><a href="https://www.liaoxuefeng.com/files/attachments/1261393208671488/l">https://www.liaoxuefeng.com/files/attachments/1261393208671488/l</a></li>
<li>有问题的长这样<br><a href="https://www.liaoxuefeng.com/files/attachments/1261391527906784/l">https://www.liaoxuefeng.com/files/attachments/1261391527906784/l</a></li>
</ul>
<p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息</p>
<p>JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure></p>
<h2 id="class版本"><a href="#class版本" class="headerlink" title="class版本"></a>class版本</h2><p>我们通常说的Java 8，Java 11，Java 17，是指<strong>JDK</strong>的版本，也就是<strong>JVM</strong>的版本，更确切地说，就是<code>java.exe</code>这个程序的版本</p>
<ul>
<li>而每个版本的JVM，它能执行的<strong>class文件版本</strong>也不同</li>
<li>只要看到<code>UnsupportedClassVersionError</code>就表示当前要加载的class文件版本超过了JVM的能力，必须使用<strong>更高版本</strong>的JVM才能运行</li>
</ul>
<p>指定编译输出有两种方式，一种是在<code>javac</code>命令行中用参数<code>--release</code>设置：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javac --release 11 Main.java</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<ul>
<li>参数<code>--release 11</code>表示源码兼容Java 11，编译的class输出版本为<strong>Java 11兼容</strong>，即class版本55。</li>
</ul>
<p>第二种方式是用参数<code>--source</code>指定<strong>源码版本</strong>，用参数<code>--target</code>指定<strong>输出class版本</strong>：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javac --source 9 --target 11 Main.java</span><br></pre></td></tr></table></figure></p>
<ul>
<li>上述命令如果使用Java 17的JDK编译，它会把源码视为<strong>Java 9兼容版本</strong>，并输出class为Java 11兼容版本</li>
</ul>
<p>注意<code>--release</code>参数和<code>--source --target</code>参数只能<strong>二选一</strong>，不能同时设置<br>指定版本如果<strong>低于</strong>当前的JDK版本，会有一些潜在的问题</p>
<p>==如果使用—release 11则会在编译时检查该方法是否在Java 11中存在==</p>
<p>如果运行时的JVM版本是Java 11，则编译时也最好使用Java 11，而不是用高版本的JDK编译输出低版本的class</p>
<p>如果使用<code>javac</code>编译时不指定任何版本参数，那么相当于使用<code>--release 当前版本</code>编译，即源码版本和输出版本均为<strong>当前版本</strong></p>
<p>在开发阶段，多个版本的JDK可以同时安装，当前使用的JDK版本可由<code>JAVA_HOME</code>环境变量切换</p>
<p>在编译的时候，如果用<code>--source</code>或<code>--release</code>指定源码版本，则使用指定的源码版本检查语法</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的<strong>Java标准库</strong>，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M</p>
<p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -<span class="built_in">cp</span> app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</span><br></pre></td></tr></table></figure><br>==注意：JVM自带的标准库<u><strong>rt.jar</strong></u>不要写到classpath中，写了反而会干扰JVM的正常运行==</p>
<ul>
<li>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code>ClassNotFoundException</code></li>
<li>jar只是用于存放class的容器，它并<strong>不关心</strong>class之间的依赖</li>
</ul>
<p>如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种<strong>自带依赖关系</strong>的<u>class容器</u>就是模块</p>
<p>从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>
<ul>
<li>java.base.jmod</li>
<li>java.compiler.jmod</li>
<li>java.datatransfer.jmod</li>
<li>java.desktop.jmod</li>
<li>…</li>
</ul>
<p>这些<code>.jmod</code>文件每一个都是一个模块，<u><strong>模块名就是文件名</strong></u></p>
<ul>
<li>模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code></li>
<li>模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了</li>
</ul>
<p>所有的模块<strong>都</strong>直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“<strong>根模块</strong>”，好比所有的类都是从<code>Object</code>直接或间接继承而来</p>
<p><strong>模块支持多版本</strong>，即在同一个模块中可以为不同的JVM提供不同的版本</p>
<h3 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h3><p>以<code>oop-module</code>工程为例，它的目录结构如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">├── build.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure><br>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是<strong>模块的描述文件</strong></p>
<ul>
<li><p>在这个模块中，它长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">	<span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。<u><strong>花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名</strong></u>。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块</p>
</li>
<li><p>当我们使用模块声明了依赖关系后，才能使用引入的模块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.XMLConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Greeting</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>();</span><br><span class="line">		System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是<strong>声明依赖关系</strong> </p>
</li>
</ul>
<h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><p>1.我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure><br>如果编译成功，现在项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">│   ├── com</span><br><span class="line">│   │   └── itranswarp</span><br><span class="line">│   │       └── sample</span><br><span class="line">│   │           ├── Greeting.class</span><br><span class="line">│   │           └── Main.class</span><br><span class="line">│   └── module-info.class</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure>
<p>2.我们需要把bin目录下的<strong>所有class文件先打包成jar</strong>，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure>
<p>3.继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure><br>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块</p>
<h3 id="运行模块"><a href="#运行模块" class="headerlink" title="运行模块"></a>运行模块</h3><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要<strong>指定模块名</strong>。试试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java --module-path hello.jmod --module hello.world</span><br></pre></td></tr></table></figure><br>结果是一个错误：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error occurred during initialization of boot layer</span><br><span class="line">java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</span><br></pre></td></tr></table></figure><br>原因是<u><strong><code>.jmod</code>不能被放入<code>--module-path</code>中</strong></u>。换成<code>.jar</code>就没问题了：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java --module-path hello.jar --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure><br>那我们辛辛苦苦创建的<code>hello.jmod</code>有什么用？答案是我们可以用它来<strong>打包JRE</strong></p>
<h3 id="打包JRE"><a href="#打包JRE" class="headerlink" title="打包JRE"></a>打包JRE</h3><p>JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉</p>
<ul>
<li>并不是说把系统安装的JRE给删掉部分模块，而是<strong>复制</strong>一份JRE，但<u><strong>只带上用到的模块</strong></u><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure></li>
<li>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录</li>
</ul>
<p>在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE</p>
<p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署</p>
<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是<u><strong>b模块明确地导出了可以访问的包</strong></u></p>
<p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml &#123;</span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>只有它声明的导出的包，外部代码才被允许访问</strong>。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> java.base;</span><br><span class="line">	<span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因此，<strong>模块进一步隔离了代码的访问权限</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>self_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2023/11/16/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>传输层向它上面的应用层提供通信服务</strong></p>
<ul>
<li>从传输层看，通信的真正端点不是主机而是<strong>主机中的进程</strong></li>
</ul>
<p>传输层有一个很重要的功能：<strong>复用</strong>(multiplexing)和<strong>分用</strong>(demultiplexing)</p>
<ul>
<li><p><strong>复用</strong>：应用层的所有应用程序都可以通过传输层再传送到网络层</p>
</li>
<li><p><strong>分用</strong>：传输层从网络层收到发送给各应用程序的数据后，必须交付指明的各应用程序</p>
</li>
</ul>
<p>运输层提供应用进程间的<strong>逻辑通信</strong></p>
<ul>
<li><p>数据的传送好像是沿着水平方向传送的</p>
</li>
<li><p>网络层为<strong>主机之间</strong>提供逻辑通信</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/07/F3Jnj9qElOINDC5.png" alt="《计算机网络》学习总结——运输层、TCP与UDP（详细理解）_为什么要提供两种tcp udp2中协议_羊and船的博客-CSDN博客"></p>
<p>传输层会对收到的报文进行<strong>差错检测</strong></p>
<p>传输层有两种不同的运输协议：</p>
<ol>
<li><p><strong>面向连接的TCP</strong></p>
</li>
<li><p><strong>无连接的UDP</strong></p>
</li>
</ol>
<p>传输层向高层用户屏蔽了下面网络核心的细节，使得应用进程看见的就是好像在两个运输层实体之间有一条<strong>端对端的逻辑通信信道</strong></p>
<ul>
<li><p>传输层采用<strong>面向连接的TCP协议</strong>时，尽管下面的网络是不可靠的，但这种逻辑通信信道相当于一条<strong>全双工的可靠信道</strong></p>
</li>
<li><p>传输层采用<strong>无连接的UDP协议</strong>时，这种逻辑通信信道仍然是一条<strong>不可靠信道</strong> </p>
</li>
</ul>
<h2 id="传输层的两个协议"><a href="#传输层的两个协议" class="headerlink" title="传输层的两个协议"></a>传输层的两个协议</h2><p>传输层有两种不同的运输协议：</p>
<ol>
<li><p><strong>面向连接的TCP（传输控制协议）</strong></p>
<ul>
<li><p>传送数据前要<strong>先建立连接</strong>，数据传送结束后要<strong>释放连接</strong></p>
</li>
<li><p>不提供广播或多播服务</p>
</li>
</ul>
</li>
<li><p><strong>无连接的UDP（用户数据报协议）</strong></p>
<ul>
<li>传送数据前<strong>不需要先建立连接</strong>，远地主机收到UDP报文后<strong>不需要确认</strong></li>
</ul>
</li>
</ol>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>TCP和UDP都是用<strong>端口</strong>来跟踪同时穿越网络的<strong>不同网络</strong>（即不同进程）</p>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/1-1676528301910-375.png" alt=""></p>
<p>端口分配规范：</p>
<ol>
<li><p>0-255保留给TCP和UDP公共应用程序使用</p>
</li>
<li><p>0-1023是熟知端口，有分发的规范，<strong>不应当被随便使用</strong></p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>SNMP</th>
<th>SNMP(trap)</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody>
<tr>
<td>熟知端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td>80</td>
<td>161</td>
<td>162</td>
<td>443</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>1024-49151可以进行登记使用，避免冲突</p>
</li>
<li><p>49152-65535为短暂端口号，用于<strong>远程通信</strong></p>
</li>
</ol>
<h3 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h3><p>第四层进行通信的单位是进程，由IP和端口共同制定，<strong>socket是第四层的地址</strong></p>
<ul>
<li><p>socket表示为（IP地址，端口）</p>
</li>
<li><p>每个连接都表示为（$socket_{source}$，$socket_{destination}$）</p>
</li>
<li><p>通信被认为是<strong>以一个socket和另一个socket之间的连接</strong></p>
</li>
</ul>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP最主要的特点：</p>
<ol>
<li><p>TCP是<strong>面向连接</strong>的传输层协议</p>
</li>
<li><p>每一条TCP连接只能由两个<strong>端点</strong>(endpoint)，只能是<strong>点对点</strong></p>
</li>
<li><p>TCP提供<strong>可靠交付</strong>的服务</p>
<ul>
<li>通过TCP连接传送的数据<strong>无差错、不丢失、不重复、按需到达</strong></li>
</ul>
</li>
<li><p>TCP提供<strong>全双工通信</strong></p>
<ul>
<li>两端都设有发送缓存和接收缓存</li>
</ul>
</li>
<li><p><strong>面向字节流</strong></p>
<ul>
<li>TCP把应用程序交下来的数据仅仅看成是一连串的<strong>无结构字节流</strong></li>
</ul>
</li>
</ol>
<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.pA-FXiUNi1jeLanK9IMlPQHaDl?pid=ImgDet&amp;rs=1" alt="【图解】三次握手，四次挥手 —— 用心看这一篇就够了-阿里云开发者社区"></p>
<p>TCP必须解决的问题：</p>
<ol>
<li><p><strong>可靠传输</strong></p>
</li>
<li><p><strong>流量控制</strong></p>
<ul>
<li><p>滑动窗口</p>
</li>
<li><p>拥塞避免</p>
</li>
</ul>
</li>
<li><p><strong>连接控制</strong></p>
<ul>
<li><p>建立连接：三次握手</p>
</li>
<li><p>断开连接：四次握手</p>
</li>
</ul>
</li>
</ol>
<h3 id="TCP数据报"><a href="#TCP数据报" class="headerlink" title="TCP数据报"></a>TCP数据报</h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625154905110.png" alt=""></p>
<p>基本情况：<strong>一行4字节</strong>，固定首部长度为20字节</p>
<ol>
<li><p><strong>源端口和目的端口</strong></p>
<p> 传输层和应用层的服务接口，各占2字节</p>
<ul>
<li>复用和分用功能都要通过端口实现</li>
</ul>
</li>
<li><p><strong>序号</strong></p>
<p> TCP传送的数据流中的每一个字节都编上一个编号，序号字段的值指<u>本报文所发送的数据的<strong>第一个字节的序号</strong></u>，占4字节</p>
<ul>
<li><p>通过序号字段做可靠传输的保证，指示的是<strong>TCP传输的比特编码</strong>，而不是地址</p>
</li>
<li><p>从小向大进行使用，使用到最大之后会从小再次重新开始分配</p>
</li>
</ul>
</li>
<li><p><strong>确认号</strong></p>
<p> <strong>期望收到的下一个报文段</strong>的数据的第一个字节的序号，用于确认对方的数据号，同时对上一次传输进行确认，占4字节</p>
<ul>
<li>体现出全双工通信的有点，比如上回收到的最后序号是700，那么确认号就是701</li>
</ul>
</li>
<li><p><strong>数据偏移</strong></p>
<p> 指出TCP报文段的数据起始处距TCP报文段的起始处的长度，<strong>单位是32位字</strong>（即4字节）</p>
<ul>
<li>不满足的话使用填充位保证为4字节的整数倍</li>
</ul>
</li>
<li><p><strong>URG</strong></p>
<p> URG = 1时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送</p>
</li>
<li><p><strong>ACK</strong></p>
<p> ACK = 1时确认号字段有效</p>
</li>
<li><p><strong>推送PSH(PuSH)</strong></p>
<p> 接收TCP收到PSH = 1的报文段，就尽快交付应用进程，而不再等到整个缓存都填满了再向上交付，此时<strong>将缓存所有部分都传输</strong></p>
</li>
</ol>
<ul>
<li><u>TCP在正常情况下并不是马上传输的，而是等到缓存满了才发送</u></li>
</ul>
<ol>
<li><p><strong>复位RST</strong></p>
<p> ReSeT = 1时表明TCP连接中出现严重差错，<strong>必须释放连接再重新建立连接</strong>  </p>
<ul>
<li>如果请求方发送的请求，如果应答方不想连接则将ReSeT置为1</li>
</ul>
</li>
<li><p><strong>同步SYN</strong></p>
<p>SYN = 1时表明这是一个连接请求或连接接受报文</p>
</li>
<li><p><strong>终止FIN</strong></p>
<p>FIN = 1表明此报文段的发送端的数据已发送完毕，并要求释放传输连接</p>
<ul>
<li>断开连接有四次握手</li>
</ul>
</li>
<li><p><strong>窗口</strong></p>
<p>用来让对方设置<strong>发送窗口</strong>的依据，表示可以进行传输的窗口大小，<strong>单位是字节</strong>，占2字节</p>
</li>
<li><p><strong>校验和</strong></p>
<p>校验和字段检验的范围包括<strong>首部和数据</strong>这两部分，占2字节</p>
</li>
<li><p><strong>紧急指针</strong></p>
<p>指出在本报文段中紧急数据共有几个字节，占2字节</p>
<ul>
<li><u>紧急数据放在本报文段数据的最前面</u></li>
</ul>
</li>
<li><p><strong>选项</strong></p>
<p>TCP最初只有一种选项，即<strong>最大报文段长度MSS</strong>(Maximum Segment Size)</p>
<ul>
<li>MSS告诉对方缓存所能接收的报文段的数据字段的最大长度是MSS个字节</li>
<li>数据字段要加上TCP首部才等于整个TCP报文段</li>
</ul>
</li>
<li><p><strong>填充字段</strong></p>
<p>使整个首部长度是4字节的整数倍</p>
</li>
</ol>
<p><strong>主机使用网段(TPDU)交换数据</strong></p>
<ul>
<li>每个段都有首部20字节 + 0或更多数据字节</li>
</ul>
<ul>
<li><p>段的大小必须与IP数据报匹配，并且必须满足底层的需求</p>
</li>
<li><p>每个字节都有一个32位序号</p>
<ul>
<li><p>通讯中商定初识序号，确认到每一位</p>
</li>
<li><p>面向字节：<strong>数据块大小可以不对应</strong></p>
</li>
<li><p><strong>根据网络条件，对每一个字节进行确认</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="建立可靠连接（三次握手）"><a href="#建立可靠连接（三次握手）" class="headerlink" title="建立可靠连接（三次握手）"></a>建立可靠连接（三次握手）</h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625160131800.png" alt=""></p>
<ol>
<li><p><strong>第一次握手</strong></p>
<ul>
<li><p><strong>客户端</strong>：执行CONNECT原语，生成 SYN = 1 和 ACK = 0 的TCP段，代表<strong>连接请求</strong></p>
</li>
<li><p><strong>服务器</strong>：执行LISTEN和ACCEPT原语，并进行<strong>被动监视</strong></p>
</li>
</ul>
</li>
<li><p><strong>第二次握手</strong></p>
<p> <u>服务器检查是否存在监视端口的服务进程</u></p>
<ul>
<li><p>如果没有任何进程，则使用 RST = 1 回答一个TCP段</p>
</li>
<li><p>如果存在进程，则决定拒绝或接受请求</p>
<ul>
<li>如果接受连接请求，则发送 SYN = 1 和 ACK = 1 的网段</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li><p><strong>第三次握手</strong></p>
<p> 客户端发送一个 SYN = 0 和 ACK = 1 的网段<strong>确认连接</strong></p>
<ul>
<li><p>三次握手是为了避免出现延时之类的情况</p>
</li>
<li><p>默认三次握手就认为可靠了，之后进行数据传输</p>
</li>
<li><p>有时候会选择则第三次握手的时候同时携带数据</p>
</li>
</ul>
</li>
</ol>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721111915206.png" alt=""></p>
<p>发送段后要<strong>暂时保留备份</strong></p>
<ul>
<li><p>没有收到确认可以进行重传（<strong>超时重传</strong>）</p>
<ul>
<li><p>设置一个超时计数器：<u>如果对方的应答超过一定时间后则直接重发</u></p>
</li>
<li><p>重新发送时间必须<strong>大于 平均传输时间 $\times$ 2</strong></p>
</li>
</ul>
</li>
<li><p>收到确认就抛弃备份</p>
</li>
</ul>
<p>每个网段和ACK必须具有ID</p>
<p><strong>停止等待协议效率较低</strong></p>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721111921621.png" alt=""></p>
<p>没有收到应答或者丢失都要直接<strong>重传</strong></p>
<p>收到重复的就直接丢弃并重新发送确认</p>
<ul>
<li><strong>出现在ACK丢失的情况</strong></li>
</ul>
<h3 id="连续ARQ协议（滑动窗口的思想）"><a href="#连续ARQ协议（滑动窗口的思想）" class="headerlink" title="连续ARQ协议（滑动窗口的思想）"></a>连续ARQ协议（滑动窗口的思想）</h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721111935526.png" alt=""></p>
<p><strong>多个数据同时发送</strong>（一次发送多个）</p>
<p>窗口大小是双方协定的</p>
<ul>
<li>通过TCP报文中的窗口字段表示</li>
</ul>
<p><strong>出现丢失的情况</strong>：</p>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721112006370.png" alt=""></p>
<ul>
<li>如果连续发送五个分组，而第三个分组丢失了，则要不最后三个分组都重传一遍，这叫做<strong>后退N帧</strong></li>
</ul>
<h3 id="释放连接（四次握手）"><a href="#释放连接（四次握手）" class="headerlink" title="释放连接（四次握手）"></a>释放连接（四次握手）</h3><p><strong>释放连接前必须等待最大的网络往返时间 2MSL</strong>（保证能处理到B最后发送的报文）</p>
<ul>
<li>防止出现任何无效的连接请求段</li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625160335629.png" alt=""></p>
<ol>
<li><p><strong>第一次握手</strong></p>
<p> 发起断开连接请求</p>
</li>
<li><p><strong> 第二次握手</strong></p>
<p> ACK = 1：允许断开，此时<u>不再发送数据，需要完成之前未处理完成的数据的处理</u></p>
</li>
<li><p><strong>第三次握手</strong></p>
<p> FIN = 1：数据处理完成，表示正式断开</p>
</li>
<li><p><strong>第四次握手</strong></p>
<p> 收到断开信息</p>
</li>
</ol>
<h3 id="TCP中的计时器"><a href="#TCP中的计时器" class="headerlink" title="TCP中的计时器"></a>TCP中的计时器</h3><ol>
<li><p><strong>重传计时器</strong>：决定多长时间进行重传</p>
</li>
<li><p><strong>坚持计时器</strong>：避免死锁</p>
<ul>
<li><p>WIN = 0的时候修改但是无法发送过去</p>
</li>
<li><p>收到WIN = 0的时候开始进行计时，到时候主动询问</p>
</li>
</ul>
</li>
<li><p><strong>保持计时器</strong>：发送数据段后刷新，如果到达一定时间则再次询问是不是还要保持连接</p>
</li>
<li><p><strong>时间等待计时器</strong></p>
</li>
</ol>
<h3 id="TCP有限状态机"><a href="#TCP有限状态机" class="headerlink" title="TCP有限状态机"></a>TCP有限状态机</h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721112024491.png" alt=""></p>
<ul>
<li><p><strong>粗线</strong>：正常的服务器端</p>
</li>
<li><p><strong>细线</strong>：异常状态</p>
</li>
<li><p><strong>虚线</strong>：正常的客户端</p>
</li>
</ul>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>UDP的最主要特点：</p>
<ol>
<li><p>没有建立连接（避免延时）</p>
</li>
<li><p>简单：发送方、接收方无连接状态</p>
<ul>
<li><p>没有握手等</p>
</li>
<li><p>每个UDP段都独立处理</p>
</li>
</ul>
</li>
<li><p>小段标题</p>
</li>
<li><p><strong>没有拥塞控制</strong></p>
</li>
</ol>
<p>UDP常见用处：</p>
<ol>
<li><p>流媒体和多媒体应用</p>
<ul>
<li><strong>速率敏感而非质量敏感</strong></li>
</ul>
</li>
<li><p>RIP：定期发送路由信息</p>
</li>
<li><p>DNS：避免延迟建立TCP连接（<strong>DNS需快速找到</strong>）</p>
</li>
<li><p>SNMP：拥塞时，SNMP必须仍然可以运行，<u>在没有拥塞和可靠性控制机制的情况下，UDP性能优于TCP</u></p>
<ul>
<li>组播和多播</li>
</ul>
</li>
<li><p>其他协议如TFTP、DHCP</p>
</li>
</ol>
<h3 id="UDP数据帧格式"><a href="#UDP数据帧格式" class="headerlink" title="UDP数据帧格式"></a>UDP数据帧格式</h3><p><img src="https://pic4.zhimg.com/v2-5802c1b70343ab580e72a6005f5a6207_b.jpg" alt="UDP详解 - 知乎"></p>
<ul>
<li><p><strong>首部只有8字节，因此UDP报文最少是8字节</strong></p>
</li>
<li><p>校验时包括数据部分，如果出现错误直接丢弃</p>
</li>
<li><p>应用层进行数据切片，决定如何进行发送，UDP直接发送，不会再自己切片</p>
</li>
</ul>
<h2 id="TCP和UDP的异同"><a href="#TCP和UDP的异同" class="headerlink" title="TCP和UDP的异同"></a>TCP和UDP的异同</h2><p><strong>不同点</strong>：</p>
<ol>
<li><p>TCP不是直接交给上层校验，而是需要先和对方沟通，<strong>缓存满了才统一交付</strong></p>
</li>
<li><p>UDP直接转发报文，保留报文标间，IP进行划分，应用程序会发送比较何时的UDP报文大小</p>
</li>
</ol>
<p><strong>共同点</strong>：</p>
<ol>
<li>校验相同</li>
</ol>
<h2 id="NAT和PAT"><a href="#NAT和PAT" class="headerlink" title="NAT和PAT"></a>NAT和PAT</h2><p>NAT是再IP数据报头部将一个地址转化为另一个地址的过程</p>
<p>NAT用于允许私下寻址的主机访问Internet，NAT是IP地址耗尽的解决方案之一：</p>
<ol>
<li><p>保留注册（合法）地址</p>
</li>
<li><p>连接到Internet时增加灵活性</p>
</li>
</ol>
<p><strong>NAT需要一个路由器来实现</strong></p>
<ul>
<li>NAT路由器可以双向转换</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-24f7e8ca7d2d40a7b33ea3f254a6a047_r.jpg" alt="NAT(地址转换技术)详解【转载】 - 知乎"></p>
<h3 id="NAT的类型"><a href="#NAT的类型" class="headerlink" title="NAT的类型"></a>NAT的类型</h3><ol>
<li><p><strong>静态NAT</strong>：固定的内部地址到注册地址的映射</p>
</li>
<li><p><strong>动态NAT</strong>：映射以先到先得的方式动态进行</p>
</li>
<li><p><strong>PAT</strong>：端口地址转换用于允许许多内部用户共享一个“内部全局”地址</p>
<ul>
<li><p>基于socket映射而不是IP地址</p>
</li>
<li><p>多个内网主机映射到一个公网地址</p>
</li>
</ul>
</li>
</ol>
<h3 id="NAT地址类型"><a href="#NAT地址类型" class="headerlink" title="NAT地址类型"></a>NAT地址类型</h3><ol>
<li><p><strong>内部本地地址</strong>(Inside Local address)：内网IP地址</p>
</li>
<li><p><strong>内部全局地址</strong>(Inside Global address)：注册IP地址，对外部展示的内部地址</p>
</li>
<li><p><strong>外部全局地址</strong>(Outside Global address)：由主机所有者分配的IP地址，通常是注册地址</p>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625161850005.png" alt=""></p>
<p><u>内部主机发送报文给网关，网关根据NAT table进行翻译，转换成内部全局地址，然后进行转发</u></p>
<h3 id="NAT的优缺点"><a href="#NAT的优缺点" class="headerlink" title="NAT的优缺点"></a>NAT的优缺点</h3><ol>
<li><p><strong>优点</strong>：并非每个内部主机都需要同时进行外部访问，因此可以是用少量的全局唯一地址池来服务相对大量的私有寻址主机</p>
</li>
<li><p><strong>缺点</strong>：映射没有从根本上解决地址短缺的问题</p>
</li>
</ol>
<h3 id="PAT"><a href="#PAT" class="headerlink" title="PAT"></a>PAT</h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625162038137.png" alt=""></p>
<ul>
<li>同样的出口IP，用不同的端口号来区别</li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-05-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625162050552.png" alt=""></p>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2023/11/20/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h2 id="会话层-Session"><a href="#会话层-Session" class="headerlink" title="会话层(Session)"></a>会话层(Session)</h2><p>如果用户想要完成一定的数据控制，就会对应在会话层完成</p>
<ul>
<li>TCP控制传输</li>
</ul>
<h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ol>
<li><p>基于令牌进行交互发言，通过数据同步保证数据完整性</p>
</li>
<li><p>进行数据分段、拼接、保证传输的有效</p>
</li>
<li><p>同步技术，保证故障恢复</p>
</li>
</ol>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><ol>
<li><p>同步：</p>
<ul>
<li><p>全双工通信</p>
</li>
<li><p>半双工通信</p>
</li>
<li><p>单工通信</p>
</li>
</ul>
</li>
<li><p>控制：</p>
<ul>
<li><p>会话连接、活动开始、数据校验</p>
</li>
<li><p><strong>令牌转换</strong></p>
</li>
</ul>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20220625162632968.png" alt=""></p>
<p><strong>同步点(CheckPoint)</strong>用于分割对话的各个部分</p>
<ul>
<li><p>同步点：发送一定数据后设置同步点</p>
</li>
<li><p>次同步点：作为同步点的一个子集，进行数据校验</p>
</li>
<li><p>主同步点：按照主同步点进行校验确认</p>
</li>
<li><p><strong>如果错误，恢复到上次已经同步的主同步点</strong></p>
</li>
</ul>
<p><strong>对话分离(Seperation)</strong>是通信的有序启动、终止和管理，尽量保证了通话的效率和可靠性</p>
<h3 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20220625162646725.png" alt=""></p>
<p>客户端-服务器模式(Client-Server)：通过会话实现</p>
<h2 id="表示层-Presentation"><a href="#表示层-Presentation" class="headerlink" title="表示层(Presentation)"></a>表示层(Presentation)</h2><p>负责以<strong>接收设备可以理解</strong>的形式表示数据</p>
<ul>
<li><p>传输语法协商</p>
</li>
<li><p>接受语法协商</p>
</li>
</ul>
<p><strong>协商编码方式可以在会话层中实现</strong></p>
<ul>
<li>解决不同的底层操作系统编码方式不同的问题，以防造成误解</li>
</ul>
<p><strong>主要功能</strong>：</p>
<ul>
<li><p>数据格式化(format)</p>
</li>
<li><p>数据压缩(compression)</p>
</li>
<li><p>数据加密(encryption)</p>
</li>
</ul>
<h3 id="数据格式化"><a href="#数据格式化" class="headerlink" title="数据格式化"></a>数据格式化</h3><p><strong>选择大家都能识别的编码形式传输</strong>，保证大家都能理解</p>
<ul>
<li>提供了不同类型的代码之间的转换</li>
</ul>
<p>数据格式类型：</p>
<ol>
<li><p><strong>图形文件格式：</strong></p>
<ul>
<li><p><strong>图形交换格式GIF</strong>(Graphic Interchange Format)</p>
</li>
<li><p><strong>联合图像专家组JPEG</strong>(Joint Photographic Experts Group)</p>
</li>
</ul>
</li>
<li><p><strong>多媒体文件格式：</strong></p>
</li>
</ol>
<p>多媒体文件格式存储声音、音乐和视频</p>
<h3 id="数据加密与压缩"><a href="#数据加密与压缩" class="headerlink" title="数据加密与压缩"></a>数据加密与压缩</h3><p>数据加密可在信息传输过程中保护信息</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>OSI模型各层对应的一些协议：</p>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20220625162715190.png" alt=""></p>
<ul>
<li><p>第六层对应了各种协议，第七层对应了应用界面</p>
</li>
<li><p>第七层最接近用户，<strong>支持应用程序的通信组件</strong></p>
</li>
</ul>
<h3 id="职责-1"><a href="#职责-1" class="headerlink" title="职责"></a>职责</h3><ul>
<li><p>确定并确定预期的通信合作伙伴的可用性</p>
</li>
<li><p>同步合作的应用程序</p>
</li>
<li><p>同步协作的应用</p>
</li>
<li><p>建立有关错误恢复程序的协议</p>
</li>
<li><p>控制数据完整性</p>
</li>
<li><p><u>通过网络应用为OSI模型的其余部分提供一个直接接口，或是通过独立应用程序提供非直接接口，如<strong>文字处理、电子表格、演示管理器、网络重定向器</strong></u></p>
</li>
</ul>
<h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p>HTTP是<strong>面向事务</strong>(transaction-orient)的客户服务器协议</p>
<p>HTTP 1.0协议是<strong>无状态</strong>的(stateless)</p>
<ul>
<li><p>每一次请求都是独立的，不记录上一次登陆的信息</p>
</li>
<li><p>Cookie是征求同意的存储（<strong>维持登陆状态</strong>）</p>
</li>
</ul>
<p>HTTP协议本身是<strong>无连接</strong>的，虽然它使用了面向连接的TCP向上提供的服务</p>
<p>万维网浏览器就是一个HTTP客户，而在万维网服务器等待HTTP请求的进程称为<strong>HTTP daemon</strong>，也称为<strong>HTTPD</strong></p>
<ul>
<li>HTTP daemon收到HTTP客户的请求后，把所需的文件返回给HTTP客户</li>
</ul>
<h4 id="HTTP报文结构（请求报文）"><a href="#HTTP报文结构（请求报文）" class="headerlink" title="HTTP报文结构（请求报文）"></a>HTTP报文结构（请求报文）</h4><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20230721112122865.png" alt=""></p>
<p>HTTP报文主要由<u>开始行、首部行和实体主体</u>组成</p>
<ul>
<li><p>在请求报文中，开始行就是请求行</p>
</li>
<li><p>请求报文和应答报文的应答结构都是一样的</p>
<ol>
<li><p>2xx：<strong>成功</strong></p>
</li>
<li><p>3xx：<strong>重定向</strong></p>
</li>
<li><p>4xx：<strong>失败</strong></p>
</li>
<li><p>5xx：<strong>服务器内部错误</strong>（不是客户端请求的错误）</p>
</li>
</ol>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>OPTION</td>
<td>请求一些选项的信息</td>
</tr>
<tr>
<td>GET</td>
<td>请求读取由URL所标志的信息</td>
</tr>
<tr>
<td>HEAD</td>
<td>请求读取由URL所标志的信息的首部</td>
</tr>
<tr>
<td>POST</td>
<td>给服务器添加信息</td>
</tr>
<tr>
<td>PUT</td>
<td>在指明的URL下存储一个文档</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除指明的URL所标志的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td>用来进行换回测试的请求报文</td>
</tr>
<tr>
<td>CONNECT</td>
<td>用于代理服务器</td>
</tr>
</tbody>
</table>
</div>
<h4 id="统一资源定位符URL"><a href="#统一资源定位符URL" class="headerlink" title="统一资源定位符URL"></a>统一资源定位符URL</h4><p>URL是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示</p>
<ul>
<li><p><u>URL给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位</u></p>
</li>
<li><p>URL相当于一个文件名在网络范围的拓展，是<strong>与因特网相连的机器上的任何可访问对象的一个指针</strong></p>
</li>
</ul>
<p>URL一般由以下四个部分组成：</p>
<p><strong>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</strong></p>
<ul>
<li><p><strong>协议</strong>：HTTPS或HTTP</p>
</li>
<li><p><strong>主机</strong>：域名的方式</p>
</li>
<li><p><strong>端口</strong>：对应进程</p>
</li>
<li><p><strong>路径</strong>：对应具体的文件</p>
</li>
</ul>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML文档是一种可以用任何文本编辑器创建的<strong>ASCII码文件</strong></p>
<ul>
<li><p><strong>HTML用一对标签或几对标签来标识一个元素</strong></p>
<ul>
<li>浏览器针对各种标签，根据所使用的显示器的尺寸和分辨率大小，重新排版并会付出所读取的页面</li>
</ul>
</li>
</ul>
<h3 id="FTP和TFTP"><a href="#FTP和TFTP" class="headerlink" title="FTP和TFTP"></a>FTP和TFTP</h3><p>FTP是一种<strong>可靠的、面向连接的</strong>服务，使用TCP传输文件</p>
<ol>
<li><p>FTP首先在客户端和服务器（<strong>端口21</strong>）之间建立<strong>控制连接</strong></p>
</li>
<li><p>然后建立计算机之间用于传输数据的连接（<strong>端口20</strong>）</p>
</li>
</ol>
<p>TFTP是使用UDP的<strong>无连接</strong>服务</p>
<ol>
<li><p><strong>不支持交互，没有目录浏览功能</strong></p>
</li>
<li><p>体积小，易于实施，更加方便</p>
</li>
<li><p>TFTP在路由器上用于传输配置文件和Cisco IOS镜像</p>
</li>
</ol>
<h4 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h4><ol>
<li>打开<strong>熟知端口21</strong>，使客户进程连接上</li>
</ol>
<ul>
<li>可以修改熟知端口</li>
</ul>
<ol>
<li><p>等待客户进程发出连接请求</p>
</li>
<li><p>启动从属进程来处理客户进程发来的请求</p>
<ul>
<li><p><strong>处理完毕就终止</strong></p>
</li>
<li><p>运行期间可能根据需要创建一些其他子进程</p>
<ul>
<li>主进程和从属进程的处理是<strong>并发</strong>的</li>
</ul>
<ol>
<li><p><strong>控制连接</strong></p>
</li>
<li><p><strong>数据连接</strong></p>
<ul>
<li>需要建立上面两个连接才能完成传输</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>回到等待状态，继续接受其他客户进程发来的请求</p>
</li>
</ol>
<h3 id="Telnet协议"><a href="#Telnet协议" class="headerlink" title="Telnet协议"></a>Telnet协议</h3><p>Telnet客户端软件提供了登录到运行Telnet服务器应用程序的远程Internet主机，然后从命令行执行命令的功能</p>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20220625162752578.png" alt=""></p>
<ul>
<li><p>输入参数，达成一致，对服务器进行操作</p>
</li>
<li><p>不同操作系统之间的快捷键和指令是有差异的，需要进行转换</p>
</li>
</ul>
<h3 id="SMTP和POP（电子邮件）"><a href="#SMTP和POP（电子邮件）" class="headerlink" title="SMTP和POP（电子邮件）"></a>SMTP和POP（电子邮件）</h3><p>电子邮件服务器使用<strong>SMTP发送和POP接收</strong>邮件相互通信</p>
<ul>
<li>发送者先登录到服务器，通过服务器根据 SMTP 传输到对应的服务器，然后用户登录后通过 POP3 协议收邮件到本地</li>
</ul>
<p><strong>SMTP</strong>(Simple Mail Transfer Protocol)：邮件发送、登陆发送等</p>
<p><strong>POP3</strong>(Post Office Protocol version 3)：邮件接收</p>
<ul>
<li>邮件到达邮件服务端，由客户端和服务端联系接收邮件</li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20220625162836882.png" alt=""></p>
<h4 id="MIME和SMTP"><a href="#MIME和SMTP" class="headerlink" title="MIME和SMTP"></a>MIME和SMTP</h4><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20220625162849543.png" alt=""></p>
<p>很多文件并不是ASCII码的，需要用MIME进行转换（扩充）</p>
<ul>
<li>MIME标准扩充了SMTP标准</li>
</ul>
<p><strong>MIME增加五个新的邮件首部</strong>：</p>
<ol>
<li><p>MIME-version：标志MIME的版本</p>
</li>
<li><p>Contenet-Description：可读字符串，说明此邮件主体是否是图像、音频或视频</p>
</li>
<li><p>Content-Id：邮件的唯一标识符</p>
</li>
<li><p>Content-Transfer-Encoding：在传送时邮件的主体是如何编码的</p>
</li>
<li><p>Content-Type：说明邮件主体的数据类型和子类型</p>
</li>
</ol>
<h3 id="简单网络管理协议SNMP"><a href="#简单网络管理协议SNMP" class="headerlink" title="简单网络管理协议SNMP"></a>简单网络管理协议SNMP</h3><p><strong>SNMP可简化网络设备之间的管理信息交换</strong></p>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20220625162901604.png" alt=""></p>
<ul>
<li><p><strong>网络管理系统NMS</strong>：通过下发请求对上网的所有主机关于流量等信息进行管理</p>
</li>
<li><p>通过管理数据库MIB进行交流</p>
</li>
<li><p><strong>使用UDP通过广播进行实现</strong></p>
</li>
</ul>
<h3 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h3><p>DNS管理域名并相应客户端<strong>将域名转换为关联IP地址</strong>的请求</p>
<h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20220625162924862.png" alt=""></p>
<ul>
<li><p>使用<code>.</code>将字符串进行分割</p>
</li>
<li><p><strong>越靠后域名级别越高</strong></p>
</li>
<li><p>www 对应到主机群</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>域名</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>国家</td>
<td>.cn</td>
<td>中国</td>
</tr>
<tr>
<td></td>
<td>.us</td>
<td>美国</td>
</tr>
<tr>
<td></td>
<td>.uk</td>
<td>英国</td>
</tr>
<tr>
<td>通用</td>
<td>.com</td>
<td>企业和公司</td>
</tr>
<tr>
<td></td>
<td>.net</td>
<td>网络服务提供商</td>
</tr>
<tr>
<td></td>
<td>,org</td>
<td>非盈利组织</td>
</tr>
<tr>
<td></td>
<td>.edu</td>
<td>教育机构</td>
</tr>
<tr>
<td></td>
<td>.gov</td>
<td>政府</td>
</tr>
<tr>
<td></td>
<td>.mil</td>
<td>军方</td>
</tr>
<tr>
<td></td>
<td>.int</td>
<td>国际组织</td>
</tr>
<tr>
<td>基础设施领域</td>
<td>arpa</td>
<td>用于反向解析域名</td>
</tr>
<tr>
<td>Recently</td>
<td>.aero</td>
<td>航空运输企业</td>
</tr>
<tr>
<td></td>
<td>.biz</td>
<td>公司和企业</td>
</tr>
<tr>
<td></td>
<td>.travel</td>
<td>旅游业</td>
</tr>
<tr>
<td></td>
<td>.jobs</td>
<td>人力资源管理者</td>
</tr>
<tr>
<td></td>
<td>.museum</td>
<td>博物馆</td>
</tr>
<tr>
<td></td>
<td>.info</td>
<td>各种资讯</td>
</tr>
</tbody>
</table>
</div>
<p>顶级域名底下的域名<strong>由顶级域名进行管理</strong></p>
<p>跟域名服务器存储位置，所以<strong>子服务器知道跟服务器地址就行</strong></p>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20220625162936895.png" alt=""></p>
<h4 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h4><p>DNS系统以<strong>层次</strong>结构设置，该层级结构创建不同级别的DNS服务器</p>
<p>次级别的DNS服务器判断其自身能否将域名转换为IP地址</p>
<ul>
<li><p>如果不行，将请求发送到更高级别</p>
</li>
<li><p>如果可以，将结果返回给服务端</p>
</li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-06-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%A1%A8%E7%A4%BA%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82/image-20230716093300053.png" alt=""></p>
<h3 id="沟通方式"><a href="#沟通方式" class="headerlink" title="沟通方式"></a>沟通方式</h3><ol>
<li><p>无上下文：</p>
<ul>
<li>当浏览器打开时，将连接到默认页面，并且将页面的文件传输到客户端，<strong>处理完成后连接断开</strong></li>
</ul>
</li>
<li><p>有上下文：</p>
<ul>
<li>作为Telnet和FTP，建立与服务器的连接并保持该链接，直到执行所有处理，<strong>确定都完成后才断开连接</strong></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2023/10/26/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的特性：</p>
<ol>
<li><strong>机械特性</strong>：指明接口所用的接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</li>
<li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的<strong>电压</strong>的范围</li>
<li><strong>功能特性</strong>：指明某条线上出现的某一电平的<strong>电压</strong>的意义</li>
<li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序</li>
</ol>
<p>数据在计算机内部多采用并行传输方式，但在通信线路上一般都是<strong>串行传输</strong>(经济因素)，即逐个比特按照时间顺序传输</p>
<h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><p>数据通信系统可划分为三个部分：<strong>源系统</strong>、<strong>传输系统</strong>、<strong>目的系统</strong></p>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.6349DelfGpekAnkd9XPNUQAAAA?w=310&amp;h=155&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="数据通信系统模型 的图像结果"></p>
<p>源系统一般分为两个部分：</p>
<ul>
<li><strong>源点</strong>(source)：源点设备产生要传输的数据</li>
<li><strong>发送器</strong>：通常源点生成的数字比特流要通过发送器编码后才能在传输系统中进行传输，典型的发送器是<strong>调节器</strong></li>
</ul>
<p>目的系统一般也分为两个部分：</p>
<ul>
<li><strong>接收器</strong>：接受传输系统传送过来的信号，并<u>把它转换为能够被目的设备处理的信息</u></li>
<li><strong>终点</strong>(destination)：从接收器获取传送来的数字比特流，然后把信息输出</li>
</ul>
<p>模拟信号是连续的，数字信号是离散的<br>代表不同离散数值的基本波形成为<strong>码元</strong></p>
<ul>
<li>一个码元携带的信息量<strong>不固定</strong>，由调制方式和编码方式决定</li>
</ul>
<p>从通信的双方信息交互方式来看，有以下三种基本方式:</p>
<ol>
<li><strong>单工通信</strong>：只能由一个方向的通信而没有反方向的交互</li>
<li><strong>半双工通信</strong>：通信的双方都可以发送信息，但不能同时发送</li>
<li><strong>全双工通信</strong>：通信的双方可以同时发送和接收信息</li>
</ol>
<p>来自信源的信号成为<strong>基带信号</strong>，必须进行<strong>调制</strong><br>调制可分为两大类：</p>
<ul>
<li><strong>基带调制</strong>：仅仅对基带信号的波形进行变化<ul>
<li>这是把数字信号转换为另一种数字信号，因此成为<strong>编码</strong></li>
</ul>
</li>
<li><strong>带通调制</strong>：使用<strong>载波</strong>(carrier)进行调制，把基带信号的频率范围搬移到较高的频段，并<u>转换为模拟信号</u><ul>
<li>经过调制的信号成为<strong>带通信号</strong></li>
</ul>
</li>
</ul>
<h3 id="编码和调制"><a href="#编码和调制" class="headerlink" title="编码和调制"></a>编码和调制</h3><p>常用编码方式如图<br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.uBw4xIfFNVIif77JCPqMaQHaEF?pid=ImgDet&amp;rs=1" alt="计算机网络学习【入门】——（二）物理层_Leon595的博客-CSDN博客"></p>
<ul>
<li><strong>不归零制</strong>：正电平代表1，负电平代表0</li>
<li><strong>归零制</strong>：正脉冲代表1，负脉冲代表0</li>
<li><strong>曼彻斯特编码</strong>：位周期中心的向上跳变代表0，向下跳变代表1</li>
<li><strong>差分曼彻斯特编码</strong>：每一位的中心处始终有跳变，位开始边界有跳变为0，没有跳变为1</li>
</ul>
<p>从信号波形来看，曼彻斯特编码产生的信号频率比不归零制高<br>从自身同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率</p>
<ul>
<li><strong>曼彻斯特编码具有自同步能力</strong></li>
</ul>
<p>基本的带通调制方法如图<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.zOwL4AlFv9KhZvfPZOsHzwAAAA?w=298&amp;h=149&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="最基本的三种调制方法 的图像结果"></p>
<ul>
<li><strong>调幅</strong>(AM)：载波的振幅随基带数字信号而变化</li>
<li><strong>调频</strong>(FM)：载波的频率随基带数字信号而变化</li>
<li><strong>调相</strong>(PM)：载波二点初始相位随基带数字信号而变化</li>
</ul>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>码元传输速率越高，信号传输距离越远，噪声干扰越大，传输媒体质量越差，在接收端的波形失真就越严重<br><img src="https://picture-pool.oss-cn-beijing.aliyuncs.com/006tNc79gy1g2w7as7a6oj30y00ak0uh.jpg" alt="计算机网络第二弹——物理层_信道和通信电路_ai-exception的博客-CSDN博客"></p>
<p>限制码元在信道上传输速率的因素：</p>
<ol>
<li><p><strong>信道能够通过的频率范围</strong></p>
<p> <strong>码间串扰</strong>：信号中的高频分量在传输时收到衰减，那么在接收端收到的波形前沿和后沿就变得不那么陡峭了，收到的信号波形就失去了码元之间的清晰界限</p>
<p> 为避免码间串扰，奈奎斯特(Nyquist)提出了<strong>奈氏准则</strong>，给出了在假定的理想条件下，<u><strong>码元的传输速率的上限值</strong></u></p>
<p> <strong>奈氏准则</strong>:理想低通信道下的极限数据传输率 = 2W$\log_2V$(b/s)</p>
<ul>
<li>其中W是<strong>理想低通信道的带宽</strong>(Hz), V表示每个码元离散电平的数目(<strong>有多少种不同的码元</strong>)</li>
</ul>
</li>
</ol>
<ol>
<li><p><strong>信噪比</strong><br> 信噪比就是信号的平均功率和噪声的平均功率之比，常记为<strong>S/N</strong>,并用分贝(dB)作为度量单位</p>
<ul>
<li><p>信噪比(dB) = $10log_{10} (S/N)$(dB)</p>
<p>信息论的创始人香农(shannon)推导出了<strong>香农公式</strong>，推导出信道的极限传输速率</p>
<p><strong>香农公式</strong>:C = W$log_2(1 + S/N)$（bit/s）</p>
</li>
<li><p>其中W为信道的带宽(Hz)， S为信道内锁传信号的平均功率，N为信道内部高斯噪声的功率</p>
<p>香农公式表明，<strong>信道的带宽或信道中的信噪比越大，信道的极限传输速率就越高</strong></p>
<p>可以通过编码的方式<strong>让每一个码元携带更多比特的信息量</strong>，以提高信息传输速率</p>
</li>
</ul>
</li>
</ol>
<h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><p>传输媒体可以分为<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p>
<ul>
<li>在非导引型传输媒体中电磁波的传输常称为无线传输</li>
</ul>
<h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><ol>
<li><strong>双绞线</strong>/<del>双扭线</del><br>把两根互相绝缘的铜导线并排放在一起，然后用规则的方法<strong>绞合</strong>(twist)起来就构成了双绞线</li>
</ol>
<p>模拟传输和数字传输都可以使用双绞线</p>
<p><u>为了提高双绞线抗电磁干扰的能力</u>，可以在双绞线外面再加上一层由金属丝编制成的屏蔽层，也就是<strong>屏蔽双绞线STP</strong>(Shielded Twisted Pair)，价格也比<strong>无屏蔽双绞线UTP</strong>贵(Unshielded Twisted Pair)</p>
<ul>
<li>聚氯乙烯套层 -&gt; （屏蔽层）-&gt; 绝缘层 - &gt; 铜线</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>绞合线类型</th>
<th>带宽</th>
<th>线缆特点</th>
<th>典型应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>16MHz</td>
<td>2对4芯双绞线</td>
<td>模拟电话，曾用于传统以太网(10Mbit/s)</td>
</tr>
<tr>
<td>4</td>
<td>20MHz</td>
<td>4对8芯双绞线</td>
<td>曾用于令牌局域网</td>
</tr>
<tr>
<td>5</td>
<td>100MHz</td>
<td>与4类相比增加了绞合度</td>
<td>传输速率不超过100Mbit/s的应用</td>
</tr>
<tr>
<td>5E(超5类)</td>
<td>125MHz</td>
<td>与5类相比衰减更小</td>
<td>传输速率不超过1Gbit/s的应用</td>
</tr>
<tr>
<td>6</td>
<td>250MHz</td>
<td>与5类相比改善了串扰等性能</td>
<td>传输速率高于1Gbit/s的应用</td>
</tr>
<tr>
<td>7</td>
<td>600MHz</td>
<td>使用屏蔽双绞线</td>
<td>传输速率不超过10Gbit/s的应用</td>
</tr>
</tbody>
</table>
</div>
<p>现在最常用的是5类线</p>
<ol>
<li><p><strong>同轴电缆</strong><br>同轴电缆由<u>内导体铜质导线（单股实心线或多股绞合线）、绝缘层、网状编织的外导体屏蔽层（也可以是单股的）以及保护塑料外层组成</u></p>
<p> 同轴电缆具有很好的抗干扰性，被广泛用于传输较高速率的数据</p>
<p> <img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.rlPy1N6-xI5h52Z3udFQTAHaDk?w=279&amp;h=168&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="同轴电缆结构 的图像结果"></p>
<p> 同轴电缆的带宽取决于电缆的质量，目前高质量的同轴电缆带宽已接近1GHz</p>
</li>
<li><p><strong>光缆</strong><br>光纤通信就是<strong>利用光导纤维传递光脉冲来进行通信</strong></p>
<ul>
<li><p>一个光纤系统的传输带宽远远大于目前其他各种传输媒体的带宽</p>
<p><strong>光纤</strong>是光纤通信的传输媒体</p>
<p><img src="https://pic4.zhimg.com/v2-016fc73f89c05c21da715e04c47ef50e_r.jpg" alt="光纤通信--光纤的结构及分类 - 知乎"></p>
<p>从纤芯中射到纤芯表面的光线的<strong>入射角大于某个临界角度</strong>，就可产生全反射</p>
<p><strong>多模光纤</strong>：存在多条不同角度入射的光线在一条光纤中传输<br><strong>单模光纤</strong>：光纤的直径减少到只有一个光的波长，使光纤一直向前传播，而不会发生多次反射</p>
<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.3jq4e5woHaz5SSysAh4X6gHaDd?w=349&amp;h=163&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="单模光纤和多模光纤的比较 的图像结果"></p>
<p>光纤非常细，必须做成很结实的光缆<br><img src="https://pic4.zhimg.com/v2-0811f0893ef97928616f36ad9b77ef9d_r.jpg" alt="通信用特种光缆的结构特点及应用场景 - 知乎"></p>
</li>
</ul>
</li>
</ol>
<p>光纤不仅具有<strong>通信容量非常大</strong>的优点，而且还有一些其他的特点：</p>
<ul>
<li><strong>传输损耗小，中继距离长，对远距离传输特别经济</strong></li>
<li><strong>抗雷电和电磁干扰性能好</strong></li>
<li><strong>无串音干扰，保密性好</strong></li>
<li><strong>体积小，重量轻</strong></li>
</ul>
<h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><p><strong>低频LF</strong>：30kHz ~ 300kHz<br><strong>中频MF</strong>：300kHz ~ 3MHz<br><strong>高频HF</strong> ：3MHz ~ 30MHz</p>
<p>传统的微波通信主要有两种形式：</p>
<ol>
<li><strong>地面微波接力通信</strong> ：需要中继器将信号放大，可传输电话、电报、图像、数据等信息<ul>
<li>微波波段频率很高，其频带范围也很宽，因此通信信道容量很大（<u>卫星通信也是</u>）</li>
</ul>
</li>
<li><strong>卫星通信</strong><br>最大特点是<strong>通信距离远，通信费用与通信距离无关</strong>，但是<u>具有较大的传播时延</u></li>
</ol>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>复用是通信技术中的基本概念<br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.RydtLD2-K6MuvBoPl_xfMAHaD7?w=320&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="频分复用示意图 的图像结果"></p>
<p>最基本的复用就是<strong>频分复用FDM</strong>(Frequency Division Multiplexing)和<strong>时分复用TDM</strong>(Time Division Multiplexing)</p>
<p>频分复用的所有用户<strong>在同样的时间内占用不同的带宽资源</strong></p>
<ul>
<li>这里的带宽指的是频率带宽而不是数据的发送速率</li>
</ul>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.wvj4XDg1aWNnVs78I99GKgHaEv?w=275&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="频分复用示意图 的图像结果"></p>
<p>时分复用把时间划分成一段段等长的<strong>时分复用帧(TDM帧)</strong></p>
<ul>
<li>TDM信号也称为等时信号</li>
</ul>
<p>时分复用的所有用户<strong>在不同的时间占用同样的频带宽度</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.YAE6Nth5Kqhl5j6p9iKF3AAAAA?w=244&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="时分复用示意图 的图像结果"></p>
<p>当用户暂时无数据发送时，在时分复用帧中分配给该用户的时隙只能处于空闲状态，这会导致复用后信道利用率不高<br><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.cRgewliFh4GaK0N7yHWK7gAAAA?pid=ImgDet&amp;rs=1" alt="现代通信技术之交换技术基础_Leslie_Waong的博客-CSDN博客"></p>
<p>复用器和分用器总是成对使用，两者之间是用户共享的高速信道</p>
<p><strong>统计时分复用STDM</strong>(Statistic TDM)<br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.M6aX1Sh1rfNXXjwKwpSmbQHaDZ?pid=ImgDet&amp;rs=1" alt="【计算机网络】信道复用技术_diligentyang的博客-CSDN博客"><br>STDM帧不是固定分配时隙，而是<strong>按需动态分配时隙</strong></p>
<ul>
<li>一个用户所占用的时隙并不是周期性地出现，因此又称为<strong>异步时分复用</strong></li>
</ul>
<p><strong>波分复用WDM</strong>(Wavelength Division Multiplexing)就是光的频分复用</p>
<ul>
<li>现在已经能在一根光纤上复用几十路甚至更多路数的光载波信号，于是使用了<strong>密集波分复用DWDM</strong>(Dense Wavelength Division Multiplexing)这一名词</li>
</ul>
<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.WZZa3GJsMhJwwq9Rp5MUrAHaEC?w=320&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="波分复用示意图 的图像结果"><br>波分复用的复用器可称为<strong>合波器</strong>，解复用器（分用器）又称为<strong>分波器</strong></p>
<p><strong>码分复用CDM</strong>(Code Division Multiplexing)是一种共享信道的方法，其实人们更常用的名词是<strong>码分多址CDMA</strong>(Code Division Multiple Access),每一个用户可以在同样的时间使用同样的频带进行通信</p>
<p>在CDMA中，每一个比特时间再划分为m个短的间隙，成为<strong>码片(chip)</strong>,通常m的值是64或128</p>
<p>了实现多用户同时通信而互补干扰，要求每个发送信号的站都使用不同的<strong>码片</strong>，也就是说使用CDMA的<strong>每一个站都被指派了一个唯一的mbit的码片序列</strong></p>
<blockquote>
<p>一个站如果要发送比特1，则发送他自己的mbit码片序列<br> 一个站如果要发送比特0，则发送自己的mbit码片序列的反码</p>
</blockquote>
<p>为了方便，我们按惯例将码片序列中的0写为-1，将1写为+1，这种通信方法称为<strong>直接序列扩频DSSS</strong>(Dienct Sequence Spread spectrum)</p>
<p>对于码片的挑选有以下原则：</p>
<ol>
<li><strong>分配给每个站的码片序列必须各不相同</strong></li>
<li><strong>分配给每个站的码片序列必须相互正交（规格化内积为零）</strong></li>
</ol>
<p>规格化内积计算公式：$S \cdot T = \frac{1}{m}\sum_{i = 1}^m{S_iT_i}=0$</p>
<ol>
<li><strong>任何一个码片向量和自己的码片反码的向量的内积为-1</strong></li>
<li><strong>任何一个码片向量和自己的码片向量的内积为1</strong></li>
</ol>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2023/10/29/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据链路层使用的信道主要有以下两种类型：</p>
<ol>
<li><strong>点对点信道</strong>：一对一的点对点通信方式</li>
<li><strong>广播信道</strong>一对多的广播通信方式</li>
</ol>
<p>这两种信道使用的协议为<strong>PPP协议</strong>和<strong>CSMA/CD协议</strong></p>
<p>数据链路层三个功能：<strong>封装成帧、透明传输、差错检测</strong></p>
<p>当主机$H_1$向主机$H_2$发送数据时，我们可以想象数据就是再数据链路层从左向右沿左向右水平方向传送的：<br><strong>$H_ 1$的链路层 -&gt; $R_ 1$的链路层 -&gt; $R_2$的链路层 -&gt; $R_3$的链路层 -&gt; $H_1$的链路层</strong><br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.lYRXS3JdKalAmA3M9O9OoQHaDt?w=348&amp;h=175&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="数据链路层的地位 的图像结果"></p>
<h2 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><p><strong>链路</strong>(link)：从一个结点到<strong>相邻节点</strong>的一段物理线路（有线或无线），而中间没有任何其他的交换节点</p>
<p><strong>数据链路</strong>(data link)：链路加上一些必要的通信协议(<u>控制数据的传输</u>)</p>
<ul>
<li>现在最常用的是使用<strong>网络适配器</strong>（既有硬件也有软件）来实现这些协议，一般的适配器都包括了数据链路层和物理层的功能</li>
</ul>
<p>数据链路层的协议数据单元——<strong>帧</strong></p>
<ul>
<li>数据链路层把网络层交下来的数据构成帧发送到链路上，以及把接受到的帧中的数据取出并上交给网络层</li>
</ul>
<p>点对点信道的数据链路层在进行通信时的主要步骤如下：</p>
<ol>
<li><u>结点A的数据链路层要把网络层交下来的IP数据报添加首部</u></li>
<li><u>结点A把封装好的帧发送给结点B的数据链路层</u></li>
<li><u>若结点B的数据链路层收到的帧无差错，则从收到的帧中提取出IP数据报交给上面的网络层，否则丢弃这个帧</u><br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.FSA9z3YLQT79p6lCaw_lPgHaEX?w=295&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="使用点对点信道的数据链路层 的图像结果"></li>
</ol>
<h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><ol>
<li><p><strong>封装成帧</strong>：<br> 封装成帧就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。网络层的IP数据报传到数据链路层就成为帧的<strong>数据部分</strong><br> 一个帧的帧长等于<u>数据部分长度加上帧首部和帧尾部的长度</u></p>
<p> 首部和尾部的一个重要功能就是<strong>帧定界</strong>（确定帧的界限）<br> 首部和尾部还包括许多必要的控制信息</p>
<p> 每一种链路层协议都规定了所能传送的帧的<strong>数据部分长度上限</strong>——<strong>最大传送单元MTU</strong>(Maximum Transfer Unit)<br> <img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.msK6UD4rQsWyCTVkiEEPbgHaC_?w=334&amp;h=141&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="用帧首部和帧尾部封装成帧 的图像结果"></p>
<p> 帧定界可以使用特殊的<strong>帧定界符</strong><br><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.E8a37k54Ab-IW_XGc2hvRAHaBx?w=343&amp;h=83&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="用控制字符进行帧定界 的图像结果"></p>
<ul>
<li>控制字符SOH(Start Of Header)放在帧的最前面，表示帧的首部开始，十六进制编码为01（二进制是00000001）</li>
<li>控制字符EOT(End Of Transmission)表示帧的结束，十六进制编码为04（二进制是00000100）</li>
</ul>
</li>
<li><p><strong>透明传输</strong><br>当传送的帧是用文本文件组成的帧时（文本文件中的字符都是从键盘上输入的），其数据部分显然<strong>不会出现SOH或EOT这样的帧定界控制字符</strong>，可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输</p>
<ul>
<li><p>非ASCII码的文本文件如果某个字节的二进制代码恰好和SOH或EOT这种控制字符一样，数据链路层就会<strong>错误地找到帧的边界</strong>，把部分帧收下，把剩下的部分丢弃，这就不是透明传输</p>
<p><strong>透明</strong>：<u>某一个实际存在的事物看起来却好像不存在一样</u>（比如玻璃）</p>
</li>
<li><p>在“数据链路层透明传输数据”表示<u>无论什么样的比特组合地数据，都能按照原样没有差错地通过</u></p>
<p><strong>字节填充</strong>(byte stuffing)/<strong>字符填充</strong>(character stuffing)：发送端的数据链路层在数据部分出现控制字符SOH或EOT时，会在前面插入<strong>转义字符”ESC“</strong>（十六进制编码是1B，二进制是00011011），接收端发送往网络层时再删除<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.gQpEtOXenVmtX5USoO88EgHaCa?w=345&amp;h=114&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="字节填充法解决透明传输的问题 的图像结果"></p>
</li>
</ul>
</li>
<li><p><strong>差错检测</strong></p>
<p> <strong>比特差错</strong>：比特在传输过程发生差错，如1变为0，0变为1</p>
<p> <strong>误码率BER</strong>(Bit Error Rate)：在一段时间内，传输错误的比特占所传输比特总数的比率</p>
<p> 数据链路层广泛使用了<strong>循环冗余检测CRC</strong>(Cyclic Redundancy Check)的检错技术</p>
<ul>
<li><p><strong>模2运算</strong>：进行加法和减法都不进位</p>
<p><strong>循环冗余检测CRC计算</strong>：<u>假定数据M有k个比特，CRC运算就是在数据M后面添加供差错检测用的n位<strong>冗余码</strong>，然后构成一个帧发出去，一共发送(k + n)位</u></p>
<p><strong>n位冗余码获得方式</strong>：在M后面加上n个0，得到的(n + k)位的数初一事先商定的(n + 1)位除数P，得出商是Q而余数是R（n位），这个余数R就作为冗余码拼接在数据M后面发送出去,也就是<strong>发送(k + n)位的CRC码</strong></p>
</li>
<li><p>这种冗余码称作<strong>帧检验序列FCS</strong>(Frame Check Sequence)</p>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.VX98Rc7ifinwUBusCIfxwQAAAA?w=265&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="循环冗余检验 的图像结果"></p>
<p>接收端把收到的数据进行CRC检验：把收到的每一个帧除以相同的除数P（模2运算），然后检查得到的余数R</p>
</li>
<li>R = 0则判定没有差错，接收</li>
<li><p>R $\ne$ 0则出现差错（<u>无法确定具体位置</u>），丢弃</p>
<p>我们并没有要求数据链路层提供可靠传输的服务，也就是说，数据链路层只能做到<strong>凡是在接收端数据链路层接受的帧均无差错</strong></p>
</li>
<li><p>可靠传输：<u>发送端发送什么，在接收端就收到什么</u></p>
<p>除了比特差错，传输差错还有一类更加复杂的情况，那就是出现了<strong>帧丢失、帧重复、帧失序</strong></p>
</li>
</ul>
</li>
</ol>
<h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><p>我们知道，互联网用户通常要连接到某个ISP才能接入互联网，PPP协议就是<u>用户计算机与ISP进行通信时所使用的数据链路层协议</u></p>
<p><strong>点对点协议PPP</strong>(Point-to-Point Protocol)是目前使用的最广泛的数据链路层协议<br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.MzAgwHdvJT8QD4HBsy01VwHaCg?w=350&amp;h=118&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="用户到ISP的链路使用PPP协议 的图像结果"></p>
<p>PPP协议应满足的需求：</p>
<ul>
<li><strong>简单</strong>：对于数据链路层的帧，不需要纠错，不需要序号，也不要流量控制。简单的设计可以使协议在实现时不容易出错，从而使不同厂商在协议的不同实现上的<strong>互操作性提高了</strong><ul>
<li>协议标准化的一个主要目的就是提高协议的互操作性</li>
</ul>
</li>
<li><strong>封装成帧</strong>：必须规定特殊的字符作为<strong>帧界定符</strong></li>
<li><strong>透明性</strong>：必须保证数据传输的透明性</li>
<li><strong>多种网络层协议</strong>：必须能够在同一条物理链路上同时支持多种网络层协议</li>
<li><strong>多种类型链路</strong>：比如串行的或并行的，同步的或异步的</li>
<li><strong>差错检测</strong>：必须能够对接收端收到的帧进行检测，并<strong>立即丢弃有差错的帧</strong></li>
<li><strong>检测连接状态</strong>：必须有一种机制能够及时自动检测出链路是否处于正常工作状态</li>
<li><strong>最大传输单元</strong>：必须对每一种类型的点对点链路<strong>设置最大传送单元MTU的默认值</strong></li>
<li><strong>网络层地址协商</strong>：必须提供一种机制使通信的两个网络层的实体能够通过协商知道或者能够配置彼此的网络层地址</li>
<li><strong>数据压缩协商</strong>：必须提供一种方法来协商使用数据压缩算法</li>
</ul>
<blockquote>
<p>PPP协议不支持多点线路，支支持点对点的链路通信<br>PPP协议只支持全双工链路</p>
</blockquote>
<h3 id="PPP协议的帧格式"><a href="#PPP协议的帧格式" class="headerlink" title="PPP协议的帧格式"></a>PPP协议的帧格式</h3><p>PPP帧的首部和尾部分别为四个字段和两个字段</p>
<ul>
<li>首部第一个字段和尾部第二个字段都是标志字符F(Flag)，规定<strong>为0x7E，表示一个帧的开始或结束</strong>，即PPP帧的定界符</li>
</ul>
<p>连续两帧之间<strong>只需要一个标识字段</strong>，如果出现连续两个标志字段，就表示这是一个空帧，应当丢弃</p>
<p>首部中的地址字符A(0xFF)和控制字符C(0x03)实际上并没有携带PPP帧的信息</p>
<p>首部的第四个字段是2字节的协议字段</p>
<ul>
<li><u>当协议字段为0x0021时，PPP帧的信息字段就是IP数据报</u></li>
<li><u>当协议字段为0xC021时，信息字段是PPP链路控制协议LCP的数据</u></li>
<li><u>当协议字段是0x8021时，表示这是网络层的控制数据</u></li>
</ul>
<p>MTU的默认值是1500字节，在RFC 1661中，MTU叫做<strong>最大接收单元MRU</strong>(Maximum Recieve Unit)</p>
<p>信息字段的长度是可变的，不超过1500字节</p>
<p>尾部第一个字段是使用CRC帧检验序列的FCS</p>
<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.AOydHBJ9z6kcaGRAocfRzwHaDY?w=320&amp;h=159&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="PPP帧的格式 的图像结果"></p>
<p>当PPP使用异步传输时，它把转义字符定义为0x7D，并使用<strong>字节填充</strong></p>
<ul>
<li>把信息字段中出现的每一个0x7E字节转变成为2字节序列(0x7D,0x5E)</li>
<li>若信息字段中出现一个0x7D的字节，则把0x7D转变为2字节序列(0x7D,0x5E)</li>
<li>若信息字段中出现ASCII码的控制字符，则在该字符前面要加入一个0x7D字节，同时将该字符的编码加以改变</li>
</ul>
<p>PPP协议用在SONET/SOH链路时，使用<strong>同步传输</strong>（一连串的比特连续传送）而不是异步传输（逐个字符地发送）</p>
<ul>
<li>在这种情况况下，PPP协议采用<strong>零比特填充</strong>方法来实现透明传输</li>
</ul>
<p><strong>零比特填充法</strong>：在发送端先扫面整个信息字段，发现5个连续的1就立即填入一个0</p>
<h3 id="PPP协议的工作状态"><a href="#PPP协议的工作状态" class="headerlink" title="PPP协议的工作状态"></a>PPP协议的工作状态</h3><ol>
<li><p>PPP链路的其实和终止状态永远是<strong>“链路禁止”</strong>(Link Dead)状态</p>
<ul>
<li>这时在用户个人电脑和ISP的路由器之间并不存在物理层的连接</li>
</ul>
</li>
<li><p>在双方建立了物理层连接后，PPP就进入<strong>“链路建立”</strong>(Link Establish</p>
<ul>
<li><p>其目的是建立链路层LCP连接</p>
<p>LCP开始协商一些配置选项，即发送LCP的<strong>配置请求帧</strong>(Configure-Request)</p>
</li>
<li><p>这是一个PPP帧，其协议字段为LCP对应的代码，而信息字段包含特定的配置请求</p>
<ol>
<li><strong>配置确认帧</strong>(Configure-Ack)：所有选项都能接受</li>
<li><strong>配置否认帧</strong>(Configure-Nak)：所有选项都理解但是不能接受</li>
<li><strong>配置拒绝帧</strong>(Configure-Reject)：选项有的无法识别或不能接受，需要协商<br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.P1WaX227ef6MllYT0YL1EgHaFL?w=232&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="PPP协议的状态图 的图像结果"></li>
</ol>
<p>LCP配置选项包括<u>链路上的最大帧长、所使用的<strong>鉴别协议</strong>(authentication protocol)的规约，以及不使用PPP帧中的地址和控制字段</u></p>
</li>
</ul>
</li>
<li><p>协商完之后双方就建立了LCP链路，接着就进入<strong>鉴别</strong>(Authenticate)状态，这一状态只允许传送<strong>LCP协议的分组、鉴别协议的分组以及监测链路质量的分组</strong></p>
<ul>
<li><strong>口令鉴别协议PAP</strong>(Passward Authentication Protocol)：需要发起通信的乙方发送身份标识符和口令，允许用户重试若干次</li>
<li><strong>口令握手鉴别协议CHAP</strong>(Challenge-Handshake Authentication Protocol)：更加复杂，更有安全性</li>
</ul>
</li>
<li><p>鉴别身份失败则到<strong>链路终止</strong>(Link Terminate)状态，鉴别成功则进入<strong>网络层协议</strong>(Network-Layer Protocol)状态</p>
<p> 在<strong>网络层协议</strong>状态，PPP链路的两端的网络控制协议NCP根据网络层的不同协议互相交换网络层特定的网络控制分组。总之，PPP协议两端的网络层可以运行不同的网络层协议，但仍可以使用同一个PPP协议进行通信</p>
<p> 如果在PPP链路上运行的是IP协议，则对PPP链路的每一端配置IP协议模块时就要使用NCP中支持IP的协议——<strong>IP控制协议IPCP</strong>(IP Control Protocol)</p>
<ul>
<li>IPCP分组也封装成PPP帧(其中协议字段为0x8021)在PPP链路上传送</li>
</ul>
</li>
<li><p>当网络层配置完毕后，链路进入<strong>链路打开</strong>(Link Open)状态，链路的两个PPP端点可以彼此向对方发送分组</p>
<ul>
<li>两个PPP端点还可以发送<strong>回送请求</strong>LCP分组(Echo-Request)和<strong>回送回答</strong>LCP分组(Echo-Reply)，以检查链路的状态</li>
</ul>
</li>
<li><p>数据传输结束后，可以由链路的一端发来<strong>终止请求</strong>LCP分组(Terminate-Request)请求链路连接，在收到对方发来的<strong>终止确认</strong>LCP分组(Terminate-Ack)后，转到<strong>链路终止</strong>状态</p>
<ul>
<li>如果链路出现故障，也会转到<strong>链路终止</strong>状态</li>
<li>当调制解调器的载波停止后，则回到<strong>链路终止</strong>状态</li>
</ul>
</li>
</ol>
<h2 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>局域网最主要的特点：<strong>网络为一个单位所拥有，且地理范围和站点数目均有限</strong></p>
<p>局域网的主要优点：</p>
<ul>
<li><strong>具有广播功能</strong>：从一个站点可很方便地访问全网</li>
<li><strong>便于系统的扩展和逐渐演变</strong>：各设备的位置可灵活调整改变</li>
<li><strong>提高系统的可靠性</strong>(reliability)、<strong>可用性</strong>(availability)和<strong>生存性</strong>(survivability)</li>
</ul>
<p>局域网按照网络拓扑进行分类，可分为<u>星形网(Star)、环形网(Ring)、总线网(Bus)</u><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.RLEyyVE1_SFTOZvvzLXqAwHaCK?w=335&amp;h=102&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="星形网 的图像结果"></p>
<p>共享信道要着重考虑的一个问题是如何使众多用户能够合理而方便地共享通信媒体资源，这在技术上有两种方法：</p>
<ol>
<li><strong>静态划分信道</strong>：用户只要分配到了信道就不会和其他用户发生冲突<ul>
<li>代价较高，不适合局域网</li>
</ul>
</li>
<li><strong>动态媒体接入控制</strong>：又称为<strong>多点接入</strong>(multiple access)，其特点是信道并非在用户通信时固定分配给用户，这分为两类：<ul>
<li><strong>随机接入</strong>：所有的用户可随机地发送信息，但如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享媒体上就要发生碰撞，使得这些用户的发送都失败</li>
<li><strong>受控接入</strong>：用户不能随机发送信息而必须服从一定的控制，典型代表有<u>分散控制的令牌环局域网和集中控制的多点线路<strong>探询</strong>(polling)，或称为<strong>轮询</strong></u></li>
</ul>
</li>
</ol>
<p>以太网的<strong>两个标准DIX Ethernet V2与IEEE的802.3标准</strong>只有很小的差别，因此很多人常把802.3局域网简称为“以太网”</p>
<ul>
<li>数据率都为10Mbit/s</li>
</ul>
<p>局域网的数据链路层可以拆分为两个子层，即<strong>逻辑链路控制LLC</strong>(Logical Link Control)子层和<strong>介质访问控制MAC</strong>(Medium Access Control)子层</p>
<ul>
<li>与接入到传输媒体有关的内容都放在MAC子层<br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625095406058.png" alt=""></li>
<li>不管采用何种传输媒体和MAC子层的局域网对LLC子层来说都是透明的<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.JkStCAOxHsgNvzgB4ig_YAHaB2?w=304&amp;h=87&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="局域网对LLC子层是透明的 的图像结果"></li>
</ul>
<p>计算机与外界局域网的连接是通过通信<strong>适配器</strong>(adapter)进行的。适配器本来是在主机箱内插入的一块网络接口板，这种接口板又称为<strong>网络接口卡NIC</strong>(Network Interface Card)，简称<strong>网卡</strong></p>
<blockquote>
<p>适配器和局域网之间的通过电缆或双绞线以串行传输方式进行的<br>适配器和计算机之间的通信是通过计算机主板上的I/O总线以并行传输方式进行的</p>
</blockquote>
<p>适配器的一个重要功能就是<strong>进行数据串行传输和并行传输的转换</strong></p>
<p>适配器在接收和发送各种帧时，不适用计算机的CPU。当适配器收到有差错的帧时，就把这个帧丢弃。<u>当适配器收到正确的帧时，他就使用中断来通知计算机，并交付协议栈中的网络层</u>。当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85OTM0NTU4LWVmNDQ3NTRhZGE1NmU5MDYucG5n" alt="数通 | 从二层、三层的概念切入这段时间学习的数通知识_层二源标识信息_zhouie的博客-CSDN博客"></p>
<p>常见局域网中的介质访问控制MAC：</p>
<ul>
<li><strong>以太网Ethernet</strong>：逻辑上是总线拓扑，物理上是星形或拓展星形拓扑</li>
<li><strong>令牌环网Token Ring</strong>：逻辑上是环形拓扑，物理上是星形拓扑</li>
<li><strong>光线分布式数据接口FDDI</strong>：逻辑上是环形拓扑，物理上是双环拓扑</li>
</ul>
<p>介质访问控制方法(Access Methods):</p>
<ul>
<li><strong>确定性轮流（Deterministic—taking turns</strong>：令牌环网和FDDI</li>
<li><strong>争用式（Non-deterministic（probabilistic）</strong>：先到先得<ul>
<li><strong>纯ALOHA协议</strong>(Pure ALOHA):主机任何时候都可以发送数据，如果发生冲突，延迟一段时间再发送</li>
<li><strong>分段ALOHA协议</strong>(Slotted ALOHA)：把信道在时间上分段，主机任何时候都发送数据，但必须等待下一个时间分段的开始才开始发送</li>
</ul>
</li>
</ul>
<p><strong>确定性MAC协议</strong>(Deterministic MAC Protocols)：</p>
<ol>
<li>特殊数据令牌在环中循环</li>
<li>当主机收到令牌时，它可以传送数据而不是令牌，这被称作<strong>夺取(seizing)令牌</strong></li>
<li>当发送(transmitted)的帧返回到发送器时，站点将发送新令牌；框架已从环上卸下或脱落(stripped)</li>
</ol>
<p><strong>非确定性MAC协议</strong>(Non-Deterministic MAC Protocols)：</p>
<ol>
<li>此 MAC 协议称为带冲突检测的载波侦听多路访问（<strong>CSMA/CD</strong>，Carrier Sense Multiple Access with Collision Detection）</li>
<li>为了使用这种共享介质（shared-medium）技术，以太网允许网络设备为传输权进行仲裁（arbitrate）</li>
<li>适用于总线结构的以太网</li>
</ol>
<p>局域网数据传输（Transmitison）方式：三种</p>
<ul>
<li><strong>单播</strong>(unicast)：将单个数据包从源发送到网络上的单个目标</li>
<li><strong>多播</strong>(multicast)：由发送到网络上特定节点子集的单个数据包组成，这些节点都有同样的进程进行响应</li>
<li><strong>广播</strong>(broadcast)：由单个数据包组成，该数据包传输到网络上的所有节点。（广播的目的地址是 0x11111111）</li>
</ul>
<h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h3><p><strong>多点接入</strong>说明这是总线型网络，协议的实质是<u>载波侦听和碰撞检测</u></p>
<p><strong>载波侦听</strong>就是<u>检测信道</u></p>
<ul>
<li>无论在发送前还是发送中，每个站都必须不停地检测信道</li>
</ul>
<p><strong>碰撞检测</strong>：也就是<u>边发送边监听</u>，也称为冲突检测</p>
<p>如图是传播时延对载波侦听的影响<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.EoScCTFNqAjuKkrWoD9hrAHaFo?pid=ImgDet&amp;rs=1" alt="CSMA/CD_姜希成的博客-CSDN博客"></p>
<ul>
<li>T为总时间，$t_0$为发生碰撞的时间，则发送端在发送数据帧用<strong>最多经过2$t_0$就可以知道是否发生了碰撞</strong></li>
<li>2$t_0$称为<strong>争用期</strong>(contention period)，也称为<strong>碰撞窗口</strong>(collision window)</li>
</ul>
<p>因此在使用CSMA/CD协议时，一个站<strong>不可能同时进行发送和接受，但必须边发送边侦听信道</strong>，也就是半双工通信</p>
<p>以太网使用<strong>截断二进制指数退避</strong>(truncated binary exponential backoff)算法来确定碰撞后的重传时机</p>
<ul>
<li><u>为了方便可以直接使用比特作为争用期的单位</u></li>
<li>从离散的集合[0, 1, 2, …, $2^k - 1$]中随机取出一个数，记作r，<strong>重传应推后的时间就是r倍的争用期</strong><ul>
<li>k = Min[重传次数， 10]</li>
</ul>
</li>
<li>当重传达16次仍不成功，则丢弃该帧并向高层报告</li>
</ul>
<p><strong>凡是长度小于64字节的都是由于冲突而异常终止的无效帧</strong></p>
<h2 id="以太网信道利用率"><a href="#以太网信道利用率" class="headerlink" title="以太网信道利用率"></a>以太网信道利用率</h2><p>以太网信道利用率总不能达到100%<br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.0lsHRR5245KxdtK8zvd-tQHaCF?pid=ImgDet&amp;rs=1" alt="计算机网络读书笔记——数据链路层（4）_晨哥是个好演员的博客-CSDN博客"></p>
<ul>
<li>我们注意到成功发送一个帧需要占用信道的时间是$T_0 + r$，这是因为当发送完最后一个比特时，这个比特还要在一台网上传播，而<strong>最坏情况是需要时间为r</strong></li>
<li>以太网单程端到端时延r与帧的发送时间$T_0$之比为：$a = \frac{r}{T_0}$<ul>
<li>a越大则争用期比例越大，信道利用率越低</li>
</ul>
</li>
</ul>
<h2 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h2><p>硬件地址又称为物理地址或者<strong>MAC地址</strong> ,实际上就是<strong>适配器地址或适配器标识符</strong>EUI-48</p>
<p>IEEE规定地址字段的第一字节的最低位为<strong>I/G位</strong>(Individual/Group)</p>
<ul>
<li>I/G = 0则地址字段表示一个<strong>单个站地址</strong></li>
<li>I/G = 1则地址字段表示一个<strong>组地址</strong>，用来进行<strong>多播（组播）</strong></li>
</ul>
<p>IEEE规定地址字段的第一字节的最低第二位为<strong>G/L位</strong>(Gloup/Local)</p>
<ul>
<li>G/L = 0则是全球管理</li>
<li>G/L = 1则是本地管理</li>
</ul>
<p>适配器从网络上收到一个MAC帧就先用硬件检查MAC帧中的目的地址，这里的帧包括以下三种：</p>
<ul>
<li><strong>单播(unicast)帧</strong>（一对一）：收到的帧的MAC地址与本站的硬件地址相同</li>
<li><strong>广播(broadcast)帧</strong>（一对全体）：发送给本局域网上所有站点的帧（全1地址）</li>
<li><strong>多播(multicast)帧</strong>（一对多）：发送给笨局域网上一部分站点的帧</li>
</ul>
<h3 id="MAC帧的格式"><a href="#MAC帧的格式" class="headerlink" title="MAC帧的格式"></a>MAC帧的格式</h3><p>存在802.3标准和Ethernet V2标准</p>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625182049677.png" alt=""></p>
<ol>
<li><p><strong>前文</strong>：从 1 和 0 的交替（alternating）模式开始，称为<strong>前同步码</strong>（preamble）</p>
<ul>
<li>告诉接收方，要来数据了，因为不是预约发数据的模式，这个码就是为了保证对方有相应准备时间，前面 7 个是前同步码（0b10101010），最后一个是帧开始定界符（0x10101011）</li>
<li>使用曼彻斯特编码的方案，无传输的时候是 0 电平的，前同步码告诉接收站一帧即将到来，<strong>前同步码不是 MAC 帧的内容</strong></li>
</ul>
</li>
<li><strong>目标和源物理地址字段</strong><ul>
<li><strong>源地址始终是单播地址</strong></li>
<li>目的地址可以是单播地址、组播地址或广播地址</li>
<li>MAC地址：6个字节为目的地址(Dest.add)，6个字节为源地址(Source.add)</li>
<li>先看目的地址的好处：<u>交换机等看到目的地址就可以进行判断，提高效率</u></li>
</ul>
</li>
<li><p><strong>长度字段</strong>：长度字段指示在该字段之后且在帧检查序列字段之前的<strong>数据字节数</strong></p>
<ul>
<li>2 个字节长，早期规范放的是长度，指定<strong>数据长度</strong>，以太网-2 标准下则是使用 type 来完成这部分内容，指定后面的 DATA 是 IP 还是 IPX 的报文数据</li>
<li>没有长度也可以计算出来长度，通过有电平长度就可以计算出数据的长度</li>
<li><u>数据长度的限制（46-1500 字节），以太网的帧长度不能长于 1518 字节</u></li>
<li>为了避免歧义，只要保证 Length 的数据大于数据报的最大长度即可保证是表示 type，保证和之前兼容 </li>
</ul>
</li>
<li><p><strong>数据字段</strong>：数据字段包含要发送的信息</p>
<ul>
<li>数据的长度为 46（18 + 46 = 64 字节）-1500 字节，帧的大小<strong>至少是 64 个字节</strong>，如果数据太短需要补充 0 才能生成 data，前引导码不算帧长度</li>
<li><strong>以太网规定，小于 64 字节的帧是由于冲突而终止的无效帧</strong></li>
<li>最前面8个字段不算帧的内容</li>
<li><strong>4 个 64 字节大小帧同时发送才能保证占据全部的链路</strong>，100m 链路，用 512us，就是 512bit</li>
</ul>
</li>
</ol>
<ol>
<li><strong>FCS字段</strong>：包含循环冗余校验码</li>
</ol>
<p>最小帧长问题：<br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220416143556873.png" alt=""></p>
<h3 id="MAC子层上的介质访问控制"><a href="#MAC子层上的介质访问控制" class="headerlink" title="MAC子层上的介质访问控制"></a>MAC子层上的介质访问控制</h3><p>MAC地址采用<strong>十六进制数</strong>，为48位，表示为12个十六进制数字</p>
<ul>
<li>IEEE管理前6个十六进制数字表示<u>制造商或供应商，并包括组织唯一标识符(OUI)</u></li>
<li>其余6个十六进制数字包括<u>接口序列号，由特定供应商管理</u></li>
</ul>
<p><strong>广播</strong>：</p>
<ol>
<li><strong>地址</strong><ul>
<li>目标MAC：全1(FFFF,FFFF,FFFF)</li>
<li>保证所有设备都能收到这个地址</li>
<li>会导致非目的主机进行地址解析</li>
</ul>
</li>
<li>广播会不必要地打断电台，从而严重影响电台性能</li>
<li>只有<strong>目的地的MAC地址未知或目的地是全部主机</strong>才能使用广播</li>
</ol>
<p>以太网是广播网络，也就是说每个站都可以看到所有帧，不管是不是目的地，因此可以<strong>通过MAC地址判断站点是否为目的地</strong>，目标站在OSI层上发送数据，其他节点丢弃帧</p>
<p><strong>广播操作步骤</strong>：</p>
<ol>
<li>听然后传送</li>
<li><strong>广播 jam 信号</strong><ul>
<li>是一个 32bit 的全 1 的数据帧表示出现了冲突</li>
<li>所有侦听的设备都会发送</li>
</ul>
</li>
<li>发生碰撞（Collision）<ul>
<li>两个设备同时使用链路发送电信号，则会出错。</li>
<li>如果有冲突，则会一直侦听总线，等到空闲则可以组织数据帧发送</li>
<li><strong>多台主机同时进行组织数据帧进行发送</strong></li>
<li><u>如果出现冲突，则会发出 jam 信号，只要有 0 或者 1 传输，有电平则会表示使用</u></li>
</ul>
</li>
<li>设备退回适当的时间，然后重新传输</li>
</ol>
<h2 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h2><p>无线局域网：</p>
<ul>
<li>基于单元的通信</li>
<li>电台发送的信号只能被附近的电台接收</li>
<li>短距离传输</li>
</ul>
<p>无线局域网标准:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>协议名称</th>
<th>带宽</th>
<th>频率</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>802.11</td>
<td>1-2Mbps</td>
<td></td>
<td></td>
</tr>
<tr>
<td>802.11b</td>
<td>11Mbps</td>
<td>2.4GHz</td>
<td>使用与802.11不同的编码技术来实现，向后兼容</td>
</tr>
<tr>
<td>802.11a</td>
<td>54Mbps</td>
<td>5GHz</td>
<td></td>
</tr>
<tr>
<td>802.11g</td>
<td></td>
<td></td>
<td>可提供与802.11a相同的功能，具有802.11b的向后兼容性</td>
</tr>
<tr>
<td>802.11n</td>
<td>108Mbps</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p><strong>802.11</strong>：</p>
<ul>
<li>关键技术：<strong>直接序列扩频DSSS</strong>(Direct Sequence Spread Spectrum)</li>
<li>DSSS 适用于在 1 到 2 Mbps 范围内运行的无线设备，上面的这个速率<strong>在实际生活场景中要除以 2</strong>（一来一回才有一次通信）</li>
<li>DSSS可以高达11Mbps的速度运行，在 2 Mbps 以上时将不被视为兼容</li>
<li>也称为 Wi-Fi™，无线保证度，是<strong>星型拓扑</strong>，基站作为中心</li>
</ul>
</li>
<li><p><strong>IEEE 802.11b</strong>(Wi-Fi)</p>
<ul>
<li>传输能力提高到 11Mbps</li>
<li>所有 802.11b 系统都<strong>向后兼容</strong>（backward compliant），因为它们还仅针对 DSSS 支持 1 和 2Mbps 数据速率的 802.11</li>
<li>通过使用与 802.11 不同的编码技术来实现更高的数据吞吐率</li>
<li>在 2.4 GHz 内运行，解决了 802.11 中出现的部分问题</li>
<li>使用的是<strong>高速直连方案</strong></li>
</ul>
</li>
<li><p><strong>IEEE 802.11a</strong></p>
<ul>
<li>涵盖在 5GHz 传输频带中运行的 WLAN 设备</li>
<li>802.11a 能够提供 54 Mbps 的数据吞吐量，并且采用称为“速率加倍”的专有技术已达到 108 Mbps。</li>
<li>实际上，更标准的等级是 20-26 Mbps。</li>
<li><u>传播距离相比 802.11 和 802.11b 短（衰减强）</u>，但是对于多用户上网的支持更好了</li>
<li>使用<strong>正交频分复用</strong>技术</li>
</ul>
</li>
<li><p><strong>IEEE 802.11g</strong>：</p>
<ul>
<li>可以提供与 802.11a（54Mbps）相同的功能，但具有 802.11b 的向后兼容性</li>
<li>使用<strong>正交频分复用</strong>技术</li>
</ul>
</li>
<li><strong>IEEE 802.11n</strong>（下一代WLAN）：<ul>
<li>提供的带宽是 802.11g 的两倍，即 108Mbps，理论上可达 500-600Mbps。实际上是 100M 左右</li>
<li><strong>目前使用比较多的方案</strong></li>
</ul>
</li>
</ol>
<p>无线局域网分为两类：</p>
<ul>
<li><strong>有基础设施拓扑网络(Infrastructure mode)</strong></li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625095629445.png" alt=""></p>
<ul>
<li><strong>无基础设施拓扑网络(ad-hoc mode)</strong></li>
</ul>
<p><img src="https://pic2.zhimg.com/v2-3a12c8558e2e8d8163ece6d9b8d66401_r.jpg" alt=""><br>基础设施指的是提前建设好的基站</p>
<h3 id="虚拟载波监听"><a href="#虚拟载波监听" class="headerlink" title="虚拟载波监听"></a>虚拟载波监听</h3><ol>
<li>源站把它要占用信道的时间（<strong>包括目的站发回确认帧所需的时间</strong>）写入到所发送的数据帧中（即在首部中的<strong>持续时间</strong>中写入需要占用信道的时间，以微秒为单位，一直到目的站把确认帧发送完为止），以便使其他所有站在这一段时间都不要发送数据</li>
<li>当站点检测到正在信道中传送的帧中的持续时间时，就调整自己的<strong>网络分配向量NAV</strong>(Network Allocation Vector)<ul>
<li>NAV 指出了信道处于忙状态的持续时间。</li>
</ul>
</li>
<li>为什么信道空闲还要再等待呢?就是考虑可能有其他站点有<strong>高优先级</strong>的帧要发送。如有，就让高优先级帧先发迭。等待的时间就是 <strong>帧间间隔IFS</strong>(Inter-Frame Space)<ul>
<li>SIFS（Short Inter-Frame Space，短帧间间隔）最短</li>
<li>PIFS（Point Inter-Frame Space，点协调功能帧间间隔）其次</li>
<li>DIFS（Distributed Inter-Frame Space，分布协调功能帧间间隔）最长</li>
</ul>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/data_link_layer-1-CSMACA.png" alt="WLAN 中的 CSMA/CA 示意"><br>实际吞吐量由于源站点发出帧后，接收节点需要返回确定帧(ACK)，这会导致吞吐量降到带宽的一半，也会收到信号强度的影响</p>
<h3 id="无线网络拓扑"><a href="#无线网络拓扑" class="headerlink" title="无线网络拓扑"></a>无线网络拓扑</h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625095629445.png" alt=""><br><strong>基本服务集BSS</strong>包括<u>一个基站BS和几个无线主机</u></p>
<ul>
<li>所有主机都可以在本地 BSS 中直接相互通信<ul>
<li>基站中两个主机之间是不直接互相通信的。</li>
<li>同一个 BSS 中的主机间直接通信<br><strong>接入点AP</strong>充当基础架构模式的基站</li>
<li>AP 硬连线到有线局域网，以提供 Internet 访问和与有线网络的连接</li>
<li>安装 AP 后，将<u>分配服务集标识符(SSID)和通道</u></li>
</ul>
</li>
</ul>
<p><strong>一个 BSS 可以通过分发系统(DS)连接到另一个 BSS，并构造一个扩展服务集(ESS)</strong></p>
<p>家里的路由器既有 AP 的功能又有路由器功能，但是理论上只应该是 AP 的功能，一般我们认为家用路由器是一个 AP</p>
<p>访问过程：在 WLAN 中激活客户端时，它将开始侦听与之关联的兼容设备，这被称为<strong>扫描</strong></p>
<ul>
<li><strong>主动扫描</strong>：导致从寻求加入网络的无线节点发送探测请求，探测请求将包含它希望加入的网络的服务集标识符，当找到具有相同 SSID 的 AP 时，该 AP 将发出探测响应，当身份验证和关联步骤已完成后，移动端发出请求帧，但是 AP 不发送自己的信息<ul>
<li>AP 比较安全。不用发送出自己的 SSID</li>
</ul>
</li>
<li><strong>被动扫描</strong>：侦听由 AP或对等节点传输的信标管理帧，包含自己的 SSID 信息，当节点接收到包含要尝试加入的网络的 SSID 的信标时，将尝试加入该网络<ul>
<li>被动扫描是一个连续的过程，并且随着信号强度的变化，节点可能会与 AP 关联或分离，也是因为强度变化，所以连接状态需要维持</li>
</ul>
</li>
</ul>
<p>需要和 AP 连接，才能向 AP 发送数据帧</p>
<h3 id="无线局域网的帧结构"><a href="#无线局域网的帧结构" class="headerlink" title="无线局域网的帧结构"></a>无线局域网的帧结构</h3><p>WLAN不使用标准的802.3帧，具体框架有三种：</p>
<ul>
<li><strong>控制帧</strong>(Control Frames)</li>
<li><strong>管理帧</strong>(Management frames)</li>
<li><strong>数据帧</strong>(仅数据帧类似于802.3帧)</li>
</ul>
<p>无线数据帧和802.3帧的有效载荷为 1500 字节</p>
<ul>
<li>以太帧不能超过 1518 字节，而无线帧则可能高达<strong>2346 字节</strong></li>
<li>无线网络帧的大小也不会太大，尽量避免转换成有线帧的时候出现帧的拆分，也就是说大小一般在 1500 字节以下，通常，<strong>WLAN 帧大小将被限制为 1518 字节</strong>，因为它最常连接到有线以太网</li>
</ul>
<h3 id="数据帧结构-802-11无线网"><a href="#数据帧结构-802-11无线网" class="headerlink" title="数据帧结构(802.11无线网)"></a>数据帧结构(802.11无线网)</h3><ol>
<li>去往 AP 和来自 AP 是我们需要重点确认</li>
<li>WEP 规格，Wired Equivalent Privacy（有线等效保密）</li>
<li>持续期：参数<strong>很重要</strong>，CSMA/CA 需要这个信息</li>
<li>有时间窗口，如果超时没收到信号，则进行重传</li>
</ol>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625180916903.png" alt=""></p>
<p>数据帧地址分类：</p>
<ul>
<li>ad hoc用地址4</li>
<li>有基础设施用地址1、2、3</li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721111234097.png" alt=""><br>这是拓展星型拓扑，而<strong>两个AP之间通过有线进行通信</strong>，因此不能全是1</p>
<h2 id="避免冲突的载波侦听多路访问CSMA-CA"><a href="#避免冲突的载波侦听多路访问CSMA-CA" class="headerlink" title="避免冲突的载波侦听多路访问CSMA/CA"></a><strong>避免冲突的载波侦听多路访问CSMA/CA</strong></h2><p>Q: <strong>为什么我们需要CSMA/CA?</strong><br>A: 冲突(Collisions)可能发生在 WLAN 中，但是站点只能知道附近的传输，因此 CSMA/CD 不是一个好的选择</p>
<ul>
<li><strong>隐藏站问题</strong>：当 A 将数据传输到 B 时，C 无法检测到 A 和 B 之间的传输，因此 C 可能会决定将数据传输到 B 并导致 B 发生冲突</li>
<li><strong>暴露站问题</strong>：当 B 将数据传输到 A 时，C 可以检测到传输，因此 C 不会将数据传输到 D。但这是一个错误（听到不应该听到的信号）</li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721111242160.png" alt=""></p>
<p><strong>多路复用机制</strong></p>
<ol>
<li>以太网<ul>
<li>信号被传输到电缆上的<strong>所有</strong>站。</li>
<li>发送站检测到冲突。</li>
<li>一次只能在信道上发送一个有效帧。</li>
</ul>
</li>
<li>WLAN 无线网络<ul>
<li>信号通过电缆传输到发送站附近的站（相邻,不可以跨越有效距离发送）</li>
<li>MAC协议必须尽最大努力确保仅发送站靠近接收站，发送方只能发送一路信号给接受方，不能有多个发送方发送信号给一个接受点</li>
<li>接收方检测确定冲突</li>
<li>一次可以在通道上传输<strong>多</strong>个有效帧,不可以产生冲突</li>
</ul>
</li>
</ol>
<p><strong>CSMA/CA</strong>：发送站点在发送数据前，以<strong>控制短帧</strong>刺激接收站点发送应答短帧，使接收站点周围的站点监听到该帧，从而在一定时间内避免数据发送</p>
<p><strong>基本过程</strong>：</p>
<ol>
<li>A 向 B 发送请求<strong>发送RTS</strong>(Request To Send)帧，A 周围的站点在一定时间内不发送数据，以保证 CTS 帧返回给 A<ol>
<li>B 向 A 回答<strong>清除发送CTS</strong>(Clear To Send)帧，B周围的站点在一定时间内不发送数据，以保证A发送完数据</li>
<li>A 开始发送</li>
<li>若控制帧RTS或CTS发生冲突，采用二进制指数后退算法等待随机时间，再重新开始(A 和 C 同时发送 RTS)</li>
</ol>
</li>
</ol>
<blockquote>
<p>退避时间短的设备先传输<br>发现冲突所有设备同时退避</p>
</blockquote>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625095718197.png" alt=""></p>
<ol>
<li>为避免冲突，802.11 所有站点在完成一个事务后必须等待一段时间才能进行下一个动作，这个时间被称为 IFS，具体取决于帧的类型。</li>
<li>SIFS（Short interframe space）：短帧间间隔 28us，用于本设备接受发送状态转换，不足够源站接受 CTS</li>
<li>DIFS（Distributed Inter-frame Spacing）：分布协调功能帧间间隔 128us（多个节点进行协调）</li>
<li>应答 CTS（Clear to Send），等待 SIFS（Short interframe space）后发送数据</li>
<li>过程中的时间写入时间数据标记位</li>
<li>NAV（网络分配向量）：网络协调时间,时间长度：NAV 计算方式在后面，NAV 是一开始就进行预估了，别的节点抢到了节点时，我们会减掉别人正常通信的时间，不是一直累积下去的情况。</li>
<li>下一次经过争用窗口来抢</li>
<li>源站需要收到确认信息 CTS 才能接着发送信息</li>
<li>多个源站向目的站发 RTS 给目的站，目的站发现冲突，告诉各自站点，PPT 处理的是 RTS</li>
</ol>
<h3 id="实际数据传输率"><a href="#实际数据传输率" class="headerlink" title="实际数据传输率"></a>实际数据传输率</h3><ol>
<li>当源节点发送帧时，接收节点将返回ACK</li>
</ol>
<ul>
<li>这可能导致消耗50%的可用带宽</li>
<li>在额定为 11 Mbps 的 802.11b 无线局域网上，这会将实际数据吞吐量降低到最大 5.0 到 5.5Mbps</li>
</ul>
<ol>
<li>网络性能也会受到信号强度的影响</li>
</ol>
<ul>
<li>随着信号变弱，可以调用自适应速率选择(ARS)</li>
<li>信号会受到距离影响，越远信号越弱，功率越低，带宽不能稳定到初始带宽</li>
<li>传输单元会将数据速率从 11 Mbps 降低到 5.5Mbps，从 5.5 Mbps 降低到 2 Mbps 或 2 Mbps 到 1 Mbps</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Ethernet</th>
<th>WLAN</th>
</tr>
</thead>
<tbody>
<tr>
<td>信号被传输到连接在线缆上的所有站点上</td>
<td>信号只被传输到接近发送站点的站点</td>
</tr>
<tr>
<td></td>
<td>接受站点检测冲突</td>
</tr>
<tr>
<td>只会有一个有效帧在信道上传播</td>
<td>会有多个有效帧同时在信道上传播</td>
</tr>
<tr>
<td></td>
<td>MAC协议必须尽可能保证只有发送站点接近接收站点</td>
</tr>
</tbody>
</table>
</div>
<h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><p><strong>网卡NICs</strong>：</p>
<ul>
<li><strong>逻辑链接控制</strong>——与计算机上层通信</li>
<li><strong>媒体访问控制</strong>——提供对共享访问媒体的结构化访问</li>
<li><strong>命名</strong>——提供唯一的 MAC 地址标识符</li>
<li><strong>成帧</strong>——封装过程的一部分，打包比特以进行传输</li>
<li><strong>信号</strong>——使用内置收发器创建信号并与媒体接口</li>
</ul>
<p><strong>网桥Bridge</strong>：连接两个相同结构的局域网，并对流经网桥的数据进行转发</p>
<ul>
<li>目的是<strong>过滤局域网上的流量</strong>(根据MAC地址而不是协议)，使流量保持在本地，同时允许连接到局域网的其他部分以获取指向那里的流量</li>
<li>跟踪网桥两侧的MAC地址，并根据该MAC地址列表做出决策</li>
<li>在网段之间收集和发送数据报</li>
<li><strong>创建冲突域</strong><ul>
<li>减少较大的冲突域，碰撞减少</li>
<li>延迟提高</li>
</ul>
</li>
<li>维护地址表</li>
<li><strong>储存转发设备</strong>，因为它必须接受整个帧并在转发前检验CRC</li>
</ul>
<h3 id="透明网桥原理"><a href="#透明网桥原理" class="headerlink" title="透明网桥原理"></a><strong>透明网桥原理</strong></h3><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/data_link_layer-3-Transparent_Bridge.png" alt=""><br>MAC表放到缓存的位置，刚启动时是空表，之后逐渐学习</p>
<ul>
<li>地址表<strong>具有生命周期</strong></li>
<li>透明指的是<u>局域网中的站点并不知道所发送的帧将经过哪几个网桥</u></li>
<li>即插即用</li>
</ul>
<p>当网络上的设备要发送数据但不知道目标地址时，会<strong>向网络上的所有设备发送广播</strong>，网桥始终会转发这些广播</p>
<ul>
<li>广播过多会导致广播风暴</li>
</ul>
<p><strong>源路由网桥</strong>：发送帧时将详细的路由信息放在帧的首部中,从而使每个经过的网桥都了解帧的路径，在<strong>令牌环网</strong>中广泛使用</p>
<ul>
<li>源站以<strong>广播方式</strong>向目的站发送一个发现帧，每个发现帧都记录所经过的路由。发现帧到达目的站时就沿各自的路由返回源站。源站在得知这些路由后，从所有可能的路由中选择出一个最佳路由。凡从该源站向该目的站发送的帧的首部，都必须携带源站所确定的这一路由信息</li>
</ul>
<p><strong>交换机Switch</strong>：识别数据包中的MAC地址信息，然后根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中</p>
<ul>
<li>执行两个基本操作：<ul>
<li><strong>切换数据帧</strong>：在输入介质上接收帧，然后将其传输到输出介质</li>
<li><strong>维护交换操作</strong>：交换器建立和维护交换表并搜索循环。，路由器构建并维护路由表和交换表</li>
</ul>
</li>
<li>交换是一项通过<strong>减少流量</strong>来缓解以太网 LAN 拥塞的技术<ul>
<li>交换机创建专用的网段或点对点连接，并将这些网段连接到交换机内的虚拟网络中</li>
<li>之所以称为<strong>虚拟电路</strong>，是因为它仅在两个节点需要通信时才存在，并且在交换机内建立</li>
<li>每个交换机端口将介质的<strong>全部带宽</strong>提供给每个主机</li>
</ul>
</li>
<li><strong>连接到交换机的所有主机仍位于同一广播域中</strong>(路由器可以创建广播域)</li>
</ul>
<p>通过添加<strong>中继器和集线器</strong>来扩展冲突域</p>
<ul>
<li>不会分割</li>
</ul>
<p>可以通过添加<strong>网桥、交换机和路由器</strong>等智能设备对网络进行分割<br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-03-%E5%B1%80%E5%9F%9F%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220416154934864.png" alt=""></p>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络概述</title>
    <url>/2023/10/26/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h2><p>互联网（internet）把许多网络通过路由器连接在一起</p>
<ul>
<li>与网络相连的计算机常称为<strong>主机</strong></li>
</ul>
<p>区分：Internet是专有名词<strong>互联网/因特网</strong>！！！</p>
<ul>
<li>Internet使用<strong>TCP/IP协议</strong>作为通信规则，前身是美国的ARPANET</li>
</ul>
<p><strong>ISP</strong>(Internet Service Provider): <strong>互联网服务提供商</strong></p>
<p>ISP分为不同层次：主干ISP、地区ISP、本地ISP</p>
<ul>
<li>根据<u>提供服务的覆盖面积大小和所拥有的IP地址数目不同</u>划分</li>
</ul>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.Rq78nZwCRn0oeQ43K_DAjQHaEa?w=254&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="基于isp的三层结构的因特网 的图像结果"></p>
<p><strong>WWW</strong>(World Wide Web)：<strong>万维网</strong></p>
<p><strong>ISOC</strong>(Internet Society):<strong>互联网协会</strong></p>
<ul>
<li>对互联网进行全面管理以及在世界范围内促进其发展和使用</li>
</ul>
<p><strong>IAB</strong>(Internet Architecture Board):<strong>互联网体系结构委员会</strong></p>
<ul>
<li>负责管理互联网有关协议的开发</li>
<li>包括<strong>互联网工程部IETF</strong>(Internet Research Task Force)和<strong>互联网研究部IRTF</strong>(Internet Research Steering Group)</li>
</ul>
<p>指定互联网标准要经过以下三个阶段：</p>
<ol>
<li><strong>互联网草案</strong>(Internet Draft)———六个月有效期</li>
<li><strong>建议标准</strong>(Proposed Standard)———成为RFC文档</li>
<li><strong>互联网标准</strong>(Internet Standard)———正式标准</li>
</ol>
<h2 id="互联网组成"><a href="#互联网组成" class="headerlink" title="互联网组成"></a>互联网组成</h2><p>从工作方式看，可以分为两部分：</p>
<ol>
<li><strong>边缘部分</strong>———由所有连接在互联网上的主机组成</li>
<li><strong>核心部分</strong>———由大量网络和连接这些网络的路由器组成</li>
</ol>
<h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><p><strong>客户-服务器方式</strong>(client-to-server)<br>客户是服务请求方，服务器是服务提供方</p>
<ul>
<li>客户程序必须知道服务器程序的地址，反之不用</li>
<li>服务器程序可<strong>同时处理</strong>多个请求<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.m3zNhmq24fpND7vwFDaRVAHaDM?w=272&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="边缘部分核心部分 的图像结果"></li>
</ul>
<p><strong>对等连接方式</strong>(peer to peer,简写<strong>P2P</strong>)<br>每一台主机既是客户又是服务器<br><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.5_g9pTBgCTWXdzDV3M5w1AHaEV?w=262&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="边缘部分核心部分 的图像结果"></p>
<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p>起特殊作用的是<strong>路由器(router)</strong>,这是一种专用计算机(但不叫主机)</p>
<ul>
<li>实现<strong>分组交换(packet switching)</strong>的关键构件，其任务是<strong>转发收到的分组</strong></li>
</ul>
<p><strong>电路交换</strong>三个步骤：<strong>建立连接</strong>-&gt;<strong>通话</strong>-&gt;<strong>释放连接</strong></p>
<ul>
<li>在通话的全部时间内，通话的两个用户始终占有端到端的通信资源</li>
<li>传输效率低</li>
</ul>
<p><strong>分组交换</strong>采用<strong>存储转发</strong>技术</p>
<p>要发送的整块数据成为一个<strong>报文</strong>(message),发送报文前先把较长的报文分成一个个较小的等长的数据段，每个数据段前面加上一些由<u>必要的控制信息</u>组成的<strong>首部</strong>(head)，就构成了一个<strong>分组</strong>(packet)</p>
<p>分组是在互联网中传送的数据单元</p>
<p>主机和路由器的区别：</p>
<ol>
<li><strong>主机是为用户进行信息处理的</strong></li>
<li><strong>路由器是用来转发分组的，即进行分组交换</strong>  </li>
</ol>
<p>分组转发的有点：</p>
<ol>
<li><strong>高效</strong> ：在分组传输的过程中动态分配传输带宽</li>
<li><strong>灵活</strong>：为每一个分组独立地选择最合适的转发路由</li>
<li><strong>迅速</strong> ：可以不先建立连接就能向其他主机发送分组</li>
<li><strong>可靠</strong>：保证可靠性的网络协议；分布式多路由的分组交换网，使网络由很好的生存性</li>
</ol>
<p>分组在各路由器存储转发时需要排队，会产生一定的<strong>时延</strong></p>
<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.BiRp_iE3q9jwba1ujRgQ-AHaES?w=299&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="电路交换 报文交换 分组交换 的图像结果"></p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>按照网络的作用范围进行分类：</p>
<ol>
<li><strong>广域网 WAN</strong>(Wide Area Network) </li>
</ol>
<ul>
<li>互联网的核心部分</li>
</ul>
<ol>
<li><del><strong>域域网 MAN</strong>(Metropolitan Area Network)</del></li>
<li><strong>局域网 LAN</strong>(Local Area Network)</li>
<li><strong>个人区域网 PAN</strong>(Personal Area Network)</li>
</ol>
<ul>
<li>也常成为<strong>无线个人区域网 WPAN</strong>(Wreless PAN)</li>
</ul>
<p>按照网络的使用者来进行分类</p>
<ol>
<li><strong>公用网</strong>(public network)</li>
<li><strong>专有网</strong>(private network)</li>
</ol>
<h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ol>
<li><strong>速率</strong>：<br>网络技术中的速率指的是<strong>数据的传送速率</strong>，也成为<strong>数据率</strong>或者<strong>比特率</strong>，单位是bit/s</li>
</ol>
<ul>
<li>k = $10^3$  M = $10^6$ G = $10^9$ </li>
</ul>
<ol>
<li><p><strong>带宽</strong>：<br>指某个<strong>信号具有的频带宽度/频带范围</strong>，单位是Hz<br>但是在计算机网络中，带宽常常指<strong>单位时间内网络中的某信道所能通过的“最高数据率”</strong>，这里带宽的单位是bit/s</p>
</li>
<li><p><strong>吞吐量</strong><br>表示在单位时间内通过某个网络( 信道、接口 )的实际数据量</p>
</li>
<li><p><strong>时延</strong>(delay)<br>指数据从网络/链路 的一端传送到另一端所需的时间</p>
<ul>
<li><strong>发送时延</strong>是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间，<del>因此也叫做<strong>传输时延</strong></del> <ul>
<li>发送时延 = 数据帧长度(bit) / 发送速率(bit/s)</li>
</ul>
</li>
<li><p><strong>传播时延</strong>是电磁波在信道中传播一定距离需要花费的时间</p>
<ul>
<li>传播时延 = 信道长度(m) / 电磁波在信道上的传播速率(m/s) </li>
</ul>
<p>发送时延在机器内部的发送器中， 与<strong>传输信道长度无关</strong><br>而传播时延在机器外部的传输信道媒体上</p>
</li>
<li><p><del><strong>处理时延</strong></del> </p>
</li>
<li><strong><del>排队时延</del></strong></li>
</ul>
</li>
</ol>
<p><strong>对于高速网络链路，我们提高的仅是数据的发送速率而不是比特在链路上的传播速率</strong></p>
<ul>
<li><strong>提高数据的发送速率只是减少了数据的发送时延</strong></li>
</ul>
<ol>
<li><p><strong>时延宽带积</strong><br>时延宽带积 = 传播时延 x 带宽</p>
<ul>
<li>因此又称为<strong>以比特位单位的链路长度</strong></li>
</ul>
</li>
<li><p><strong>往返时间RTT</strong><br>RTT不包括发送时间</p>
</li>
<li><p><strong>利用率</strong><br>分为信道利用率和网络利用率 </p>
<ul>
<li><strong>信道利用率</strong>指出某信道有百分之几的时间是被利用的</li>
<li><p><strong>网络利用率</strong>是全网络的信道利用率的加权平均值</p>
<p>信道和网络利用率过高会产生非常大的时延</p>
</li>
</ul>
</li>
</ol>
<h2 id="计算机网络体系"><a href="#计算机网络体系" class="headerlink" title="计算机网络体系"></a>计算机网络体系</h2><p>美国的IBM公司宣布了<strong>系统网络体系结构SNA</strong>(System Network Architecture),这个著名的网络标准就是按照分层的办法制定的</p>
<p>国际标准化组织ISO提出了<strong>开放系统互连基本参考模型(OSI/RM)</strong>(Open System Interconnection Reference Model),简称<strong>OSI</strong></p>
<p>得到最广泛应用的是<strong>TCP/IP</strong>,其为事实上的国际标准</p>
<p><strong>网络协议(network protocol)</strong>: 为进行网络中的数据交换而建立的规则、标准或约定，由三个要素组成：</p>
<ol>
<li><strong>语法</strong>：数据与控制信息的结构或格式</li>
<li><strong>语义</strong>：需要发出何种控制信息，完成何种动作以及做出何种响应</li>
<li><strong>同步</strong>：事件实现顺序的详细说明 </li>
</ol>
<p>分层的好处：</p>
<ol>
<li><strong>各层之间是独立的</strong></li>
<li><strong>灵活性好</strong></li>
<li><strong>结构上可分隔开</strong></li>
<li><strong>易于实现和维护</strong></li>
<li><strong>能促进标准化工作</strong></li>
</ol>
<p>通常来说各层要完成的功能由以下一些：</p>
<ul>
<li><strong>差错控制</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>分段和重装</strong> </li>
<li><strong>复用和分用</strong></li>
<li><strong>连接的建立和释放</strong></li>
</ul>
<p><strong>计算机网络的各层以及协议的几何就是网络的体系结构</strong>（<u>计算机网络的体系结构就是这个计算机网络以及构件所应完成的功能的精确定义</u>）</p>
<p>TCP/IP是一个四层的体系结构，包含应用层、运输层、网际层、网络接口层</p>
<p>学习的时候常常采用一种五层协议体系结构，包含<strong>应用层、运输层、网络层、数据链路层、物理层</strong></p>
<ol>
<li><p><strong>应用层</strong>(application)：<br> <u>通过应用进程间的交互来完成特定的网络应用</u>，应用层协议定义的是<u>应用进程间通信和交互的规则</u>，我们把应用层交互的数据单元成为<strong>报文</strong></p>
</li>
<li><p><strong>运输层</strong>(transport)：<br> . <u>向两台主机进程之间的通信提供通用的数据传输服务</u>，运输层有分用服用功能</p>
<ul>
<li><strong>传输控制协议TCP</strong>: 提供<u>面向连接的、可靠的</u>数据传输服务，其数据传输单位是<strong>报文段</strong>(segment)</li>
<li><strong>用户数据报协议UDP</strong>: 提供<u>无连接的、尽最大努力的数据传输服务(不保证数据传输的可靠性)</u>，其数据传输单位是<strong>用户数据报</strong></li>
</ul>
</li>
<li><p><strong>网络层</strong>(network)：<br> <u>为分组交换网上的不同主机提供通信服务</u>。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成<strong>分组</strong>或<strong>包</strong>进行传送。由于网络层使用IP协议，因此分组也可叫做<strong>IP数据报</strong>，简称<strong>数据报</strong>(不同于UDP)</p>
<ul>
<li>无论哪一层传送的数据单元，都可笼统地用<strong>分组</strong>来表示</li>
</ul>
</li>
<li><p><strong>数据链路层</strong>(data link)：<br> <u>将网络层交下来地IP数据报组装成<strong>帧</strong></u>(frame),在两个相邻结点间的链路上传送帧，还能检测所受到的帧有没有差错(<strong>可靠协议</strong>)</p>
<ul>
<li>每一帧都包括数据和必要的<strong>控制信息</strong></li>
</ul>
</li>
<li><p><strong>物理层</strong>(physical)：<br> 数据的单位是<strong>比特</strong>。物理层要考虑用多大的电压代表“1”和“0”，以及接收方如何识别出发送方所发送的比特，还要确定连接电缆的插头应当由多少根引脚以及各引脚应如何连接</p>
<ul>
<li><strong>传递信息所利用的一些物理媒介，比如双绞线、同轴电缆、光纤等并不在物理层协议之内</strong></li>
</ul>
</li>
</ol>
<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.Hjk_e100vUeMrSztC6TN-QHaDp?w=327&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="数据在各层之间的传递过程 的图像结果"></p>
<p>OSI模型把对等层次之间传送的数据单位成为该层地<strong>协议数据单元PDU</strong>(Protocol Data Unit)</p>
<p><strong>协议是控制两个对等实体(或多个实体)进行通信的规则的集合</strong></p>
<p>在协议的控制下，<u>两个对等实体间的通信使得本层能够向上一层提供服务</u>，要实现本层协议，还需要使用下面一层所提供的服务</p>
<p>OSI把层与层之间交换的数据的单位成为<strong>服务数据单元SDU</strong>(Service Data Unit),它可以和PDU不一样</p>
<p><strong>TCP/IP体系结构</strong>：<br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.3ecsYu-PTfzEhcQnDPbWjgAAAA?w=197&amp;h=132&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="TCP/IP体系结构 的图像结果"></p>
<p>TCP/IP协议可以<strong>为各式各样的应用提供服务</strong>，同时TCP/IP协议也<strong>允许IP协议在各式各样的网络构成的互联网上运行</strong><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.TrBY3slvUtRUihT72Q8krwAAAA?w=245&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="TCP/IP体系结构 的图像结果"></p>
<h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><h3 id="局域网设备"><a href="#局域网设备" class="headerlink" title="局域网设备"></a>局域网设备</h3><p><strong>集线器Hub</strong>：多端口中继器，用于连接个人计算机，属于<strong>物理层</strong></p>
<ul>
<li>用于重新生成和定时网络信号</li>
<li>传播信号</li>
<li><strong>无法过滤流量</strong></li>
<li><strong>无法确定最佳路径</strong></li>
<li>用作网络集中点</li>
<li>有时称为多端口中继器</li>
</ul>
<p><strong>网桥Bridge</strong>：连接两个相同结构的局域网，并对流经网桥的数据进行转发，属于<strong>数据链路层</strong></p>
<ul>
<li>目的是<strong>过滤局域网上的流量</strong>，使流量保持在本地，同时允许连接到局域网的其他部分以获取指向那里的流量</li>
<li>跟踪网桥两侧的MAC地址，并根据该MAC地址列表做出决策</li>
<li>在网段之间收集和发送数据报</li>
<li><strong>创建冲突域</strong></li>
<li>维护地址表</li>
</ul>
<p><strong>交换机Switch</strong>：识别数据包中的MAC地址信息，然后根据MAC地址进行转发，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中，属于<strong>数据链路层</strong></p>
<ul>
<li>用于集中连接</li>
<li>结合了集线器的连通性和网桥的流量控制</li>
<li>将帧从传入端口切换到传出端口，为每个端口提供全带宽</li>
<li>提供单独的数据路径</li>
</ul>
<p><strong>路由Router</strong>：连接不同的网络并完成路径选择和分组转发，属于<strong>网络层</strong></p>
<ul>
<li><strong>大型网络中重要的流量调节装置</strong></li>
<li>根据网络地址做出决策</li>
<li>检查数据包（第3层数据），为它们选择最佳路径，然后将它们切换到正确的输出端口</li>
<li>两个主要目的：<u>路径选择和数据包切换到最佳路由</u></li>
</ul>
<p><strong>主机Hosts</strong>：直接连接到网段的设备，并不从属于任何层</p>
<p><strong>中继器Repeaters</strong>：用于对数字信号进行再生，以扩展局域网段的长度，驱动长距离通信。属于<strong>物理层</strong></p>
<ul>
<li><u>用于延长网络的长度</u></li>
<li>清除、放大和重新发送被长电缆削弱的信号</li>
<li>在比特级重新生成（放大）并重新定时网络信号，使其能够在媒体上传播更长的距离</li>
<li><strong>不执行筛选</strong></li>
</ul>
<h3 id="广域网设备"><a href="#广域网设备" class="headerlink" title="广域网设备"></a>广域网设备</h3><p><strong>路由Router</strong>：连接不同的网络并完成路径选择和分组转发，属于<strong>网络层</strong></p>
<p><strong>调制解调器Modem CSU/DSU TA/NT1</strong>: 模拟到数字信号，实现远程局域网连接</p>
<p>集线器和中继器的区别：</p>
<ul>
<li>中继器通常只有两个端口，集线器通常有四到二十个或更多端口</li>
<li>中继器在一个端口接收，在另一个端口重复，而集线器在一个端口接收，在所有其他端口发送</li>
<li>集线器常见于以太网10BaseT或100BaseT网络中</li>
</ul>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>当两个比特在同一网络上同时传播时，会发生冲突</p>
<p>通过添加<strong>中继器和集线器</strong>来扩展冲突域</p>
<ul>
<li>不会分割</li>
</ul>
<p>可以通过添加<strong>网桥、交换机和路由器</strong>等智能设备对网络进行分割</p>
<p>当超过延迟限制时，后期冲突的数量会急剧增加</p>
<p><strong>延迟冲突</strong>是指在传输帧的前64个字节后发生冲突</p>
<p>这些延迟冲突帧增加的延迟称为<strong>消耗延迟</strong></p>
<p>随着消耗延迟和延迟的增加，网络性能下降</p>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2023/11/06/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>对于不同帧使用同一方案进行处理</li>
<li>希望通过<strong>路由选择算法</strong>进行路径选择和转发，对第二层是透明的</li>
<li>只能避免拥塞，<strong>不能流量控制</strong></li>
</ul>
<h3 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h3><ul>
<li>使用<strong>分层寻址方案</strong>，方便逐步细化目的地地址</li>
<li>细分网络并控制流量</li>
<li>减少交通堵塞，基于IP做<strong>分段和传达</strong>，用来减少拥塞</li>
<li>与其他网络交谈</li>
<li>对于不同的数据链路层的帧，第三层基于IP协议，来实现<strong>跨介质</strong>的逻辑理解和互通</li>
<li><p>负责进行连通和传达，<strong>数据可靠性由终端设备（第四层及以上）来进行保证</strong></p>
<p><strong>路由器</strong>  </p>
<ul>
<li>互连网段或网络（分割网段）</li>
<li>根据IP地址做出合理的决定</li>
<li><u>根据路由表确定最佳路径</u></li>
<li>将数据报从入站端口切换到出站端口</li>
</ul>
</li>
</ul>
<ol>
<li>如果A网段的设备向路由器发送了一个B网段的广播地址，那么路由器会进行转发</li>
<li>如果A网段的设备发送的是<strong>本网段</strong>的广播地址，那么路由器不会进行转发（广播域划分）</li>
</ol>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>网际协议IP是TCP/IP体系中两个最主要的协议之一，配套使用的还有三个协议：</p>
<ul>
<li><strong>地址解析协议ARP</strong>(Address Resolution Protocol)</li>
<li><strong>网际控制报文协议ICMP</strong>(Internet Control Message Protocol)</li>
<li><strong>网际组管理协议IGMP</strong>(Internet Group Management Protocol)</li>
</ul>
<h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a>IP数据报格式</h3><p>数据格式常以32位（4字节）为单位来描述</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS8zNTllMDhhNTJmNjRkZWFhYzU1M2FkYjAxMzIzMjdhZC94bWxub3RlLzkxOTFDRjYzQkY0OTQzMENBM0I4RTY3NDA3OTBBMDA5LzE0MTY5?x-oss-process=image/format,png" alt="IP数据报格式_片偏移怎么计算_小皮子摘星星的博客-CSDN博客"></p>
<ul>
<li>首部的前一部分是<strong>固定长度</strong>，共20字节</li>
<li>首部固定部分后面是一些<strong>可选字段</strong>，长度可变</li>
</ul>
<p>首部固定部分中的各字段：</p>
<ol>
<li><p><strong>版本</strong>：IP协议的版本，共4位，广泛使用的版本是IPv4</p>
</li>
<li><p><strong>首部长度</strong>：首部长度的表示单位是<strong>32位字</strong>（4字节），可表示的最大十进制数值是15，共4位</p>
<ul>
<li>由于首部的固定长度是20字节，所以<u>首部长度字段最小值为5，最大值为60字节（$15 \times 4 = 60$）</u></li>
<li>IP分组的首部长度不是4的字节时，必须利用最后的填充字段加以填充，因此<strong>数据部分永远在4字节的整数倍开始</strong></li>
<li>最常用的是20字节，即首部长度为0101</li>
</ul>
</li>
<li><p><strong>区分服务</strong>：在旧标准中叫做<strong>服务类型</strong>，共8位，一般情况不使用这个字段</p>
</li>
<li><p><strong>总长度</strong>：首部和数据部分的长度和，单位为<strong>字节</strong>，共16位</p>
<ul>
<li>数据链路层设置了最大传输单元MTU，因此数据报的总长度不能超过规定的MTU值，不然会将数据报进行<strong>分片</strong>处理</li>
</ul>
</li>
<li><p><strong>标识(identification)</strong>：IP软件在存储器中维持一个计数器，每产生一个数据报计数器+1，并将此值赋给标识字段，当产生分片时就将标识字段的值复制给每一个分片，<strong>便于重装为完整的数据报</strong>，共16位</p>
</li>
<li><p><strong>标志(flag)</strong>：共3位，但只有两位有意义</p>
<ul>
<li>最低位为<strong>MF</strong>(More Fragment)，MF = 1表示后面还有分片，MF = 0表示这时若干数据报片的最后一个</li>
<li>中间一位是<strong>DF</strong>(Don’t Fragment)，表示不能分片，只有DF = 0才允许分片</li>
</ul>
</li>
<li><p><strong>片偏移</strong>：指出分片在原分组的相对位置（<u>相对于起点在何处开始</u>），偏移单位为<strong>8字节</strong>，共13位</p>
</li>
<li><p><strong>生存时间</strong>：数据报在网络中的寿命，防止无法交付的数据报无限制地在互联网中兜圈子，现在功能为<strong>跳数限制</strong>（至多可经过几个路由器），共8位</p>
</li>
<li><p><strong>协议</strong>：指出数据报携带的数据是使用何种协议，共8位</p>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625195505983.png" alt=""></p>
<ol>
<li><p><strong>首部校验和</strong>： 这个字段只检验数据报的首部，共16位</p>
</li>
<li><p>源地址：共32位</p>
</li>
<li><p>目的地址：共32位</p>
</li>
</ol>
<p>首部可变部分：<br>可变部分就是一个选项字段，选项字段用来支持排错、测量以及安全等措施，内容很丰富，最后用全0的填充字段补齐成为4字节的整数倍</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址就是给互联网上的每一台主机（或路由器）的每一个端口分配一个在全世界范围内<strong>唯一</strong>的32位标识符</p>
<p>IP地址分为若干类，但都由两个固定长度的字段组成，分别是<strong>网络号</strong>和<strong>主机号</strong><br><img src="https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTcuY25ibG9ncy5jb20vYmxvZy8xMzIxMTc5LzIwMTgwMS8xMzIxMTc5LTIwMTgwMTMwMTA1MjExODU5LTExMjIwNjczMjUucG5n.jpg" alt="如何对IP地址进行子网划分？"></p>
<ul>
<li>D类地址为<strong>组播/多播</strong>（一对多）</li>
<li>通常写法是<strong>点分十进制</strong>（每8位二进制加一个点）</li>
</ul>
<p>A类：0 ~127<br>B类：128~192<br>C类：192~223<br>D类：224~239<br>E类：240~255</p>
<p><strong>A类网络号只有7位可指派，但是一般不能指派全0和全1</strong></p>
<ul>
<li>全0表示本网络</li>
<li>全1用于环回测试（根本不是一个网络地址）</li>
</ul>
<p><strong>B类网络号只有14位可指派，但是网络地址128.0.0.0是不指派的</strong></p>
<ul>
<li>B类开始IP地址是128.1.0.0</li>
</ul>
<p><strong>C类网络号只有21位可指派，但是网络地址192.0.0.0是不指派的</strong></p>
<ul>
<li>C类开始IP地址是192.0.1.0</li>
</ul>
<p><strong>主机号一般不能取全0，也不能取全1</strong></p>
<ul>
<li>全0用来标识网段地址</li>
<li>全1用来表示网段的广播地址</li>
</ul>
<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.TYNOsvDz4d7HKYChR9cb_gHaCW?w=350&amp;h=110&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="一般不使用特殊IP地址 的图像结果"></p>
<ul>
<li>用交换机或网桥连接起来的若干个<strong>局域网</strong>仍属于一个网络</li>
<li>IP地址是一种逻辑地址</li>
</ul>
<h3 id="划分子网和构造超网"><a href="#划分子网和构造超网" class="headerlink" title="划分子网和构造超网"></a>划分子网和构造超网</h3><p>早期IP地址的设计不够合理，主要体现在：</p>
<ul>
<li><strong>IP地址空间利用率有时很低</strong></li>
<li><strong>两级IP地址不够灵活</strong></li>
</ul>
<p><strong>划分子网</strong>(subnetting)：在IP地址中增加一个<strong>子网号字段</strong>，也叫做子网寻址或者子网路由选择</p>
<ul>
<li>从<strong>主机号</strong>借用若干位作为子网号，从而变成三级IP地址：<u>网络号、子网号、主机号</u></li>
<li>减小了广播域，提高网络利用率</li>
</ul>
<p>子网可以借用的位数：</p>
<ul>
<li><strong>最小位数是2</strong>：当只借用1位时就只能表示本网络和广播</li>
<li><strong>最大位数可以是保留<u>至少2位主机号</u>的任何数字</strong><ul>
<li>A类20位</li>
<li>B类14位</li>
<li>C类6位</li>
</ul>
</li>
<li>借用4位是最高效率的</li>
</ul>
<p>32位IP地址本身以及数据报首部都没有包含任何有关子网划分的信息，因此我们可以使用<strong>子网掩码</strong>(subnet mask)来确认数据报属于哪个子网</p>
<ul>
<li>把网络号和子网号全赋1，主机号全赋0<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.Yru1afxE6AChjauViBlaKgHaDe?pid=ImgDet&amp;rs=1" alt="计算机网络子网划分相关知识点 | 张甲博客"></li>
</ul>
<p>子网掩码和IP地址<strong>逐位相与</strong>，就可以得到子网的网络地址<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.fjola4pnIU8GGA84wtpjSwAAAA?pid=ImgDet&amp;rs=1" alt="IP2——IP地址和子网划分学习笔记之《子网掩码详解》 - 白灰 - 博客园"></p>
<ul>
<li>不管有没有划分子网，与运算后都能得出网络地址</li>
</ul>
<p><strong>默认子网掩码</strong>：</p>
<ul>
<li>A类：255.0.0.0</li>
<li>B类：255.255.0.0</li>
<li>C类：255.255.255.0</li>
</ul>
<p>子网数 = $2 ^ n$ - 2</p>
<ul>
<li>子网号有n位</li>
<li>除去全0和全1（实际上在CIDR协议中已经可以使用这两种情况了）</li>
</ul>
<p><strong>无分类编制CIDR（构建超网）</strong>：<br>在一个划分子网的网络中可同时使用几个不同的子网掩码，使用<strong>可变子网掩码VLSM</strong>(Variable Length Subnet Mask)可进一步提高IP地址资源利用率。在VLSM的基础上又进一步研究出<strong>无分类编制路由选择CIDR</strong>(Classless Inter-Domain Routing)</p>
<ol>
<li><p><strong>网络前缀</strong> </p>
<p> <u>CIDR消除了传统的A类、B类、C类地址以及划分子网的概念</u>，而是把互联网地址分为<strong>网络前缀和主机号</strong></p>
<ul>
<li>使用<strong>斜计线法</strong>（CIDR记法），即在IP地址后面加上斜线“\”，然后写上网络前缀所占的位数</li>
<li><p>把<strong>网络前缀相同的连续IP地址</strong>组成一个“CIDR地址块”，我们只要知道CIDR地址块中任何一个地址，就可以知道<u>起始地址和最大地址以及地址数</u></p>
<p>为了更方便的进行路由选择，CIDR使用32位的<strong>地址掩码</strong>(address mask)，也可以继续称作子网掩码</p>
</li>
<li>网络前缀赋为1，主机号赋为0</li>
<li><p>分配到地址块后仍可以划分子网，但是借用的位应当加入到网络前缀</p>
<p>路由表利用CIDR地址块查找目的网络，这种地址的聚合常称为<strong>路由聚合</strong>(route aggregation)，也称为<strong>构成超网</strong></p>
<p>CIDR记法有多种形式：</p>
</li>
<li>地址块10.0.0.0/10可以简写为10/10，也就是<u>把点分十进制中低位连续的0省略</u></li>
<li><p>在网络前缀的后面加个*，例如00001010 00*，意思是<u>*之前是网络前缀，*之后是主机号，可以是任意数字</u></p>
<p>从表格可以看出，除了最后几行，CIDR地址块都包含了多个C类地址（$2^n$倍），这就是<strong>构成超网</strong>一词的由来<img src="https://www.alloll.com/uploads/allimg/191126/1-191126150R3208.jpg" alt="划分子网和构造超网之无分类编址 CIDR_ 融合统一通信常见问题"></p>
</li>
<li><strong>网络前缀越短，包含的地址数越多</strong></li>
</ul>
</li>
<li><p><strong>最长前缀匹配</strong>（最长匹配/最佳匹配）<br>路由表项目和由<strong>网络前缀</strong>和<strong>下一跳地址</strong>组成</p>
<ul>
<li>可能查找路由表时不止一个结果</li>
</ul>
</li>
</ol>
<p>应该在匹配结果中选择具有<strong>最长网络前缀</strong>的路由</p>
<ol>
<li><strong>利用二叉线索查找路由表</strong><br>先找出对应于每一个IP地址的<strong>唯一前缀</strong><ul>
<li>唯一前缀就是在表中所有IP地址中，该前缀是唯一的</li>
</ul>
</li>
</ol>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.vmExsKBOvcUMvOS2VKIXdQHaCj?w=332&amp;h=120&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="二叉线索查找路由表 的图像结果"></p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>路由器有两个功能：<strong>路径选择、分组转发</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.mjDbeOQEQ6KjI4n-2QWWIAHaD_?w=288&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="二叉线索查找路由表 的图像结果"></p>
<ol>
<li><p><strong>分组转发</strong><br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220419103046677.png" alt=""></p>
<ul>
<li>在分类子网划分时，全0代表本机地址，全1代表广播地址</li>
<li><strong>做转发根据的是网段而不是具体的IP</strong></li>
</ul>
</li>
<li><p><strong>路径选择</strong><br>路由器根据路由规范，选择他当时认为最合适的路径</p>
<ul>
<li>选择数据包到达目的地的路径中的下一跳</li>
</ul>
</li>
</ol>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625100437411.png" alt=""></p>
<h3 id="路由器端口："><a href="#路由器端口：" class="headerlink" title="路由器端口："></a>路由器端口：</h3><p>接口是路由器连接到网络的附件，在IP路由中也可以称为<strong>端口</strong></p>
<ul>
<li>这个IP地址往往被称作这个<strong>网络的网关</strong></li>
<li>每个接口必须有一个单独的唯一网络地址<ul>
<li>比如S1和S2不能相同</li>
<li>路由器的连接的网段一定要不同·</li>
</ul>
</li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625100523538.png" alt=""></p>
<blockquote>
<ol>
<li>路由器端口记录了网段的IP地址（和连接的地方是相同的）</li>
<li>在计算需要分配的端口总数时，注意路由器的端口也需要算上</li>
</ol>
</blockquote>
<h3 id="IP地址分配："><a href="#IP地址分配：" class="headerlink" title="IP地址分配："></a>IP地址分配：</h3><ol>
<li><p><strong>静态地址分配</strong>(Static addressing)</p>
<ul>
<li>为每个单独的设备配置一个IP地址</li>
<li>保证不重复</li>
<li>需要知道规范，通过命令行进行分配</li>
</ul>
</li>
<li><p><strong>动态地址分配</strong>(Dynamic addressing)</p>
<ul>
<li><strong>反向地址解析RARP</strong>(Reverse Address Resolution Protocol)：发起请求根据IP地址信息来分配</li>
<li><strong>BOOTStrap协议(BOOTP)</strong>：用于工作栈 </li>
<li><strong>动态主机配置协议DHCP</strong>(Dtnamic Host Configuration Protocol)：IP地址和掩码处理后得到网络地址，保证每个网段中的主机的网段地址一致</li>
</ul>
</li>
</ol>
<h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><p><strong>ARP协议通过IP地址解析出MAC地址</strong></p>
<ul>
<li>在IP层抽象的互联网上只能看到IP数据报</li>
<li>在局域网的链路层只能看见MAC帧</li>
</ul>
<p>ARP协议在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表，并且<strong>动态更新</strong></p>
<ul>
<li>每台主机都设有一个ARP高速缓存(ARP cache)，里面有<strong>本局域网</strong>各主机和路由的IP地址到硬件地址的映射表（已知）</li>
</ul>
<p>主机A向<strong>本局域网</strong>上的主机B发送IP数据报过程：</p>
<ol>
<li><p>先在ARP高速缓存中查看有无主机B的IP地址</p>
<ul>
<li>如果有就查出硬件地址并写入MAC帧，然后发送</li>
<li>如果无就进行下面步骤</li>
</ul>
</li>
<li><p>广播发送ARP请求分组，内容为<strong>自身IP地址、自身硬件地址、想知道IP地址为xxx的主机的硬件地址</strong></p>
<ul>
<li>写入自身信息是便于以后主机B向主机A发送数据报</li>
</ul>
</li>
<li><p>IP地址一致的主机B收下ARP请求分组，并发送ARP响应分组，内容是<strong>自身IP地址、自身硬件地址</strong></p>
<ul>
<li>ARP响应分组是单播</li>
</ul>
</li>
<li><p>主机A收到ARP响应分组后就写入ARP高速缓存 </p>
</li>
</ol>
<p>主机发送给<strong>另一个网络</strong>上的另一主机数据报时，应该先找到相应的路由器进行转发，这时<u>需要把路由器的IP地址解析为硬件地址</u></p>
<p>为了使设备与另一网络上的零一设备通信，必须提供<strong>默认网关</strong></p>
<ul>
<li><strong>默认网关就是路由器连接到源主机所在网段的接口的IP地址</strong></li>
</ul>
<p>ARP四种典型情况：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMS5heDF4LmNvbS8yMDE4LzExLzIwL0Y5TlRITy5qcGc?x-oss-process=image/format,png#shadow" alt="网络层（七）地址解析协议ARP_数学家是我理想的博客-CSDN博客"></p>
<ol>
<li><p>主机$H_1$发送数据报到同一网络上的另一主机$H_2$。这时$H_1$发送ARP请求分组，找到$H_2$的硬件地址</p>
</li>
<li><p>主机$H_1$发送数据报到零一网络上的另一主机$H_3$或$H_4$，这时$H_1$发送ARP请求分组，找到路由器$R_1$的硬件地址，剩下的交给$R_1$，即下面的3和4</p>
</li>
<li><p>路由器$R_1$把数据报转发到与$R_1$相连的网2的主机$H_3$，这时$R_1$发送ARP请求分组，找到$H_3$的硬件地址</p>
</li>
<li><p>$R_1$要把数据报发送到网3上的主机$H_4$，这时$R_4$发送ARP请求分组，找到$R_2$的硬件地址，剩下的交给$R_2$</p>
</li>
</ol>
<h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><h3 id="面向连接的网络服务"><a href="#面向连接的网络服务" class="headerlink" title="面向连接的网络服务"></a>面向连接的网络服务</h3><p>在任何发送数据的行为之前，要先建立好连接，协商好参数才会开始传输，所有数据<strong>有序传输</strong></p>
<ul>
<li>网络情况导致数据出现问题，需要<strong>接收方进行一定处理</strong>来保证数据正确</li>
<li>传输过程要保持连接距离，只有完成传输才能断开连接</li>
<li>传输比较可靠，代价高</li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625100703902.png" alt=""></p>
<h3 id="无连接的网络服务"><a href="#无连接的网络服务" class="headerlink" title="无连接的网络服务"></a>无连接的网络服务</h3><p>不要求发送方和及受访在发送前先建立一个连接，分别对待每一个数据包，系统不需要进行大量的数据保留，不需要很多的缓存</p>
<ul>
<li>局域网使用比较多，<strong>可靠性比较低，不处理报文丢失</strong></li>
<li>少量报文使用无连接可以调高效率（可靠网）</li>
</ul>
<p><strong>IP就是提供无连接的网络服务</strong><br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625100711032.png" alt=""></p>
<h3 id="电路交换-Circuit-Switched"><a href="#电路交换-Circuit-Switched" class="headerlink" title="电路交换(Circuit Switched)"></a>电路交换(Circuit Switched)</h3><p>电路交换要先建立一个虚电路关系，之后报文走对应的虚电路</p>
<ul>
<li>所有数据包<strong>依次</strong>在同一虚拟通道上传播<ul>
<li>电路利用效率低</li>
<li>可能是分段建立，可能局部可以复用，但是<strong>整体不可以复用</strong></li>
</ul>
</li>
<li>虚电路强于面向连接，传输更可靠，<strong>保证传输先后关系</strong></li>
</ul>
<h3 id="报文交换-Packet-Switched"><a href="#报文交换-Packet-Switched" class="headerlink" title="报文交换(Packet Switched"></a>报文交换(Packet Switched</h3><p>当数据包从源传递到目标时，它们可以：</p>
<ol>
<li>切换到其他路径（根据当前的网络情况，进行路由选择）</li>
<li>乱序到达</li>
</ol>
<p><strong>将原始数据分为很多子报文，每个子报文自己选择路径进行发送</strong></p>
<ul>
<li>设备根据<strong>各种标准</strong>为每个数据包<strong>确定路径</strong>，某些标准可能因分组而异 </li>
<li>大部分无连接网络都是基于报文交换实现的，可以控制网络拥塞</li>
<li>出现问题时只需要重传对应部分的报文</li>
</ul>
<h2 id="网络协议操作"><a href="#网络协议操作" class="headerlink" title="网络协议操作"></a>网络协议操作</h2><p>被动路由协议用于路由器之间，保证路由器之间连通</p>
<p>主动路由用于做各自路由表的生成，路由器彼此交换信息</p>
<blockquote>
<p>routed protocol是用来使用路由表的<br>routing protocol是用来生成路由表的<br>routing protocol决定routed protocol</p>
</blockquote>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625100734720.png" alt=""></p>
<ul>
<li>存在冗余，A转发给B是由当前网络状况处理</li>
<li>ABC之间都是通过帧来今进行计算的</li>
</ul>
<h3 id="被动可路由协议Routed-protocol"><a href="#被动可路由协议Routed-protocol" class="headerlink" title="被动可路由协议Routed protocol"></a>被动可路由协议Routed protocol</h3><p>路由协议或可路由协议是<u>为网络层提供支持的协议</u></p>
<ul>
<li>IP是网络层协议，因此它可以通过互联网进行路由(routed)</li>
</ul>
<h3 id="不可路由协议Non-routable-protocol"><a href="#不可路由协议Non-routable-protocol" class="headerlink" title="不可路由协议Non-routable protocol"></a>不可路由协议Non-routable protocol</h3><p>不可路由协议是<u>不支持第三层的协议</u>，最常见的是NetBEUI</p>
<ul>
<li>直接根据目的方的地址在局域网中进行生成定位</li>
<li><strong>跨局域网也不支持第三层</strong></li>
<li><strong>NetBEUI仅限于在一个网段上运行</strong></li>
</ul>
<p>routing protocol是主动可路由协议也就是Dynamic routes</p>
<p><strong>被动可路由协议的寻址：</strong></p>
<p>将目的主机和子网掩码进行逻辑与运算得到对应的网段，然后请求路由表可以发现某个端口为目的网段，接着将报文封装转发给对应的主机</p>
<ul>
<li>路由表存储在内存中</li>
</ul>
<p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/44.png" alt=""><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/45.png" alt=""></p>
<h3 id="路由协议的分类"><a href="#路由协议的分类" class="headerlink" title="路由协议的分类"></a>路由协议的分类</h3><ol>
<li><p><strong>静态路由</strong>：<br>网络管理员在路由器中手动输入路由信息</p>
<ul>
<li>用于<strong>隐藏</strong>部分网络，安全（不进行路由表交换）</li>
<li>测试网络中的特定链接</li>
<li>用于仅在到达目标网络的路径时维护路由表</li>
</ul>
</li>
<li><p><strong>动态路由</strong>：<br>路由器在运行过程中互相学习信息，<strong>使用路由协议更新路由信息</strong>，如RIP、IGRP、EIGRP、OSPF等，人工维护代价比较大</p>
<ul>
<li>维护路由表</li>
<li>以路由更新的形式即使分发信息</li>
<li>路由器可以调整以适应不停变化的网络状况</li>
<li>打开后会启动进程，按照不同的协议和网上的不同设备学习信息，然后根据<strong>算法</strong>生成路由表</li>
</ul>
</li>
</ol>
<p>主动路由协议Routing protocol也是动态路由</p>
<ul>
<li>路由协议确定路由协议遵循的到达目的地的路径</li>
<li>用来构建路由表</li>
<li>公平、简单、适应变化</li>
</ul>
<h3 id="动态路由协议分类"><a href="#动态路由协议分类" class="headerlink" title="动态路由协议分类"></a>动态路由协议分类</h3><ol>
<li><p><strong>内部网关协议</strong>(Interior Gateway Protocols)：</p>
<p> 例如RIP，IGRP，EIGRP，OSPF等，可在自治系统中使用</p>
<ul>
<li>自治系统是<strong>逻辑</strong>的划分，而不是物理层次的划分</li>
<li><p>IGP是内部确定的管理规则</p>
<p>分类：</p>
</li>
</ul>
<ol>
<li><p><strong>距离矢量协议DVP</strong>(Distance-Vector Protocols)</p>
<p> 例如RIP、IGRP</p>
<ul>
<li>从<strong>邻居</strong>的角度查看网络拓扑（不是全局）</li>
<li>在路由器之间添加距离向量（根据跳数决定和）</li>
<li>经常会定期更新</li>
<li><p>将路由表<strong>副本</strong>传递到邻居路由器</p>
<p>示例：<br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625100916810.png" alt=""></p>
<ul>
<li>只知道最少跳数（<strong>不知道最佳路径</strong>）</li>
<li>定时路由表会相互交换给邻居</li>
</ul>
<p><strong>DVP的代表RIP</strong>(Routing Information Protocol)：</p>
<p>基于距离矢量的内部网关协议，<u>唯一指标是跳数</u>，选择<strong>走跳数最短的路径</strong>而非最快的路径，最受欢迎</p>
<ul>
<li>最大跳数是15</li>
<li><strong>每30秒更新一次（广播），可以修改</strong></li>
<li>RIP v2是RIP v1的改进版本，更加常用</li>
</ul>
<p><strong>IGRP</strong>(Interior Gateway Routing Protocol) 和 <strong>EIGRP</strong>(Enhanced IGRP)：</p>
<p>基于距离矢量的内部网关协议，指标由<strong>带宽、负载、延迟、可靠性组成</strong>，EIGRP是IGRP的高级版本，它是<strong>混合</strong>路由协议（不全根据跳数计算）</p>
<ul>
<li>IGRP最大跳数为255</li>
<li>每90秒更新一次</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>链路状态协议LSP</strong>(Link State Protocols)</p>
<p> 例如OSPF</p>
<ul>
<li>获取整个网络拓扑的通用视图（全局）</li>
<li>计算到其他路由器的最短路径</li>
<li>事件触发的更新</li>
<li><p>将链路状态路由更新传递给其他路由器</p>
<p>LSP操作过程：</p>
</li>
</ul>
<ol>
<li>相互交换彼此学到对应的Topological Database（全局）</li>
<li>使用SPF算法，以自己为根，通过最短路径优先算法，生成以自己为根的树</li>
<li><p>根据这一个树再生成路由表，逻辑是树的逻辑</p>
<p>示例：<br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220625100932511.png" alt=""></p>
<ul>
<li>彼此交换连接状态</li>
<li>LSP不是定时进行交换的，而是初始的时候进行交换，稳定之后根据事件触发的时候才会更新数据<ul>
<li>更新后发送给所有路由器，需要将Database发送给所有路由器</li>
<li>根据Database更新自己的树，然后再次生成路由表</li>
</ul>
</li>
<li>从所有可达的道路上找到<strong>代价最小</strong>的路径</li>
</ul>
<p><strong>LSP的代表OSPF</strong>(Open Shortest Path First)</p>
<ul>
<li>最短路径优先协议</li>
<li>本科阶段指标只考虑<strong>带宽</strong>  </li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>外部网关协议</strong>(Exterior Gateway Protocols)：例如EGP、BGP，<strong>用于自制形同之间路由数据报</strong></p>
<ul>
<li>通过BGP，让其他自治系统了解自己的自治系统中的网段（不同系统）</li>
</ul>
</li>
</ol>
<h2 id="因特网控制报文协议ICMP"><a href="#因特网控制报文协议ICMP" class="headerlink" title="因特网控制报文协议ICMP"></a>因特网控制报文协议ICMP</h2><p>ICMP为了提高IP数据报交付成功的机会，允许主机或路由器<strong>报告差错情况和提供有关异常情况的报告</strong>，一般路由器在丢弃报文的时候，都会返回一个ICMP差错报文</p>
<ul>
<li>ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去</li>
<li>ICMP只是IP层的协议</li>
</ul>
<p>ICMP报文格式：<br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721111746804.png" alt=""></p>
<p>数据字段如下：</p>
<ol>
<li>一般会把原始的 IP 数据报文的数据报首部 + 8 字节（数据的，可能会包含端口信息）作为 ICMP 的数据部分</li>
<li>ICMP 的前 8 个字节的是确定的（前 4 个字节是类型，校验位，后面四个字节是确定的）</li>
<li>然后添加一个首部作为 IP 数据报进行发送。<br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721111803208.png" alt=""></li>
</ol>
<p>两种ICMP报文：<br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20230721111752377.png" alt=""></p>
<ul>
<li><strong>查询报文</strong>：不是很多</li>
<li><strong>差错报告报文</strong>：比较多</li>
</ul>
<h3 id="目的站不可到达"><a href="#目的站不可到达" class="headerlink" title="目的站不可到达"></a>目的站不可到达</h3><ol>
<li><strong>网络</strong>不可到达（net unreachable）</li>
<li><strong>主机</strong>不可到达（host unreachable）</li>
<li><strong>协议</strong>不可到达（protocol unreachable）</li>
<li><strong>端口</strong>不可到达（port unreachable）</li>
<li><strong>源路由选择</strong>不能完成（source route failed）</li>
<li>目的网络<strong>不可知</strong>（unknown destination network）</li>
<li>目的主机<strong>不可知</strong>（unknown destination host）</li>
<li>不可知是完全不可以解析，不可达是可以解析但是不可以到达</li>
</ol>
<p><strong>下面几种情况不应该发送ICMP差错报文</strong>：</p>
<ol>
<li>对ICMP差错报文不再发送</li>
<li>对第一个分片的数据报片的所有后续数据报片</li>
<li>对具有多播地址的数据报</li>
<li>对具有特殊地址的数据报 </li>
</ol>
<h3 id="PING-Packet-InterNet-Groper"><a href="#PING-Packet-InterNet-Groper" class="headerlink" title="PING(Packet InterNet Groper)"></a>PING(Packet InterNet Groper)</h3><ol>
<li>PING 用来测试两个主机之间的连通性，一般是用来检查局域网的连通性：PING 不通，<u>不仅仅是发送不过去，有可能是应答不回来</u></li>
<li>PING 使用了<strong>ICMP 回送请求与回送回答报文</strong></li>
<li>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或 UDP</li>
</ol>
<h2 id="不同设备"><a href="#不同设备" class="headerlink" title="不同设备"></a>不同设备</h2><p><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220422114841185.png" alt=""><br><img src="https://eaglebear2002.github.io/2022Spring-%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97/%E4%BA%92%E8%81%94%E7%BD%91%E8%AE%A1%E7%AE%97-04-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF/image-20220422115043148.png" alt=""></p>
]]></content>
      <categories>
        <category>互联网计算</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语法</title>
    <url>/2023/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94SQL%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="通用语法及分类"><a href="#通用语法及分类" class="headerlink" title="通用语法及分类"></a>通用语法及分类</h2><p>MySQL语法：</p>
<ul>
<li><p>可以单行或多行书写，以分号结尾</p>
</li>
<li><p>可以使用空格和缩进提高可读性</p>
</li>
<li><p><strong>不区分大小写</strong>，关键字建议大写</p>
</li>
</ul>
<p>SQL分类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>DDL</td>
<td>Data Definition Language</td>
<td>数据定义语言，用来定义数据库对象(数据库、表、字段)</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manipulation Language</td>
<td>数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据查询语言，用来查询数据库中表的记录</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据控制语言，用来创建数据库用户，控制数据库的访问权限</td>
</tr>
</tbody>
</table>
</div>
<p>PS：<u>[…]为可选参数</u></p>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="数据库操作："><a href="#数据库操作：" class="headerlink" title="数据库操作："></a>数据库操作：</h3><ol>
<li><p>查询</p>
<ul>
<li><p>查询所有数据库：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前数据库：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名 [<span class="keyword">DEFAULT</span> CHARSET 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE[IF <span class="keyword">EXISTS</span>] 数据库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="表操作："><a href="#表操作：" class="headerlink" title="表操作："></a>表操作：</h3><ol>
<li><p>查询</p>
<ul>
<li><p>查询当前数据库所有表：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询表结构：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询指定表的建表语句：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>创建</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段<span class="number">1</span> 字段<span class="number">1</span>类型 [COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">	......</span><br><span class="line">	字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">) [COMMENT 表注释];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>最后一个字段后面没有逗号</p>
</li>
<li><p>添加字段</p>
</li>
</ul>
</li>
<li><p>修改</p>
<ul>
<li><p>添加字段</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释] [约束]</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据类型</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改字段名和字段类型、</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANEG 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表名</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li><p>删除字段</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除表</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定表，并重新创建该表（<strong>清除数据</strong>）</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><ol>
<li><p>添加数据</p>
<ul>
<li><p>给指定的字段添加数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,...) <span class="keyword">VALUES</span> (值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>给全部字段添加数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">VALUES</span> (值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量添加数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(字段名<span class="number">1</span>,字段名<span class="number">2</span>,...) <span class="keyword">VALUES</span> (值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">VALUES</span> (值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...),(值<span class="number">1</span>,值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>插入数据时，指定的字符顺序一定与值的顺序是一一对应的</li>
<li>字符串和日期型数据应该包含在引号中</li>
</ul>
</li>
<li><p>修改数据</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>,字段名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>,... [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure>
<ul>
<li>没有条件就会修改整张表的数据</li>
</ul>
</li>
<li><p>删除数据</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件];</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有条件会删除整张表的数据</li>
</ul>
</li>
</ol>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><p>DQL编写顺序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	字段列表 </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	分组后条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>
<p>DQL执行顺序：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	表名列表</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	分组后条件列表</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">	字段列表 </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">	分页参数</span><br></pre></td></tr></table></figure>
<ol>
<li><p>基本查询</p>
<ul>
<li><p>查询多个字段</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>,字段<span class="number">2</span>,字段<span class="number">3</span>,... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>* 表示查询全部字段</strong></li>
</ul>
</li>
<li><p>设置别名</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> [<span class="keyword">AS</span> 别名],字段<span class="number">2</span>[<span class="keyword">AS</span> 别名],... <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去除重复记录</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段列表 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>条件查询</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件列表;</span><br></pre></td></tr></table></figure>
</li>
<li><p>聚合函数</p>
<p> 定义：<u>将一列数据作为一个整体，进行纵向计算</u></p>
<ul>
<li><p><strong>不计算null值</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 聚合函数(字段列表) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>常用的聚合函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
<tr>
<td>avg</td>
<td>平均值</td>
</tr>
<tr>
<td>count</td>
<td>统计数量</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>分组查询</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件] <span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组字	段名 [<span class="keyword">HAVING</span> 分组后过滤条件];</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>不满足where条件不参与分组，且where不能对聚合函数进行判断</strong></p>
</li>
<li><p><strong>分组后不满足having条件过滤掉</strong></p>
</li>
</ul>
</li>
<li><p>排序查询</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>,字段<span class="number">2</span>,排序方式<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>排序方式</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASC</td>
<td>升序（默认）</td>
</tr>
<tr>
<td>DESC</td>
<td>降序</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>分页查询</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 LIMIT 起始索引,查询记录数;</span><br></pre></td></tr></table></figure>
<p> <strong>注意</strong>：</p>
<ol>
<li><p><strong>起始索引从0开始，$起始索引 = （查询页码 - 1）\times 每页记录数$</strong></p>
</li>
<li><p>分页查询是数据库的方言，不同数据库有不同的实现，MySQL中是LIMIT</p>
</li>
<li><p>如果查询的是第一页数据，起始索引可以省略</p>
</li>
</ol>
</li>
</ol>
<h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><ol>
<li><p>查询用户</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>主机名为 localhost 或 %（任意主机）</strong> </li>
</ul>
</li>
<li><p>修改用户密码</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>删除用户</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><ol>
<li><p>查询权限</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>授予权限、</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据库名和表名可以用 * 来表示所有</strong></li>
</ul>
</li>
<li><p>撤销权限</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span><span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>数据库名和表名可以用 * 来表示所有</strong></li>
</ul>
</li>
</ol>
<ul>
<li>多个权限之间要用逗号分隔</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2023/12/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CONCAT(S1, S2, …, Sn)</strong></td>
<td>字符串拼接</td>
</tr>
<tr>
<td><strong>LOWER(str)</strong></td>
<td>转小写</td>
</tr>
<tr>
<td><strong>UPPER(str)</strong></td>
<td>转大写</td>
</tr>
<tr>
<td><strong>LPAD(str, n, pad)</strong></td>
<td>用pad进行左填充，达到n个字符长度</td>
</tr>
<tr>
<td><strong>RPAD(str, n, pad)</strong></td>
<td>用pad进行右填充，达到n个字符长度</td>
</tr>
<tr>
<td><strong>TRIM(str)</strong></td>
<td>出去首部和尾部的空格</td>
</tr>
<tr>
<td><strong>SUBSTRING(str, start, len)</strong></td>
<td>截取字符串</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CEIL(x)</strong></td>
<td>向上取整</td>
</tr>
<tr>
<td><strong>FLOOR(x)</strong></td>
<td>向下取整</td>
</tr>
<tr>
<td><strong>MOD(x, y)</strong></td>
<td>取模</td>
</tr>
<tr>
<td><strong>RNAD()</strong></td>
<td>0·1之间的随机数</td>
</tr>
<tr>
<td><strong>ROUND(X, y)</strong></td>
<td>x四舍五入，保留y位</td>
</tr>
</tbody>
</table>
</div>
<h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CURDATE()</strong></td>
<td>当前日期</td>
</tr>
<tr>
<td><strong>CURTIME()</strong></td>
<td>当前时间</td>
</tr>
<tr>
<td><strong>NOW()</strong></td>
<td>当前日期和时间</td>
</tr>
<tr>
<td><strong>YEAR(date)</strong></td>
<td>指定date的年份</td>
</tr>
<tr>
<td><strong>MONTH(date)</strong></td>
<td>指定date的月份</td>
</tr>
<tr>
<td><strong>DAY(date)</strong></td>
<td>指定date的日期</td>
</tr>
<tr>
<td><strong>DATE_ADD(date, INTERVAL expr type)</strong></td>
<td>一个日期/时间值 加上一个时间间隔expr</td>
</tr>
<tr>
<td><strong>DATEDIFF(date1, date2)</strong></td>
<td>相差的天数(date1 - date2)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>DATE_ADD函数中的<strong>INTERVAL是固定要写的</strong>，type可以是<U>DAY、MONTH、YEAR</U></li>
</ul>
<h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IF(value, t, f)</strong></td>
<td>如果value为true则t，否则f</td>
</tr>
<tr>
<td><strong>IFNULL(value1, value2)</strong></td>
<td>如果value不为空则value1，否则value2</td>
</tr>
<tr>
<td><strong>CASE WHEN [val1] THEN [res1] … ELSE [default] END</strong></td>
<td>如果val1为true则res1，…，否则default默认值</td>
</tr>
<tr>
<td><strong>CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</strong></td>
<td>如果expr等于val1则res1，…，否则default默认值</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>多个目标要用多个when</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>概述</title>
    <url>/2023/11/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>MySQL数据库:</p>
<ul>
<li><p><strong>关系型数据库(RDBMS)</strong>：建立在关系模型基础上，由多张相互连接的二维表组成的数据库</p>
<ul>
<li><p>使用表存储数据，格式统一，便于维护</p>
</li>
<li><p>使用SQL语言操作，标准统一，使用方便</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.bhETLFjHWwkC_R78pgz0vwAAAA?pid=ImgDet&amp;rs=1" alt="MySQL:认识数据库_MySQL数据库的优点_About_yyyyyyy的博客-CSDN博客_mysql的优点"></p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="通用语法及分类"><a href="#通用语法及分类" class="headerlink" title="通用语法及分类"></a>通用语法及分类</h3><p>MySQL语法：</p>
<ul>
<li>可以单行或多行书写，以分号结尾</li>
<li>可以使用空格和缩进提高可读性</li>
<li><strong>不区分大小写</strong>，关键字建议大写</li>
</ul>
<p>SQL分类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>DDL</td>
<td>Data Definition Language</td>
<td>数据定义语言，用来定义数据库对象(数据库、表、字段)</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manipulation Language</td>
<td>数据操作语言，用来对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据查询语言，用来查询数据库中表的记录</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据控制语言，用来创建数据库用户，控制数据库的访问权限</td>
</tr>
</tbody>
</table>
</div>
<p>PS：<u>[…]为可选参数</u></p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th>数字类型</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1byte</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2bytes</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3bytes</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4bytes</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8bytes</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4bytes</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8bytes</td>
</tr>
<tr>
<td>DECIMAL</td>
<td>依赖精度和标度</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>可以在类型后面加入<strong>UNSIGNED</strong>表示无符号范围</li>
<li>浮点数（）内两个数分别表示<strong>整体长度和小数位数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符串类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR</td>
<td>0-255bytes</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0-65535bytes</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0-255bytes</td>
<td>不超过255个字符的二进制数据</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0-255bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0-65535bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0-65535bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0-16777215bytes</td>
<td>二进制形式的中长长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0-16777215bytes</td>
<td>中长长度文本数据</td>
</tr>
<tr>
<td>LONGBLOG</td>
<td>0-4294967295bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0-4294967295bytes</td>
<td>极大文本数据</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>CHAR和VARCHAR需要接上（）表示<strong>最大长度</strong></li>
<li><u>定长的空间会全部占用，性能比VARCHAR好</u></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>日期类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01至9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59至838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901至2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00至9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td>1970-01-01 00:00:01至2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值、时间戳</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>约束</title>
    <url>/2023/12/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="概述（感觉没什么要写的）"><a href="#概述（感觉没什么要写的）" class="headerlink" title="概述（感觉没什么要写的）"></a>概述（<del>感觉没什么要写的</del>）</h2><p>约束是<u>作用于表中字段上的规则</u>，用于<strong>限制存储在表中的数据</strong></p>
<p>目的：<u>保证数据库中数据的正确、有效性和完整性</u></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>非空约束</strong></td>
<td>限制该字段的数据不能为 null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td><strong>唯一约束</strong></td>
<td>保证该字段所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td><strong>主键约束</strong></td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td><strong>默认约束</strong></td>
<td>存储数据时，如果未指定该字段的值，则用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td><strong>检查约束</strong></td>
<td>保证字段值满足一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td><strong>外键约束</strong></td>
<td>用来让两张表的数据之间建立联系，保证数据的一致性和完整性</td>
<td>FOREIGN KEY</td>
</tr>
</tbody>
</table>
</div>
<h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><ol>
<li><p>添加外键</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	字段名 数据类型;</span><br><span class="line">	...</span><br><span class="line">	[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键名称;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除/更新行为"></a>删除/更新行为</h3><div class="table-container">
<table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NO ACTION</strong></td>
<td>当在父表中删除/更新对应记录时，应检查该记录是否有对应外键，如果有则不允许删除/更新</td>
</tr>
<tr>
<td><strong>RESTRICT</strong></td>
<td>当在父表中删除/更新对应记录时，应检查该记录是否有对应外键，如果有则不允许删除/更新</td>
</tr>
<tr>
<td><strong>CASCADE</strong></td>
<td>当在父表中删除/更新对应记录时，应检查该记录是否有对应外键，如果有，则也删除/更新外键在子表中的记录</td>
</tr>
<tr>
<td><strong>SET NULL</strong></td>
<td>当在父表中删除对应记录时，应检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求外键允许取null）</td>
</tr>
<tr>
<td><strong>SET DEFAULT</strong></td>
<td>父表有变更时，自建将外键列设置成一个默认的值（innodb不支持）</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表 (主表列名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> [行为] <span class="keyword">ON</span> <span class="keyword">DELETE</span> [行为]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>你曾是少年</title>
    <url>/2023/11/21/%E6%97%A5%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%A0%E6%9B%BE%E6%98%AF%E5%B0%91%E5%B9%B4/</url>
    <content><![CDATA[<p>2023.11.19晚，比赛还未结束，也许是暂时还没结束，但是我已经绝望地合上电脑，走出待了四个小时的教室</p>
<blockquote>
<p>我的手臂伤势恢复一直不错，我可以继续比赛，不过休息不是件坏事，我会考虑我的下一步选择<br>——the shy赛后采访</p>
</blockquote>
<p>其实走出来的那个时候，外面的冷风倒是没那么的刺，依稀记得，那个时候我脑海里的是：</p>
<blockquote>
<p>明凯你不要退役啊<br>——女粉丝</p>
</blockquote>
<p>小时候不懂得这一切背后的意义，只是单纯觉得：“有必要吗？不就是一场比赛而已。”</p>
<blockquote>
<p>shy哥你不要退役啊<br>——我的内心</p>
</blockquote>
<p>现在我上大学了，似乎懂得了一点点这份英雄暮年的无奈，也许会有一些素不相识的小孩疑惑着：“有必要吗？不就是一场比赛而已。”</p>
<p><strong>年少时射出的一颗子弹，经过多年，正中眉心</strong></p>
<p>虽然很不想承认，但是这轮比赛完完全全地让宙斯登上了上路的王座，不再年轻的你看着意气风发的宙斯，会不会满眼都是18岁的自己</p>
<p>我想啊，初二那年如果我没有看你的比赛，这几天也不会有如此感触吧</p>
<p>从8强开始看的比赛，或许不能算什么真正的粉丝，毕竟自我小学开始玩LOL的时候，冠军总是被faker斩获，因此总是对所谓的比赛提不起多大兴趣，但是你真的让我对早已失去的LOL职业比赛重燃信心</p>
<p>同样的上单位，你让我明白了原来可以这么玩游戏，原来可以这么压制，原来可以$\cdots \:\cdots$</p>
<p>虽然上了高中后再也没有时间玩LOL了，但是在难得的两周一天的回家时间，在凌晨，我还是愿意打开你的直播间，看你rank，甚至是看你吃夜宵，我想那些日子我应该也挺开心吧</p>
<p>后来啊，你被人们说靠小虎抬进的世界赛，被人们说瑞士轮1：2闹麻了，被人们嘲笑上限冠军，被人们说打个欧美弱鸡闹麻了，被人们说抽签组闹麻了，被人们说打个BLG闹麻了，直到一步步走到首尔，走到最大的舞台$\cdots \:\cdots$</p>
<p>而我看到的是，早已下坡的你一次次挽狂澜于既倒，扶大厦于将倾，直到决赛之前，你的世界赛表现堪称完美，甚至是让人看到了IG.The Shy的身影，因此我更加相信，你在今年拥有一个美满的结局</p>
<blockquote>
<p>The Shy向上天祈祷，回应他的只有18年的自己<br>——虎扑评论</p>
</blockquote>
<p>这样的评论，几乎在决赛前的每一局都能出现，我也那么以为，登神的剧本描述的是你，我们万分期待着，四号种子掀翻T1的剧情再次上演</p>
<p>决赛时候我看BP过程的担心，还是应验了：</p>
<ul>
<li><p>三楼出剑魔的话宙斯会出永恩</p>
</li>
<li><p>塞拉斯不ban不能拿大树</p>
</li>
</ul>
<p>毋庸置疑faker的表现无可挑剔，也许他生来就是LOL这个故事的主角：主角在年少时拿下三连冠，后来沉寂许久，最后在自己第10年职业生涯拿下第四个冠军。一切看起来都那么完美，但是啊，<strong>我不是主角的粉丝</strong>，我好像永远被困在18年的仁川了，这次shy哥还是没能把我们带回家，也许再也没有机会了</p>
<p>晚上路过茶百道的时候，wjy问我：“你还想喝橙露啵啵吗？”我苦笑了一阵，一时也说不出话来。但其实啊，不管你拿不拿得到这个冠军，我都只是<strong>希望能看你多打几局比赛</strong>，这对我来说就是已经足够了</p>
<p>现在看来，我一个星期前梦中WBG 2 : 0 T1的梦境显得那么荒谬，但是无论无论怎么样，我全程看完今年世界赛的眼睛告诉我你发挥已经极致</p>
<blockquote>
<p>下山的路太吵了，我听不见<br>——网友</p>
</blockquote>
<p>故事的开始：</p>
<blockquote>
<p>基地来了个孩子，他的锐雯在天上飞</p>
</blockquote>
<p>故事的尾声：</p>
<blockquote>
<p>很可惜走到决赛却输了，更可惜的是我觉得我年纪大了，如果我再年轻一点是不是可以过更精彩的人生<br>——the shy赛后采访</p>
</blockquote>
<p>我想啊，如果身体还允许的话，能不能再让我看你一年，不奢求能走到多远了，只希望你开开心心地结束自己作为选手的生涯。你的少年时期，已经看过山上的风景，这段路，已经足够伟大</p>
<blockquote>
<p>许多年前，你有一双清澈的双眼<br>奔跑起来，就像一道春天的闪电<br>——焦迈奇《你曾是少年》</p>
</blockquote>
<p>我明白时光不能倒转，但是我还是很怀念我的初二，很怀念我初识你的时候，一切都能重新来过</p>
]]></content>
      <categories>
        <category>所念</category>
      </categories>
      <tags>
        <tag>所念</tag>
      </tags>
  </entry>
  <entry>
    <title>内部存储器</title>
    <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>存储器由一定数量的单元构成，每个单元可以被唯一标识，<u>每个单元都有存储一个数值的能力</u></p>
<ul>
<li><p><strong>地址</strong>：单元的唯一标识符</p>
</li>
<li><p><strong>地址空间</strong>：可唯一标识的单元总数</p>
</li>
<li><p><strong>寻址空间</strong>：<u>存储在每个单元中的信息的位数</u></p>
<ul>
<li>大多数存储器是<strong>字节寻址</strong>的</li>
</ul>
</li>
</ul>
<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.U_KazHXkAlJ1Ox3D238pSwHaEv?rs=1&amp;pid=ImgDetMain" alt="存储器层次结构_存储系统的层次结构_亚撒西带师的博客-CSDN博客"></p>
<h2 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h2><p><strong>位元</strong>(memory cell)：半导体存储器的基本元件，用于存储<strong>1位</strong>数据</p>
<ul>
<li><p><strong>呈现两种稳态（或半稳态）</strong>：分别表示二进制的0和1</p>
</li>
<li><p><strong>能够至少被写入数据一次</strong>：用来设置状态</p>
</li>
<li><p><strong>能够被读取来获取状态信息</strong></p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-1.png" alt=""></p>
<p>半导体存储器类别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>种类</th>
<th>可擦性</th>
<th>写机制</th>
<th>易失性</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机存取存储器(RAM)</td>
<td><strong>读-写存储器</strong></td>
<td>电可擦除，字节级</td>
<td>电</td>
<td><strong>易失</strong></td>
</tr>
<tr>
<td>只读存储器(ROM)</td>
<td>只读存储器</td>
<td><strong>不可能</strong></td>
<td><strong>掩膜</strong></td>
<td>非易失</td>
</tr>
<tr>
<td>可编程ROM(PROM)</td>
<td>只读存储器</td>
<td><strong>不可能</strong></td>
<td>电</td>
<td>非易失</td>
</tr>
<tr>
<td>可擦除PROM(EPROM)</td>
<td>主要进行读操作的存储器</td>
<td>紫外线可擦除，芯片级</td>
<td>电</td>
<td>非易失</td>
</tr>
<tr>
<td>电可擦除PROM(EEPROM)</td>
<td>主要进行读操作的存储器</td>
<td>电可擦除，字节级</td>
<td>电</td>
<td>非易失</td>
</tr>
<tr>
<td>快闪存储器</td>
<td>主要进行读操作的存储器</td>
<td>电可擦除，块级</td>
<td>电</td>
<td>非易失</td>
</tr>
</tbody>
</table>
</div>
<h3 id="随机存取存储器-RAM"><a href="#随机存取存储器-RAM" class="headerlink" title="随机存取存储器(RAM)"></a>随机存取存储器(RAM)</h3><p>特性：</p>
<ul>
<li><p>可以简单快速地进行读/写操作</p>
</li>
<li><p><strong>易失的（Volatile）</strong></p>
</li>
</ul>
<p>类型：</p>
<ol>
<li><p><strong>DRAM（动态RAM）</strong>：</p>
<p> 在电容器上用<strong>电容充电</strong>的方式存储数据</p>
<ul>
<li><p>电容器有无电荷分别代表二进制1和0</p>
<p><strong>需要周期地充电刷新以维护数据存储</strong></p>
</li>
<li><p><u>电容器有漏电的自然趋势</u></p>
</li>
<li><p>有一个阈值来确定电荷是解释为1还是0</p>
</li>
<li><p>刷新是<strong>异步刷新</strong></p>
<p>传统DRAM是异步的</p>
</li>
</ul>
<ol>
<li><p>处理器向内存提供地址和控制信号，表示内存中特定单元的一组数据应该被读出或写入DRAM </p>
</li>
<li><p>DRAM执行各种内部功能，如激活行和列地址线的高电容，读取数据，以及通过输出缓冲将数据输出，<strong>处理器只能等待这段延迟，即存取时间</strong></p>
</li>
<li><p>延时后，DRAM才写入或读取数据</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-3.png" alt=""></p>
</li>
</ol>
</li>
<li><p><strong>SRAM（静态RAM）</strong>：</p>
<p> 使用<strong>传统触发器、逻辑门配置</strong>来存储二进制值</p>
<ul>
<li><p>使用与处理器相同的逻辑元件</p>
<p><strong>只要有电源，就可以一直维持数据</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-4.png" alt=""></p>
</li>
</ul>
</li>
</ol>
<h4 id="DRAM和SRAM对比"><a href="#DRAM和SRAM对比" class="headerlink" title="DRAM和SRAM对比"></a>DRAM和SRAM对比</h4><p><strong>相同</strong>：</p>
<ul>
<li><strong>易失性</strong>：<u>两者都要求电源持续供电才能保持位值</u></li>
</ul>
<p><strong>不同</strong>：</p>
<ul>
<li><p>DRAM具有更简单、更小的位元，但要求能支持刷新的电路</p>
</li>
<li><p>DRAM密度更高，价格更低</p>
</li>
<li><p>SRAM通常更快</p>
</li>
<li><p>DRAM倾向满足大容量存储器的需求，<strong>SRAM一般用于高速缓存，SRAM用于主存</strong></p>
</li>
</ul>
<h4 id="高级DRAM架构"><a href="#高级DRAM架构" class="headerlink" title="高级DRAM架构"></a>高级DRAM架构</h4><p>传统的DRAM芯片受到其内部架构与处理器内存总线接口的限制</p>
<p>类型：</p>
<ol>
<li><p><strong>SDRAM（同步DRAM）</strong>：</p>
<p> SDRAM与处理器的数据交互同步与外部的时钟信号，并且以处理器/存储器总线的<strong>最高速度</strong>运行，<strong>不需要插入等待状态</strong></p>
<ul>
<li><p>由于<strong>SDRAM随系统时钟及时移动数据</strong>，CPU直到数据何时准备好，控制器可以完成其他工作</p>
</li>
<li><p>异步是需要再次沟通的，而<strong>同步是减少一些交互，确定具体的交互时间（延迟时间）</strong></p>
<p>数据读写是在时钟周期的<strong>上升点</strong>进行</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-5.png" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>DDR SDRAM（双速率SDRAM）</strong>：</p>
<p> 每个时钟周期发送两次数据，<strong>一次在时钟脉冲的上升沿，一次在下降沿</strong></p>
<p> DDR $\rightarrow$ DDR2 $\rightarrow$ DDR3 $\rightarrow$ DDR4</p>
<ul>
<li><p>增加操作频率</p>
</li>
<li><p>增加预取缓冲区</p>
</li>
</ul>
</li>
</ol>
<h3 id="只读存储器-ROM"><a href="#只读存储器-ROM" class="headerlink" title="只读存储器(ROM)"></a>只读存储器(ROM)</h3><p>特性：</p>
<ul>
<li><p><strong>非易失性</strong>：不要求供电来维持数据</p>
</li>
<li><p><strong>只可读</strong>：但不能写入新数据</p>
</li>
</ul>
<p>应用：</p>
<ul>
<li>微程序设计、库子系统、系统程序、函数表</li>
</ul>
<p>问题：</p>
<ul>
<li><p><strong>无出错处理机会</strong></p>
</li>
<li><p><strong>用户无法写入数据</strong></p>
<ul>
<li>唯一的数据写入机会在出厂时完成</li>
</ul>
</li>
</ul>
<h3 id="可编程ROM-PROM"><a href="#可编程ROM-PROM" class="headerlink" title="可编程ROM(PROM)"></a>可编程ROM(PROM)</h3><p>PROM提供了灵活性和方便性，在大批量生产领域仍具有吸引力</p>
<p>特性：</p>
<ul>
<li><p><strong>非易失性</strong></p>
</li>
<li><p><strong>只能写入一次</strong></p>
<ul>
<li><p>写过程是用电信号执行</p>
</li>
<li><p>需要特殊设备来完成写或“编程”过程</p>
</li>
</ul>
</li>
</ul>
<h3 id="可擦除可编程“只读”存储器-EPROM"><a href="#可擦除可编程“只读”存储器-EPROM" class="headerlink" title="可擦除可编程“只读”存储器(EPROM)"></a>可擦除可编程“只读”存储器(EPROM)</h3><p>EPROM比PROM更贵，但有<strong>可多次改写</strong>的优点</p>
<p>特性：</p>
<ul>
<li><p><strong>光擦除</strong>：在写操作前将封装芯片暴露在紫外线下</p>
<ul>
<li><p>所有的存储单元都便会相同的初始状态</p>
</li>
<li><p>每次擦除需要约20分钟</p>
</li>
</ul>
</li>
<li><p><strong>电写入</strong></p>
</li>
</ul>
<h3 id="电可擦除可编程“只读”存储器-EEPROM"><a href="#电可擦除可编程“只读”存储器-EEPROM" class="headerlink" title="电可擦除可编程“只读”存储器(EEPROM)"></a>电可擦除可编程“只读”存储器(EEPROM)</h3><p>与EPROM对比，EEPROM更贵，且密度低，支持小容量芯片</p>
<p>特性：</p>
<ul>
<li><p><strong>可以随时写入而不删除之前的内容</strong></p>
</li>
<li><p>只更新寻址到的一个或多个字节</p>
</li>
<li><p>写操作每字节需要几百微秒</p>
</li>
</ul>
<h3 id="快闪存储器"><a href="#快闪存储器" class="headerlink" title="快闪存储器"></a>快闪存储器</h3><p>价格和功能介于EPROM和EEPROM之间</p>
<p>特性：</p>
<ul>
<li><p><strong>电可擦除</strong></p>
<ul>
<li>与EEPROM相同</li>
</ul>
</li>
<li><p>擦除时间为几秒</p>
<ul>
<li>优于EPROM，不如EEPROM</li>
</ul>
</li>
<li><p><strong>可以在块级擦除，不能在字节级擦除</strong></p>
<ul>
<li>优于EPROM，不如EEPROM</li>
</ul>
</li>
</ul>
<h2 id="从位元到主存"><a href="#从位元到主存" class="headerlink" title="从位元到主存"></a>从位元到主存</h2><h3 id="寻址单元"><a href="#寻址单元" class="headerlink" title="寻址单元"></a>寻址单元</h3><p>寻址单元由<u>若干相同地址的位元</u>组成</p>
<p>每个寻址单元内的数据不能进行局部修改，而是<strong>整体修改</strong></p>
<p>寻址模式：</p>
<ul>
<li><p><strong>字节(Byte)</strong>：常用</p>
</li>
<li><p><strong>字(Word)</strong></p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-7.png" alt=""></p>
<h3 id="存储阵列"><a href="#存储阵列" class="headerlink" title="存储阵列"></a>存储阵列</h3><p>存储阵列由<u>大量寻址单元</u>组成</p>
<p>选中就是对行和列进行加电，然后<strong>同时被加电的地方被选中</strong></p>
<p><strong>随机访问</strong>：先读取地址，然后找到行和列，然后选中，所以<u>无论是什么单元，都是一样的访问时间</u></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-8.png" alt=""></p>
<h3 id="如何寻址"><a href="#如何寻址" class="headerlink" title="如何寻址"></a>如何寻址</h3><p>地址译码器：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-9.png" alt=""></p>
<h3 id="如何刷新"><a href="#如何刷新" class="headerlink" title="如何刷新"></a>如何刷新</h3><p><strong>存储周期</strong>：读/写一次所耗费的时间</p>
<ul>
<li>某行刷新一次的时间也等于一个存取周期</li>
</ul>
<p><strong>刷新间隔</strong>：所有存储单元都刷新一遍的时间</p>
<p>刷新类型：</p>
<ol>
<li><p><strong>集中式刷新(Centralized refresh)</strong></p>
<p> 停止读写操作，并刷新每一行</p>
<ul>
<li>刷新时无法操作内存</li>
</ul>
</li>
<li><p><strong>分散式刷新(Decentralized refresh)</strong></p>
<p> 在每个存储周期中，当读写操作完成时进行刷新</p>
<ul>
<li>会增加每个存储周期的时间</li>
</ul>
</li>
<li><p><strong>异步刷新(Asynchronous refresh)</strong></p>
<p> 每一行各自以64ms间隔刷新（按时间切割）</p>
<ul>
<li>效率高</li>
</ul>
</li>
</ol>
<h3 id="芯片"><a href="#芯片" class="headerlink" title="芯片"></a>芯片</h3><p>芯片引脚：</p>
<ul>
<li><p>Address：A0-A19</p>
</li>
<li><p>Data：D0-D7</p>
</li>
<li><p>Vcc：电源</p>
</li>
<li><p>Vss：地线</p>
</li>
<li><p><strong>CE：芯片允许引脚</strong></p>
</li>
<li><p>Vpp：程序电压</p>
</li>
<li><p><strong>WE：写允许</strong></p>
</li>
<li><p><strong>OE：读允许</strong></p>
</li>
<li><p><strong>RAS：行地址选通</strong></p>
</li>
<li><p><strong>CAS：列地址选通</strong></p>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt7/cpt7-10.png" alt=""></p>
<h3 id="模块组织"><a href="#模块组织" class="headerlink" title="模块组织"></a>模块组织</h3><ol>
<li><p><strong>位扩展</strong></p>
<p> 地址线不变，数据线增加</p>
<ul>
<li><p>使用8个4K*1bit的芯片组成4K*8bit的存储器</p>
<p><img src="https://pic1.zhimg.com/80/v2-668d7fef957899e9bc5d5790febdd3a8_1440w.webp" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>字扩展</strong></p>
<p> 地址线增加，数据线不变</p>
<ul>
<li><p>使用4个16K*8bit的芯片组成64K*8bit的存储器</p>
<p><img src="https://pic3.zhimg.com/80/v2-3a3f476d1753811c04e942031536caaa_1440w.webp" alt=""></p>
</li>
</ul>
</li>
<li><p><strong>字位扩展</strong></p>
<p> 地址线增加，数据线增加</p>
<p> 使用8个16K*4bit的芯片组成64K*8bit的存储器</p>
<p> <img src="https://pic3.zhimg.com/80/v2-edee52a951e146238e2b77bdf7563f6e_1440w.webp" alt=""></p>
</li>
</ol>
<h2 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h2><p>CPU的速度比内存的速度块，且两者的差距不断扩大，导致出现<strong>内存墙</strong></p>
<h3 id="Cache的基本思路"><a href="#Cache的基本思路" class="headerlink" title="Cache的基本思路"></a>Cache的基本思路</h3><p>在使用主存之余，添加一块小而快的Cache，<strong>存放主存中部分信息的副本</strong></p>
<ul>
<li>Cache位于CPU和主存之间，可以集成在CPU内部或作为主板上的一个模块</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-1.png" alt=""></p>
<h3 id="Cache运行流程"><a href="#Cache运行流程" class="headerlink" title="Cache运行流程"></a>Cache运行流程</h3><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-2.png" alt=""></p>
<ol>
<li><p><strong>检查</strong>：当CPU试图访问主存中的某个字时，会首先检查这个字是否在Cache中</p>
</li>
<li><p>检查后分两种情况：</p>
</li>
</ol>
<ul>
<li><p><strong>命中hit</strong>：如果在Cache则把这个字传送给CPU</p>
</li>
<li><p><strong>未命中miss</strong>：如果不在Cache，则将主存中包含这个字固定大小的块读入Cache中，然后<strong>再从Cache传送该字给CPU</strong></p>
</li>
</ul>
<p><strong>无论如何Cache都会首先访问Cache</strong></p>
<p>Cache通过<strong>标记tags</strong>来标识其内容在主存中的对应位置</p>
<ul>
<li>将Cache中每一行的标记和目标地址的标记进行比较，如果有相同即为命中</li>
</ul>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>定义：<u>处理器频繁访问主存中相同位置或相邻存储位置的现象</u></p>
<p>类型：</p>
<ol>
<li><p><strong>时间局部性</strong>：在相对较短的时间周期内，重复访问特定的信息</p>
<ul>
<li><p>也就是相同位置的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> factorial = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;  </span><br><span class="line">	factorial = factorial * i;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>空间局部性</strong>：在相对较短的时间周期内，访问相邻存储位置的数据</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">	score[i] = final[i] * <span class="number">0.4</span> + midterm[i] * <span class="number">3</span> + assign[i] * <span class="number">0.2</span> + activity[i] * <span class="number">0.1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>顺序局部性</strong>：线性排列并访问</li>
</ul>
</li>
</ol>
<p>由于时间局部性，将未命中的数据再返回给CPU的同时存放在Cache中，<strong>以便再次访问命中</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-4.png" alt=""></p>
<p>由于空间局部性，将包含所访问的字的块存储到Cache中，<strong>以便在访问相邻数据时命中</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-5.png" alt=""></p>
<p><u>搬一个块的时间要比一次次搬块内每个单元的时间要快</u>，因此Cache能节省时间</p>
<h4 id="平均访问时间"><a href="#平均访问时间" class="headerlink" title="平均访问时间"></a>平均访问时间</h4><p>设P是命中率，$T_c$是Cache的访问时间，$T_m$是主存的访问时间</p>
<ul>
<li><p><strong>使用Cache的平均访问时间</strong>：$T_a = p \times T_c + (1-P) \times (T_c + T_m) = T_c + (1 - P) \times T_m$</p>
<ul>
<li><p>命中率P越大，$T_c$越小，效果越好</p>
</li>
<li><p>如果想要$T_a &lt; T_m$，必须要求$P &gt; \frac{T_c}{T_m}$</p>
</li>
</ul>
</li>
</ul>
<h3 id="Cache容量"><a href="#Cache容量" class="headerlink" title="Cache容量"></a>Cache容量</h3><p>扩大Cache容量后果：</p>
<ul>
<li><p>增大命中率P</p>
</li>
<li><p>增加Cache的开销和访问时间$T_c$</p>
<ul>
<li>随着块的增大，P增长会放缓，因为过大就<strong>不满足局部性原理</strong>了</li>
</ul>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-6.png" alt=""></p>
<h3 id="映射功能"><a href="#映射功能" class="headerlink" title="映射功能"></a>映射功能</h3><p>实现主存块到Cache行的映射</p>
<p>映射方式的选择会影响Cache的组织结构</p>
<ul>
<li><p><strong>直接映射</strong></p>
</li>
<li><p><strong>全关联映射</strong></p>
</li>
<li><p><strong>组关联映射</strong></p>
</li>
</ul>
<h4 id="Cache和主存结构"><a href="#Cache和主存结构" class="headerlink" title="Cache和主存结构"></a>Cache和主存结构</h4><ol>
<li><p><strong>Cache</strong></p>
<ul>
<li><p>一行：tag + 行 + 字</p>
</li>
<li><p>一共m个块，也就是m行</p>
</li>
<li><p>tag是主存储器的一部分，用来<strong>识别当前储存的是哪一块</strong></p>
</li>
</ul>
</li>
<li><p>主存：字长，每一块（k字）</p>
</li>
</ol>
<h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p>将主存中的每个块映射到<strong>一个固定可用</strong>的Cache行中，适合大容量的Cache</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-8.png" alt=""></p>
<ul>
<li>$Cache行号 = 主存储器块号\: \% \:Cache行数$</li>
</ul>
<p>主存储器地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标记</th>
<th>Cache行号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>标记</strong>：地址中最高的n位，<strong>区分映射到同一行的不同块</strong></p>
<ul>
<li><p>$n = log_2M - log_2C$</p>
<ul>
<li>M为块数，C为Cache行数</li>
</ul>
</li>
<li><p>为了成本，要用尽可能少的位置存储tag</p>
</li>
</ul>
<p><strong>优点</strong>：简单、快速映射、快速检查</p>
<p><strong>缺点</strong>：两个块被重复使用的话有可能出现<strong>抖动</strong>的现象</p>
<h4 id="全关联映射"><a href="#全关联映射" class="headerlink" title="全关联映射"></a>全关联映射</h4><p>一个内存块可以装入Cache的<strong>任意一行</strong>，适合容量较小的Cache</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt8/cpt8-10.png" alt=""></p>
<p>主存储器地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标记（块号）</th>
<th>字（块内地址）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>优点</strong>：避免抖动</p>
<p><strong>缺点</strong>：实现起来比较复杂，搜索代价大，即检查的时候需要去访问Cache每一行</p>
<h4 id="组关联映射"><a href="#组关联映射" class="headerlink" title="组关联映射"></a>组关联映射</h4><p>Cache分为若干组，每一组包含相同数量的行，每个主存块被映射到<strong>固定组的任意一行</strong>，面向不同容量的Cache做了折中</p>
<p><img src="https://www.whuanle.cn/wp-content/uploads/2022/09/image-1663471542219.png" alt="Cache 的映射方式 - 面向云技术架构 - 痴者工良"></p>
<ul>
<li>$Cache组号 = 主存块号\: \% \:组数$</li>
</ul>
<p>K - 路组关联映射：<strong>K是每一组的行数</strong></p>
<ul>
<li><p>K=1则等价于直接映射</p>
</li>
<li><p>K=Cache行数则等价于全关联映射</p>
</li>
</ul>
<p>主存储器地址：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标记</th>
<th>Cache组号</th>
<th>块内地址</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p><strong>标记</strong>：地址中最高的n位，<strong>区分映射到同一组的不同块</strong></p>
<ul>
<li><p>$n = log_2M - log_2S$</p>
<ul>
<li>M为块数，C为组数</li>
</ul>
</li>
</ul>
<h4 id="三种映射方式对比"><a href="#三种映射方式对比" class="headerlink" title="三种映射方式对比"></a>三种映射方式对比</h4><p><strong>关联度</strong>：一个主存块映射到Cache中可能存放的位置个数</p>
<ul>
<li><p>直接映射：1</p>
</li>
<li><p>全关联映射：Cache行数</p>
</li>
<li><p>全关联映射：每组的行数</p>
</li>
</ul>
<p>关联度越低，则<u>命中率越低、判断是否命中的时间越短、标记所占额外空间开销越小</u></p>
<h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><h4 id="最近最少使用算法-LRU"><a href="#最近最少使用算法-LRU" class="headerlink" title="最近最少使用算法(LRU)"></a>最近最少使用算法(LRU)</h4><p>替换在Cache中<strong>最长时间未被访问</strong>的数据块</p>
<ul>
<li>可以设计一个USE位，<strong>未被访问则加1，被访问则置0，替换USE位最大的行</strong></li>
</ul>
<h4 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h4><p>替换在Cache中<strong>停留时间最长</strong>的数据块</p>
<h4 id="最不经常使用算法-LFU"><a href="#最不经常使用算法-LFU" class="headerlink" title="最不经常使用算法(LFU)"></a>最不经常使用算法(LFU)</h4><p>替换Cache中<strong>被访问次数最少</strong>的数据块</p>
<ul>
<li>每行设置一个计数器</li>
</ul>
<h4 id="随机替换算法-Random"><a href="#随机替换算法-Random" class="headerlink" title="随机替换算法(Random)"></a>随机替换算法(Random)</h4><p><strong>随机</strong>替换Cache中的数据块</p>
<h3 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h3><ul>
<li><p>如果没被修改，则该数据块可以直接被替换掉</p>
</li>
<li><p>如果被修改，则在替换掉该数据块之前，必须将修改后的数据块写回到主存对应位置</p>
</li>
</ul>
<h4 id="缓存命中时写策略"><a href="#缓存命中时写策略" class="headerlink" title="缓存命中时写策略"></a>缓存命中时写策略</h4><ol>
<li><p><strong>写直达</strong></p>
<p> 所有写操作<strong>同时</strong>对Cache和主存进行</p>
<p> <strong>优点</strong>：确保主存中的数据总是和Cache中的数据一致</p>
<p> <strong>缺点</strong>：产生大量的主存访问，减慢写操作</p>
</li>
<li><p><strong>写回法</strong></p>
<p> 先更新Cache中的数据，当Cache中某个数据块<strong>被替换</strong>，如果它被修改了，才被写回主存</p>
<ul>
<li><p>利用<strong>脏位</strong>或<strong>使用位</strong>表示是否被修改</p>
<p><strong>优点</strong>：减少访问主存的次数</p>
<p><strong>缺点</strong>：部分主存数据可能不是最新的（未发生替换但需要读主存的场景）</p>
</li>
</ul>
</li>
</ol>
<h4 id="缓存未命中写策略"><a href="#缓存未命中写策略" class="headerlink" title="缓存未命中写策略"></a>缓存未命中写策略</h4><ol>
<li><p><strong>写不分配</strong>：</p>
<p> 直接将数据写入主存，无需读入Cache，通常搭配<strong>写直达</strong></p>
<p> <strong>优点</strong>：避免Cache和主存数据不一致</p>
</li>
<li><p><strong>写分配</strong>：</p>
<p> 将数据所在的块读入Cache后，在Cache中更新内容，通常搭配<strong>写回法</strong></p>
<p> <strong>优点</strong>：减少写内存次数</p>
</li>
</ol>
<h3 id="行大小"><a href="#行大小" class="headerlink" title="行大小"></a>行大小</h3><ul>
<li><p>随着行大小的逐步增大，<strong>Cache命中率会增加</strong></p>
<ul>
<li>空间局部性</li>
</ul>
</li>
<li><p>行大小较大后，继续增加行大小，<strong>Cache命中率会下降</strong></p>
<ul>
<li>频繁替换</li>
</ul>
</li>
</ul>
<p>行太小，行数太多<strong>反时间局部性</strong></p>
<p>行太大，行数太少<strong>反空间局部性</strong></p>
<h3 id="Cache数目"><a href="#Cache数目" class="headerlink" title="Cache数目"></a>Cache数目</h3><p><strong>一级</strong></p>
<ul>
<li><p>将Cache与处理器置于同一芯片</p>
</li>
<li><p>减少处理器在外部总线上的活动，从而减少了执行时间</p>
</li>
</ul>
<p><strong>多级</strong></p>
<ul>
<li><p>当$L_1$未命中时，减少处理器对总线上DRAM或ROM的访问</p>
</li>
<li><p>使用单独的数据路径，代替系统总线在$L_2$缓存和处理器之间传输数据，部分处理器将$L_2$ Cache结合到处理器芯片上</p>
</li>
</ul>
<p><strong>统一</strong></p>
<ul>
<li><p>更高的命中率，在获取指令和数据的负载之间自动进行平衡</p>
</li>
<li><p>只需设计和实现一个Cache</p>
</li>
</ul>
<p><strong>分立</strong></p>
<ul>
<li>消除Cache在指令的取值/译码单元和执行单元之间的竞争，在任何基于指令的流水线的设计中都是重要的</li>
</ul>
]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数定理性质</title>
    <url>/2023/11/10/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AE%9A%E7%90%86%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<p>整理BY：<strong>Misayaas</strong></p>
<p>内容来自：<strong>《线性代数讲义》</strong></p>
<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><h3 id="克莱姆法则简单版"><a href="#克莱姆法则简单版" class="headerlink" title="克莱姆法则简单版"></a>克莱姆法则简单版</h3><p>若存在方程组$\begin{cases}<br>a_{11}x_1 + a_{12}x_2= b_1 \\<br>a_{21}x_1 + a_{22}x_2= b_2\\<br>\end{cases}$，</p>
<p>可令$\Delta = \begin{vmatrix}<br>a_{11} &amp; a_{12} \\<br>a_{21} &amp; a_{22} \\<br>\end{vmatrix}$，$\Delta_1 = \begin{vmatrix}<br>b_1 &amp; a_{12} \\<br>b_2 &amp; a_{22} \\<br>\end{vmatrix}$，</p>
<p>$\Delta_2 = \begin{vmatrix}<br>a_{11} &amp; b_1 \\<br>a_{21} &amp; b_2 \\<br>\end{vmatrix}$</p>
<p>则对该方程组有一下结论（可以递推更高阶）：</p>
<ol>
<li><p><strong>若$\Delta \neq 0$，则方程组有唯一的解，$x_1 = \frac{\Delta_1}{\Delta}，x_2 = \frac{\Delta_2}{\Delta}$</strong></p>
</li>
<li><p><strong>若$\Delta = 0$，但$\Delta_1,\Delta_2$不全为0，则方程组无解</strong></p>
</li>
<li><p><strong>若$\Delta = \Delta_1 = \Delta_2 =0$，则方程组有无穷多组解</strong></p>
</li>
</ol>
<p><strong>方程组解的结论</strong>：</p>
<ol>
<li><p>齐次线性方程组必有零解，非齐次方程都是非零解</p>
</li>
<li><p>含有n个未知数的n个方程的齐次线性方程组若<strong>有非零解，则它的行列式等于0</strong>（充要条件）</p>
</li>
</ol>
<h3 id="行列式基本性质"><a href="#行列式基本性质" class="headerlink" title="行列式基本性质"></a>行列式基本性质</h3><ol>
<li><p>某两行（列）对应成比例，则行列式的值为0</p>
</li>
<li><p>若行列式的<strong>某一行\列</strong>拆分成两行（列）元素的和，则行列式可以拆成两个行列式的和</p>
</li>
<li><p>行列式<strong>任一行\列</strong>的公因子可以提出称为该行列式的因子</p>
</li>
<li><p><strong>两行\列元素交换后，原行列式的值<u>差一个负号</u></strong></p>
</li>
</ol>
<h3 id="n阶行列式的性质"><a href="#n阶行列式的性质" class="headerlink" title="n阶行列式的性质"></a>n阶行列式的性质</h3><ol>
<li><p>行列式和它的转置行列式的值相等</p>
</li>
<li><p><strong>两行\列元素交换后，原行列式的值<u>差一个负号</u></strong></p>
<ul>
<li>两行（列）相等的行列式的值为0</li>
<li>行列式可以按任一行（列）展开</li>
</ul>
</li>
<li><p>行列式<strong>任一行\列</strong>的公因子可以提出称为该行列式的因子</p>
<ul>
<li><u>用k乘以行列式的某一行（列），其结果就等于用k去乘这个行列式</u></li>
</ul>
</li>
<li><p><strong>将行列式 的任意一行（列）乘以k加到另一方（列）上去，行列式的值不变</strong></p>
</li>
<li><p>行列式任一行（列）的元素与另一行（列）的代数余子式对应的乘积之和为0</p>
</li>
</ol>
<h3 id="反对称"><a href="#反对称" class="headerlink" title="反对称"></a>反对称</h3><p>一切奇数阶的反对称行列式都等于0</p>
<h3 id="范德蒙德行列式"><a href="#范德蒙德行列式" class="headerlink" title="范德蒙德行列式"></a>范德蒙德行列式</h3><p>$D = \begin{vmatrix}<br>1 &amp; 1 &amp; \cdots &amp;1\\<br>x_1 &amp; x_2 &amp; \cdots &amp;x_n\\<br>x_1^2 &amp; x_2^2 &amp; \cdots &amp;x_n^2\\<br>\vdots &amp; \vdots &amp;  &amp;\vdots\\<br>x_1^{n-1} &amp; x_2^{n-1}&amp; \cdots &amp;x_n^{n-1}\\<br>\end{vmatrix} = \prod_{1 \leq i \leq j \leq n}(x_j - x_i)$</p>
<h2 id="矩阵、向量"><a href="#矩阵、向量" class="headerlink" title="矩阵、向量"></a>矩阵、向量</h2><h3 id="奇异矩阵"><a href="#奇异矩阵" class="headerlink" title="奇异矩阵"></a>奇异矩阵</h3><p>如果|A| $\neq$ 0，则称矩阵A是<strong>非异矩阵</strong>，如果|A| = 0，则矩阵A是<strong>奇异矩阵或退化矩阵</strong></p>
<h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>结合律：（AB）C = A （BC）</p>
<p>数乘结合律：k（AB）= （kA）B = A（kB）</p>
<p><strong>分配律：A（B + C）= AB + AC</strong></p>
<ul>
<li>AO = OA = O；AE = EA = A</li>
</ul>
<p><strong>矩阵相乘的行列式</strong>：<u>|A$\cdot$B| = |A| $\cdot$ |B|</u></p>
<h3 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h3><ol>
<li><p>$(A^T)^T = A；|A^T| = |A|$</p>
</li>
<li><p>$(A + B)^T = A^T + B^T$</p>
</li>
<li><p>$(kA)^T = kA^T$</p>
</li>
<li><p>$(AB)^T = B^TA^T$</p>
</li>
</ol>
<h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><p>$A = \begin{vmatrix}<br>P_{11} &amp; P_{12} \\<br>P_{21} &amp; P_{22} \\<br>\end{vmatrix}$，则$A^T = \begin{vmatrix}<br>P_{11}^T &amp; P_{21}^T \\<br>P_{12}^T &amp; P_{22}^T \\<br>\end{vmatrix}$</p>
<h3 id="初等变换和初等矩阵"><a href="#初等变换和初等矩阵" class="headerlink" title="初等变换和初等矩阵"></a>初等变换和初等矩阵</h3><p>初等矩阵左（右）乘一个矩阵的结果就是<strong>对这个矩阵做相应的初等行（列）变换</strong></p>
<ul>
<li>左行右列</li>
</ul>
<p>推论：</p>
<ol>
<li><p>设A为$m \times n$矩阵，r(A) = r，则存在m阶可逆矩阵P和n阶可逆矩阵Q，使得$A = P\Lambda Q$ </p>
<ul>
<li>其中$\Lambda = \begin{vmatrix}<br>E_r &amp; O \\<br>O &amp; O_{(m -r)\times (n-r)} \\<br>\end{vmatrix}$</li>
</ul>
</li>
</ol>
<h3 id="等价"><a href="#等价" class="headerlink" title="等价"></a>等价</h3><p>等价关系具有<strong>自反性、对称性、传递性</strong>，若A和B等价，那么A可以经过<strong>有限次</strong>初等变换得到B</p>
<p><u>具有行等价关系的矩阵所对应的线性方程组有相同的解</u></p>
<h3 id="行梯型矩阵和行简化梯形矩阵"><a href="#行梯型矩阵和行简化梯形矩阵" class="headerlink" title="行梯型矩阵和行简化梯形矩阵"></a>行梯型矩阵和行简化梯形矩阵</h3><p>共同点：</p>
<ol>
<li><p>零行在最下面</p>
</li>
<li><p>从第一行起，每行第一个非零元素前面的零的个数逐行增加</p>
</li>
</ol>
<p>行简化阶梯型特有：</p>
<ol>
<li><strong>非零行第一个非零元素为1，其所在列其他元素为0</strong></li>
</ol>
<h3 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h3><p>矩阵的秩是<strong>非零子式的最高次数</strong>（<del>宋浩说的最重要</del>）</p>
<p>基础知识：</p>
<ol>
<li><p>$0 \leq r(A_{m \times n}) \leq min(m，n)$</p>
</li>
<li><p>$r(A^T) = r(A)$</p>
</li>
<li><p>$r(A) = n \Longleftrightarrow |A| \neq 0 \Longleftrightarrow A非异$</p>
</li>
<li><p><strong>初等变换不改变矩阵的秩</strong></p>
</li>
<li><p><u>任一满秩矩阵可以经过若干次初等行（列）变换变为单位矩阵</u></p>
</li>
</ol>
<h3 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h3><p>AB = BA = E且逆矩阵是<strong>唯一</strong>的</p>
<p>基本性质：</p>
<ol>
<li><p>若A可逆，则$A^{-1}$也可逆，且$(A^{-1})^{-1} = A$，且|$A^{-1}$| = $|A|^{-1}$ </p>
</li>
<li><p>若A可逆，则kA也可逆（k$\neq$ 0），且$(kA)^{-1} = k^{-1}A^{-1}$</p>
</li>
<li><p><strong>若A可逆，则$A^T$也可逆，且$(A^T)^{-1} = (A^{-1})^T$</strong></p>
</li>
<li><p><strong>若A、B为同阶可逆矩阵，则AB也可逆，且$(AB)^{-1} = B^{-1}A^{-1}$</strong></p>
</li>
</ol>
<p>推论：</p>
<ol>
<li><p><strong>矩阵A可逆的充要条件是：A为满秩矩阵</strong></p>
</li>
<li><p>矩阵A可逆的充要条件是：$|A| \neq 0，且A^{-1} = \frac{1}{|A|} A^*$</p>
</li>
</ol>
<h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><p>基本公式是：$AA^\ast = A^\ast A = |A|E$</p>
<p>推论：</p>
<ol>
<li><p><strong>设A为n阶方阵($n \geq 2$)，则$|A^*| = |A|^{n-1}$</strong></p>
</li>
<li><p><strong>设A为n阶方阵($n \geq 2$)，则$(A^\ast) ^\ast= |A|^{n-2}A$</strong></p>
</li>
</ol>
<h3 id="线性组合"><a href="#线性组合" class="headerlink" title="线性组合"></a>线性组合</h3><p>给定n维向量组A：$\alpha_1,\alpha_2,\cdots,\alpha_m$和同维向量 $\beta$，如果存在一组数$k_1,k_2,\cdots,k_m$，使得 $\beta = k_1\alpha_1+k_2\alpha_2+\cdots+k_m\alpha_m$，则称 $\beta$ 是向量组A的一个线性组合或称向量 $\beta$ 可由向量组A线性表示</p>
<p>性质：</p>
<ol>
<li><p>零向量是任何向量组 $\alpha_1,\alpha_2,\cdots,\alpha_m$ 的线性组合</p>
</li>
<li><p><strong>任何n维向量都可由 $e_1,e_2,\cdots,e_n$ 线性表示，向量组 $e_1,e_2,\cdots,e_n$ 也称为n维基本向量</strong></p>
</li>
</ol>
<h3 id="等价向量组"><a href="#等价向量组" class="headerlink" title="等价向量组"></a>等价向量组</h3><p>设有两个向量组A：$\alpha_1,\alpha_2,\cdots,\alpha_m$ 及B：$\beta_1,\beta_2,\cdots,\beta_m$，若A中的每个向量都可由向量组B线性表示，则称向量组A可由向量组B线性表示，<strong>若两个向量组A，B可以相互表示，则成这两个向量等价</strong></p>
<h3 id="线性相关和线性无关"><a href="#线性相关和线性无关" class="headerlink" title="线性相关和线性无关"></a>线性相关和线性无关</h3><p>定义：（<del>超级无敌重要啊啊啊啊啊</del>）</p>
<ol>
<li><p>给定一向量组A：$\alpha_1,\alpha_2,\cdots,\alpha_m$，如果存在<strong>不全为零</strong>的数 $k_1,k_2,\cdots,k_m$，使得 $k_1\alpha_1+k_2\alpha_2+\cdots+k_m\alpha_m = \theta$，那么称向量组A是<strong>线性相关</strong>的</p>
</li>
<li><p>如果只有当 $k_1=k_2=\cdots=k_m=0$ 时，上述等式才成立，那么就是<strong>线性无关</strong>的</p>
</li>
</ol>
<p><strong>线性相关的充要条件是：$x_1\alpha_1+x_2\alpha_2+\cdots+x_m\alpha_m = \theta$（$Ax = \theta$） 有非零解</strong></p>
<p>最基本的结论：</p>
<ol>
<li><p>一个向量线性相关的充要条件是： $\alpha = \theta$ </p>
</li>
<li><p>一个向量线性无关的充要条件是： $\alpha \neq \theta$ </p>
</li>
<li><p>包含零向量的向量组是线性相关的</p>
</li>
<li><p><strong>如果一个向量组的部分向量组线性相关，则该向量组也线性相关</strong></p>
</li>
<li><p><strong>如果一个向量组线性无关，则其中任一个部分分量也线性无关</strong></p>
</li>
</ol>
<p>定理：</p>
<ol>
<li><p>向量组A：$\alpha_1,\alpha_2,\cdots,\alpha_m$（$m \geq 2$）<strong>线性相关</strong>的充要条件是：<u>向量组A中<strong>至少有一个</strong>向量可由其余 m-1 个向量线性表示</u></p>
</li>
<li><p>向量组A：$\alpha_1,\alpha_2,\cdots,\alpha_m$（$m \geq 2$）<strong>线性无关</strong>的充要条件是：<u>其中<strong>任何一个</strong>向量都不能由其余向量线性表示</u></p>
</li>
<li><p>设向量组A：$\alpha_1,\alpha_2,\cdots,\alpha_r$ 线性无关，而向量组B：$\alpha_1,\alpha_2,\cdots,\alpha_r,\beta$ 线性相关，<strong>则向量 $\beta$ 必可由向量组A线性表示，并且表达式唯一</strong></p>
</li>
<li><p>设向量组A：$\alpha_1,\alpha_2,\cdots,\alpha_r$ 线性无关，则向量组B：$\alpha_1,\alpha_2,\cdots,\alpha_r,\beta$ 线性无关的充分必要条件是<strong>向量 $\beta$ 不可能由向量组A线性表示</strong></p>
</li>
</ol>
<h3 id="向量线性相关性与矩阵秩的关系"><a href="#向量线性相关性与矩阵秩的关系" class="headerlink" title="向量线性相关性与矩阵秩的关系"></a>向量线性相关性与矩阵秩的关系</h3><ol>
<li><p><strong>n维列向量组A：$\alpha_1,\alpha_2,\cdots,\alpha_r$ 线性相关的充要条件是： $r(A) &lt; r$，线性无关的充要条件是： $r(A) = r$</strong></p>
<ul>
<li><u>向量个数m大于维数n</u>，则该向量组<strong>线性相关</strong></li>
</ul>
</li>
<li><p>n个n维向量<strong>线性无关</strong>的充要条件是<u>其行列式不为0</u></p>
</li>
<li><p>设 $A_{m \times n}$ 的秩 $r(A) = r \leq m$ ，且 A 的某 r 列（行）组成的矩阵含有不等于零的r阶子式，则此 r 列（行）向量线性无关</p>
</li>
</ol>
<h3 id="极大无关组和向量组的秩"><a href="#极大无关组和向量组的秩" class="headerlink" title="极大无关组和向量组的秩"></a>极大无关组和向量组的秩</h3><p>极大无关组定理推论：</p>
<ol>
<li><p>设 $\alpha_{i_1},\alpha_{i_2},\cdots,\alpha_{i_r}$ 是向量组 $\alpha_1,\alpha_2,\cdots,\alpha_m$ 的一个极大无关组，则向量组 $\alpha_1,\alpha_2,\cdots,\alpha_m$ 中的任一向量可由 $\alpha_{i_1},\alpha_{i_2},\cdots,\alpha_{i_r}$ <strong>线性唯一表示</strong></p>
</li>
<li><p>一个向量组的各个极大无关组所含向量个数相同</p>
</li>
</ol>
<ol>
<li><p>向量组和它的极大无关组等价</p>
</li>
<li><p>一个向量组的各个极大无关组是等价的</p>
</li>
<li><p><strong>两个向量组等价的充要条件是：<u>一组的一个极大无关组与另一组的一个极大无关组等价</u></strong></p>
</li>
</ol>
<p>向量组的秩：</p>
<ol>
<li><p><strong>等价的向量组必有相同的秩</strong></p>
</li>
<li><p>任一矩阵的秩与其行秩、列秩相等</p>
</li>
<li><p><strong>秩的重要性质</strong>：</p>
<ul>
<li><p>$r(A + B) \leq r(A) + r(B)$</p>
</li>
<li><p>$r(AB) \leq min\{r(A)，r(B)\}$</p>
</li>
<li><p><strong>若A，B都为n阶方阵，$r(AB) \geq r(A) + r(B) - n$</strong></p>
</li>
</ul>
</li>
</ol>
<h2 id="线性代数组解的结构"><a href="#线性代数组解的结构" class="headerlink" title="线性代数组解的结构"></a>线性代数组解的结构</h2><h3 id="线性方程组的可解性"><a href="#线性方程组的可解性" class="headerlink" title="线性方程组的可解性"></a>线性方程组的可解性</h3><p>线性方程组<strong>有解</strong>的充要条件是：<u>系数矩阵A的秩等于增广矩阵B的秩</u></p>
<ul>
<li>$r(A) = r(B) = n$ 时，方程组有唯一解</li>
<li>$r(A) = r(B) \leq n$ 时，方程组有无穷多组解</li>
<li>$r(A) \neq r(B)$ 时，方程组无解</li>
</ul>
<h3 id="齐次方程组解的结构"><a href="#齐次方程组解的结构" class="headerlink" title="齐次方程组解的结构"></a>齐次方程组解的结构</h3><ol>
<li><p>若 $\alpha_1,\alpha_2$ 是方程组 $Ax = \theta$ 的解，则<strong>其线性组合 $k_1\alpha_1 + k_2\alpha_2$ 也是该方程组的解</strong></p>
</li>
<li><p>设 $A \in R^ { m \times n}$，若 $r(A) = n$ 时，则 $Ax = \theta$ 只有零解；若 $r(A) &lt; n$，则 $Ax = \theta$ 有非零解</p>
<ul>
<li><p>方程组 $r(A) = n$，$A \in R^ { m \times n}$ <strong>有非零解</strong>的充要条件是：<u>|A| = 0</u></p>
</li>
<li><p>若 $A \in R^ { m \times n}$，且m &lt; n，则 $Ax = \theta$ 有非零解 </p>
</li>
</ul>
</li>
<li><p>若齐次方程有非零解，则该方程组的基础解系并不唯一</p>
</li>
<li><p><strong>若齐次方程组的系数矩阵A的秩为r，则其基础解系的向量个数为$n-r$</strong></p>
</li>
</ol>
<h3 id="非齐次方程组解的结构"><a href="#非齐次方程组解的结构" class="headerlink" title="非齐次方程组解的结构"></a>非齐次方程组解的结构</h3><p>若 $A\eta =  b$（$b \neq \theta$），则 $Ax =  b$ 的通解为 $\eta + \alpha$</p>
<ul>
<li>其中 $\alpha$ 为 $Ax =  \theta$ 的解（<strong>齐次方程的解</strong>）</li>
<li><strong>若 $Ax =  \theta$ 的基础解系为    $\alpha_1,\alpha_2,\cdots,\alpha_r$，则 $A\eta =  b$ 的通解为$\eta + k_1\alpha_1 + k_2\alpha_2 + \cdots + k_r\alpha_r$</strong></li>
</ul>
<h2 id="矩阵的特征值线性无关和特征向量"><a href="#矩阵的特征值线性无关和特征向量" class="headerlink" title="矩阵的特征值线性无关和特征向量"></a>矩阵的特征值线性无关和特征向量</h2><h3 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h3><p>对于同阶方阵A与B，如果存在<strong>可逆矩阵P</strong>，使得 $B = P^{-1}AP$，则称A相似于B，记为 $A \sim B$，P称为A到B的<strong>相似变换矩阵</strong></p>
<ul>
<li>相似矩阵满足等价关系三个性质</li>
</ul>
<p>相似矩阵性质：</p>
<ol>
<li><p>若 $A \sim B$，则|A| = |B|，从而A和B可逆性相同</p>
</li>
<li><p>若 $A \sim B$，且A或B可逆，则 $A^{-1} \sim B^{-1}$</p>
</li>
<li><p>若 $A \sim B$，则 $A^n \sim B^n$，$kA \sim kB$</p>
</li>
<li><p>若 $A \sim B$，则 $f(A) \sim f(B)$，其中 $f(x) = \alpha_nx^n + \alpha_{n-1}x^{n-1}+\cdots +\alpha_1x^1+\alpha_0x^0$ 为任意多项式</p>
</li>
<li><p><strong>相似矩阵具有相同的特征多项式，从而有相同的特征值</strong></p>
<ul>
<li>特征多项式相同的矩阵未必相似</li>
</ul>
</li>
<li><p><strong>相似矩阵具有相同的迹和行列式</strong></p>
</li>
</ol>
<h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3><p><strong>特征多项式</strong>是：$|\lambda E - A| = 0$</p>
<ol>
<li><p>设方阵A有特征值 $\lambda$，$\xi_1,\xi_2$ 是属于$\lambda$ 的特征向量，则它们的<strong>任意不等于零向量的线性组合 $\eta = k_1\xi_1 + k_2\xi_2$ 仍是属于 $\lambda$ 的特征向量</strong></p>
<ul>
<li>属于 $\lambda$ 的特征向量有无数个</li>
</ul>
</li>
<li><p>若 $f(x)$ 为x的多项式，矩阵A有特征值 $\lambda$，则 $f(A)$ 有特征值 $f(\lambda)$</p>
</li>
<li><p>若n阶可逆方阵A的所有特征值为 $\lambda_1,\cdots,\lambda_n$（包含相同的特征值），则 $\lambda_i \neq 0$，且矩阵 $A^{-1}$ 的特征值为 $\lambda_1^{-1},\cdots,\lambda_n^{-1}$</p>
</li>
<li><p>若n阶矩阵A的特征值为 $\lambda_1,\cdots,\lambda_n$</p>
<ul>
<li><strong>主对角线之和等于特征值之和：$tr(A) = \sum_{i = 1}^n \lambda_i$</strong></li>
<li><strong>行列式的值等于特征值的乘积：$|A| = \prod_{i = 1}^n \lambda_i$</strong></li>
</ul>
</li>
<li><p>设A是一个块对角矩阵，$A =<br>\left(<br>\begin{matrix}<br>A_1 &amp; &amp; &amp; \\<br>&amp; A_2 &amp; &amp; \\<br>&amp; &amp; \ddots&amp;\\<br>&amp; &amp; &amp; A_m<br>\end{matrix}<br>\right)$<br>则A的特征多项式是 $A_1,A_2,\cdots,A_m$ 的特征多项式的乘积，于是 <strong>$A_1,A_2,\cdots,A_m$ 的所有特征值就是A的所有特征值</strong></p>
</li>
<li><p><u>m阶方阵AB与n阶方阵BA具有相同的非零特征值，且 $tr(AB) = tr(BA)$</u></p>
</li>
<li><p><strong>属于不同特征值的特征向量线性无关</strong></p>
</li>
<li><p>若 $\lambda_1,\lambda_2,\cdots,\lambda_n$ 是矩阵A的不同特征值，而A的属于 $\lambda_i$ 的线性无关的特征向量为 $\alpha_{i1},\alpha_{i2},\cdots,\alpha_{is_i}$，则向量组 $\alpha_{11},\cdots,\alpha_{1s_i},\alpha_{21},\cdots,\alpha_{2s_i},\cdots,\alpha_{m1},\cdots,\alpha_{ms_m}$ 线性无关</p>
</li>
<li><p><strong>设 $\lambda_0$ 是n阶方阵A的k重特征值，则A的属于特征值 $\lambda_0$ 的<u>线性无关</u>的特征向量的个数不超过k</strong></p>
</li>
</ol>
<h3 id="矩阵可对角化的条件"><a href="#矩阵可对角化的条件" class="headerlink" title="矩阵可对角化的条件"></a>矩阵可对角化的条件</h3><p>n阶矩阵可对角化的充要条件是：<strong>有n个线性无关的特征向量，且对角矩阵的主对角线由特征值组成，相似变换矩阵由属于相应特征值的特征向量构成</strong></p>
<ul>
<li><u>若n阶矩阵有n个互不相同的特征值，则矩阵可对角化</u></li>
</ul>
<p>n阶方阵可对角化的充要条件是：<strong>每个 $k_i$ 重特征值 $\lambda_i$ 对应的特征矩阵 $|\lambda_iE - A|$ 的秩为 $n-k_i$</strong></p>
<h3 id="向量内积"><a href="#向量内积" class="headerlink" title="向量内积"></a>向量内积</h3><ol>
<li>$(\alpha,\beta)=(\beta,\alpha)$</li>
<li>$(k\alpha,\beta)=k(\alpha,\beta)$</li>
<li>$(\alpha+\gamma,\beta)=(\alpha,\beta) + (\gamma,\beta)$</li>
<li>$(\alpha,\alpha)\geq0；(\alpha,\alpha)=0当且仅当\alpha = \theta$</li>
</ol>
<p>若 $(\alpha,\beta)=0$，则称 $\alpha$ 和 $\beta$ <strong>正交或垂直</strong></p>
<h3 id="正交向量和正交矩阵"><a href="#正交向量和正交矩阵" class="headerlink" title="正交向量和正交矩阵"></a>正交向量和正交矩阵</h3><p>若实矩阵满足 $A^TA=E$，则称A为<strong>正交矩阵</strong></p>
<ul>
<li><strong>若A，B是同阶的正交矩阵，那么AB也是正交矩阵</strong></li>
<li>E也为正交矩阵</li>
</ul>
<p>性质：</p>
<ol>
<li><p>正交向量组必线性无关</p>
</li>
<li><p>对于方阵A，下面一些条件互为<strong>等价</strong>：</p>
<ul>
<li><p><strong>A为正交矩阵</strong></p>
</li>
<li><p>$A^T=A^{-1}$</p>
</li>
<li><p>$AA^T=E$</p>
</li>
<li><p>A的列向量构成标准正交列向量组</p>
</li>
<li><p>A的行向量构成标准正交行向量组</p>
</li>
</ul>
</li>
<li><p>设A是n阶正交矩阵，$\lambda$ 是A的特征值，$\alpha$ 为n维列向量</p>
<ul>
<li><p>$|A|^2=1$（重要）</p>
</li>
<li><p>$(A\alpha)^T(\overline{A\alpha})=\alpha^T\overline{\alpha}$ </p>
</li>
<li><p>$|\lambda|=1$（也重要）</p>
</li>
</ul>
</li>
</ol>
<h3 id="实对称矩阵对角化"><a href="#实对称矩阵对角化" class="headerlink" title="实对称矩阵对角化"></a>实对称矩阵对角化</h3><p><strong>实对称矩阵一定可以对角化</strong></p>
<p>性质：</p>
<ol>
<li><p>实对称矩阵的特征值均是实数</p>
</li>
<li><p><strong>实对称矩阵的属于不同特征值的特征向量相互正交</strong></p>
</li>
<li><p>设有实n维单位列向量 $\beta$，则比能找到 n-1 个向量与 $\beta$ 一起构成由n个向量组成的标准正交向量组</p>
</li>
<li><p><strong>若A是实对称矩阵，则存在同阶的正交矩阵P使得 $P^TAP$ 是实对角矩阵，从而实对称矩阵可以对角化</strong></p>
</li>
</ol>
<h2 id="实二次型"><a href="#实二次型" class="headerlink" title="实二次型"></a>实二次型</h2><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p><strong>定义</strong>：$x = cy$（<del>宋浩说x一定写在前面，我觉得怎么不用</del>）</p>
<p>线性变换系数行列式为$|P| = \begin{vmatrix}<br>c_{11} &amp; c_{12} &amp; \cdots &amp;c_{1n}\\<br>x_{21} &amp; x_{22} &amp; \cdots &amp;x_{2n}\\<br>\vdots &amp; \vdots &amp;  &amp;\vdots\\<br>x_{n1} &amp; x_{n2}&amp; \cdots &amp;x_{nn}\\<br>\end{vmatrix}$</p>
<ul>
<li><p>如果$|P| \neq 0$，称为<strong>非异线性变换</strong>或<strong>非退化线性变换</strong></p>
</li>
<li><p>如果$|P| = 0$，称为<strong>奇异线性变换</strong>或<strong>退化线性变换</strong></p>
</li>
<li><p>如果P为正交矩阵，则称为<strong>正交变换</strong></p>
</li>
</ul>
<h3 id="合同"><a href="#合同" class="headerlink" title="合同"></a>合同</h3><p><strong>定义</strong>：同阶方阵A、B之间存在一个可逆矩阵P，使得$B = P^TA\:P$，那么称为A合同于B</p>
<ul>
<li>P称为<u>A到B的合同变换矩阵</u></li>
</ul>
<p><strong>合同关系是一个等价关系</strong></p>
<h3 id="二次型化简"><a href="#二次型化简" class="headerlink" title="二次型化简"></a>二次型化简</h3><p><strong>矩阵表示</strong>：$f(x_1,x_2,\cdots,x_n) = x^TA\:x$</p>
<ul>
<li>A是对称矩阵</li>
</ul>
<p><strong>定理</strong>：</p>
<ol>
<li><p>存在非退化的线性变换将实二次型化为标准形，且平方项系数可以任意次序排列</p>
</li>
<li><p>存在可逆矩阵将实对称矩阵合同变换为实对角矩阵，且对角元素可以任意次序排列</p>
</li>
</ol>
<p><strong>化简方法</strong>：</p>
<ul>
<li><p><strong>正交矩阵法</strong></p>
<ol>
<li><p>求解矩阵A的特征方程$|\lambda E-A| = 0$</p>
</li>
<li><p>求出基础解系</p>
</li>
<li><p>将标准正交化的特征向量作为列构成正交矩阵$P= \left(\begin{matrix}<br>p_{11} &amp; p_{12} &amp; p_{13}\\<br>p_{21} &amp; p_{22} &amp; p_{23}\\<br>p_{31} &amp; p_{32}&amp; p_{33}\\<br>\end{matrix}\right)$</p>
</li>
<li><p>得到线性变换$\begin{cases}<br>x_1 = p_{11}y_1 + p_{12}y_2 + p_{13}y_3\\<br>x_2 = p_{21}y_1 + p_{22}y_2 + p_{23}y_3\\<br>x_3 = p_{31}y_1 + p_{32}y_2 + p_{33}y_3<br>\end{cases}$</p>
</li>
</ol>
</li>
<li><p><strong>配方法</strong></p>
<ol>
<li><p><strong>式中有非零平方项比如$a_{11}x_1^2$</strong>：将式中所有含$x_1$的项配成一个平方项$a_{11}(x_{11} + \frac{a_12}{a_11}x_2 + \cdots + \frac{a_{1n}}{a11}x_n)^2$，并令非退化线性变换为$\begin{cases}<br>y_1 = x_1 + \frac{a_{12}}{a_{11}}x_2 + \cdots + \frac{a_{1n}}{a_{11}}x_n\\<br>y_2 = x_2\\<br>\cdots \cdots \\<br>y_n = x_n<br>\end{cases}$<br>即可把原式化为不含$x_1$和$y_1$的交叉项的式子</p>
</li>
<li><p><strong>式中无非零平方项</strong>：可以用一个线性变换配出平方项，例如$2a_{12}x_{1}x_{2}$，则作如下非退化线性变换<br>$\begin{cases}<br>x_1 = y_1 + y_2\\<br>x_2 = y_1 - y_2\\<br>x_3 = y_3 \\<br>\cdots \cdots \\<br>x_n = y_n<br>\end{cases}$，然后再按情况一处理</p>
</li>
</ol>
</li>
<li><p><strong>合同变换法</strong></p>
<ol>
<li><p>设二次型矩阵为$A = \left(\begin{matrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp;a_{1n}\\<br>a_{12} &amp; a_{22} &amp; \cdots &amp;a_{2n}\\<br>\vdots &amp; \vdots &amp;  &amp;\vdots\\<br>a_{n1} &amp; a_{n2}&amp; \cdots &amp;a_{nn}\\<br>\end{matrix}\right)$</p>
</li>
<li><p>对矩阵$B = \left(\begin{matrix}<br>A \\<br>E \\<br>\end{matrix}\right)$ <strong>做一次初等列变换后接着做一次对应的初等行变换</strong>，重复这种做法，直到得到$\left(\begin{matrix}<br>\Lambda \\<br>P \\<br>\end{matrix}\right)$，然后P的用法参考正交矩阵法</p>
</li>
</ol>
</li>
</ul>
<h3 id="二次型的规范形"><a href="#二次型的规范形" class="headerlink" title="二次型的规范形"></a>二次型的规范形</h3><p><strong>惯性定理</strong>：存在非退化的线性变换将实二次型化为实规范形 $z_1^2 + \cdots + z_p^2 - z_{p + 1}^2 - \cdots - z_r^2$ ；存在实可逆矩阵将实对称矩阵合同变换为 $diag(E_p,-E_{r-p},O_{n-r})$，其中r是二次型矩阵的秩</p>
<p><strong>推论</strong>：</p>
<ol>
<li><strong>实二次型矩阵A的正特征值个数为正惯性指数，负特征值个数为负惯性指数，非零特征值个数为二次型的秩</strong></li>
</ol>
<h3 id="正定二次型"><a href="#正定二次型" class="headerlink" title="正定二次型"></a>正定二次型</h3><p>若A为n阶是<strong>实对称</strong>矩阵，则下列条件互为等价：</p>
<ul>
<li><p>半正定等情况类似</p>
<ol>
<li><p><strong>A为正定矩阵</strong></p>
</li>
<li><p>A的特征值为正</p>
</li>
<li><p>A的正惯性指数为0</p>
</li>
<li><p><strong>A的各阶顺序主子式都为正</strong></p>
</li>
</ol>
</li>
</ul>
<h2 id="线性空间与线性变换"><a href="#线性空间与线性变换" class="headerlink" title="线性空间与线性变换"></a>线性空间与线性变换</h2><h3 id="数环"><a href="#数环" class="headerlink" title="数环"></a>数环</h3><p>属于集合 $R$ 的任意两个数的和、差、积仍属于 $R$，则称这个集合 $R$ 为数环</p>
<ul>
<li><strong>任何数环必有0</strong></li>
</ul>
<h3 id="数域"><a href="#数域" class="headerlink" title="数域"></a>数域</h3><p>若 $K$ 是<strong>至少含有两个互异数</strong>的数环，且其中任何两个数之商仍属于 $K$ ，则称这个集合 $K$ 为数域</p>
<ul>
<li><strong>任何数域必有0和1</strong></li>
</ul>
<h3 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h3><p>设 $V$ 是一个非空集合，$K$ 是一个属于，V满足以下两个条件：</p>
<ol>
<li><p>在 $V$ 中定义一个封闭的加法运算，即当 $x,y \in V$ 时，有唯一的 $z = x + y \in V$，且满足：</p>
<ul>
<li><p>$x + y = y + x$</p>
</li>
<li><p>$x + (y + z) = (x + y) + z$</p>
</li>
<li><p>存在<strong>零元素</strong> $0 \in V$，对 $V$ 中任意元素 $x$，都有 $x + 0 = x$</p>
</li>
<li><p>存在<strong>负元素</strong>：对任一元素 $x \in V$，存在一个元素 $y \in V$，使得 $x + y = 0$，称 $y$ 为 $x$ 的负元素，记为 $-x$，即 $x + (-x) = 0$</p>
</li>
</ul>
</li>
<li><p>在 $V$ 中定义一个封闭的数乘运算，即当 $x \in V,\lambda \in K$ 时，有唯一的 $\lambda x \in V$，且满足：</p>
<ul>
<li><p>$(\lambda + \mu)x = \lambda x + \mu x$</p>
</li>
<li><p>$\lambda(x + y) = \lambda x + \lambda y$</p>
</li>
<li><p>$\lambda(\mu x) = (\lambda \mu)x$</p>
</li>
<li><p>$1\cdot x = x$</p>
</li>
</ul>
</li>
</ol>
<p>我们称 $V$ 是属于 $K$ 上的线性空间，记作 $V(K)$</p>
<p>性质：</p>
<ol>
<li><p>线性空间的零元素是唯一的</p>
</li>
<li><p>线性空间中任一元素的负元是唯一的</p>
</li>
<li><p>设 $0,1,-1,\lambda \in K,x,-x,0 \in V$，则有：</p>
<ul>
<li><p>$0x = 0$</p>
</li>
<li><p>$(-1)x = -x$</p>
</li>
<li><p>$\lambda 0 = 0$</p>
</li>
<li><p>若 $\lambda x = 0$，则 $\lambda = 0$ 或 $x = 0$</p>
</li>
</ul>
</li>
</ol>
<p>只含一个元素的线性空间称为<strong>零空间</strong></p>
<ul>
<li>那个元素就是零元素</li>
</ul>
<h3 id="基与坐标"><a href="#基与坐标" class="headerlink" title="基与坐标"></a>基与坐标</h3><p>设 $V$ 是数域 $K$ 上的线性空间，</p>
<ol>
<li><p>如果在 $V$ 中可以找到任意多个线性无关的向量，则称 $V$ 是<strong>无限维线性空间</strong></p>
</li>
<li><p>如果存在有限多个向量 $a_1, a_2, \cdots, a_n \in V$，满足：</p>
<ol>
<li><p>$a_1, a_2, \cdots, a_n$ 线性无关</p>
</li>
<li><p>$V$ 中任一向量都可由 $a_1, a_2, \cdots, a_n$ 线性表示</p>
<p>则称 $V$ 是<strong>有限维线性空间</strong>，称 $a_1, a_2, \cdots, a_n$ 是V的一组<strong>基</strong>（<strong>基底</strong>），$a_i$ 叫第 $i$ 个<strong>基向量</strong>，基向量的个数 $n$ 称为线性空间的<strong>维数</strong>，记为 $dim(V) = n$，并称 $V$ 是 $n$ 维线性空间</p>
</li>
</ol>
</li>
</ol>
<p>定理：</p>
<ol>
<li><p><strong>设 $a_1, a_2, \cdots, a_n$ 是 $n$ 维线性空间 $V$ 的一组基，对任意 $a \in V$，$a$ 可以唯一地由这一组基线性表出</strong></p>
<p>设 $a_1, a_2, \cdots, a_n$ 是 $n$ 维线性空间 $V$ 的一组基，对任意 $a \in V$，若有一组有序数 $x_1,x_2,\cdots,x_n$ 使得 $a$可表示为 $a = x_1a_1 + x_2a_2 + \cdots + x_na_n$，这组有序数就称为向量 $a$ 在基 $a_1, a_2, \cdots, a_n$ 下的<strong>坐标</strong>，记为 $x = (x_1,x_2,\cdots,x_n)$ 或 $x = (x_1,x_2,\cdots,x_n)^T$</p>
</li>
</ol>
<h3 id="基变换和坐标变换"><a href="#基变换和坐标变换" class="headerlink" title="基变换和坐标变换"></a>基变换和坐标变换</h3><p>设 $\alpha_1, \alpha_2, \cdots, \alpha_n$ 和 $\beta_1,\beta_2,\cdots,\beta_n$ 是 $n$ 维线性空间 $V$ 的两组基，并且 $(\beta_1,\beta_2,\cdots,\beta_n) = (\alpha_1, \alpha_2, \cdots, \alpha_n)P$，若  $V$ 中任意元素 $\alpha$ 在这两组基下的坐标分别是 $(x_1,x_2,\cdots,x_n)$ 和 $(y_1,y_2,\cdots,y_n)$</p>
<ul>
<li>存在 $(y_1,y_2,\cdots,y_n)^T = P^{-1}(x_1,x_2,\cdots,x_n)^T$</li>
</ul>
<h3 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h3><p>线性空间 $V$ 的一个非空子集 $W$ 是 $V$ 的子空间的<strong>充要条件</strong>：</p>
<ol>
<li><p>对任意 $\alpha , \beta \in W$，有 $\alpha +\beta \in W$，即对<strong>加法封闭</strong></p>
</li>
<li><p>对任意 $\alpha  \in W,\lambda \in K$，有 $\lambda \alpha  \in W$，即对<strong>数乘封闭</strong></p>
</li>
</ol>
<p>线性空间 $V$ 的一个非空子集 $W$ 是 $V$ 的子空间的<strong>充要条件</strong>：</p>
<ol>
<li>对任意的 $\alpha , \beta \in W,\lambda,\mu \in K$，有 $\lambda \alpha +\mu \beta \in W$</li>
</ol>
<p>齐次方程组的全体解向量是 $R^n$ 的一个非空子集 $W$ ，<strong>则 $W$ 是 $R^n$ 的一个子空间</strong>，该齐次方程组的任一组基础解系是 $W$ 的一组基，<strong>若这个方程组系数矩阵的秩为 $r$ ，则 $dim(W) = n -r$</strong></p>
<ul>
<li>这个子空间称为齐次方程组的<strong>解空间</strong></li>
</ul>
<h3 id="子空间的交与和"><a href="#子空间的交与和" class="headerlink" title="子空间的交与和"></a>子空间的交与和</h3><ol>
<li><p>数域 $K$ 上线性空间 $V$ 的两个子空间 $W_1,W_2$的交与和仍是$V$ 的子空间</p>
</li>
<li><p><strong>若 $W_1,W_2$ 是线性空间 $V$ 的两个有限维子空间，则 $dim(W_1) + dim(W_2) = dim(W_1 + W_2) + dim(W_1 \cap W_2 )$</strong></p>
</li>
</ol>
<h3 id="子空间的直和"><a href="#子空间的直和" class="headerlink" title="子空间的直和"></a>子空间的直和</h3><p>若 $W_1 + W_2$ 中任一向量都只能<strong>唯一地表示</strong>为子空间 $W_1$ 的一个向量与子空间 $W_2$ 的一个向量和，则称 $W_1 + W_2$  是直和，记为 $W_1 \oplus W_2$</p>
<p>定理：</p>
<ol>
<li><p>$W_1 + W_2$ 是直和的<strong>充要条件</strong>：$W_1 \cap W_2 = \{0\}$</p>
</li>
<li><p>$W_1 + W_2$ 是直和的<strong>充要条件</strong>：$dim(W_1 + W_2) = dim(W_1) + dim(W_2)$</p>
</li>
</ol>
<p>若 $W_1,W_2,\cdots W_m$ 是线性空间 $V$ 的子空间，若</p>
<ul>
<li><p>$W_1 + W_2 +\cdots +W_m = V$</p>
</li>
<li><p>$W_1 \cap W_2 = \{0\},(W_1 + W_2) \cap W_3 = \{0\}, \cdots ,(W_1 + W_2 + \cdots + W_{m-1}) \cap W_m = \{0\}$</p>
</li>
</ul>
<p>则 $V$ 是 $W_1,W_2,\cdots W_m$ 的直和</p>
<h3 id="线性变换-1"><a href="#线性变换-1" class="headerlink" title="线性变换"></a>线性变换</h3><p>如果 $V_1$ 到 $V_2$ 的映射满足：$T(\lambda \alpha +\mu \beta) = \lambda T \alpha + \mu T \beta$，则称 $T$ 为 $V_1$ 到 $V_2$ 的<strong>线性映射</strong></p>
<ul>
<li><p>其中 $\alpha,\beta \in V_1,\lambda \in K$</p>
</li>
<li><p>在 $V_1 = V_2 = V$ 时，称这个 $T$ 为 $V$ 上的<strong>线性变换</strong></p>
</li>
</ul>
<p><strong>线性映射性质</strong>：</p>
<ol>
<li><p>$T0 = 0$</p>
</li>
<li><p>对任意的 $\alpha_1,\alpha_2,\cdots,\alpha_m \in V_1$，有 $T(K_1\alpha_1 + k_2\alpha_2 + \cdots k_m\alpha_m) = k_1T\alpha_1 + k_2T\alpha_2 + \cdots + k_mT\alpha_m$</p>
</li>
<li><p><strong>若 $\alpha_1,\alpha_2,\cdots,\alpha_m$ 线性相关，则 $T\alpha_1,T\alpha_2,\cdots,T\alpha_m$ 也线性相关</strong></p>
</li>
</ol>
<p>特殊的线性变换：</p>
<ul>
<li><p><strong>数乘变换</strong>：对任意 $\alpha \in V$，有 $T_k\alpha = k\alpha$</p>
</li>
<li><p><strong>恒等变换</strong>：$T\alpha = \alpha$</p>
</li>
<li><p><strong>零变换</strong>：$T\alpha = 0$</p>
</li>
</ul>
<h3 id="像空间和核空间"><a href="#像空间和核空间" class="headerlink" title="像空间和核空间"></a>像空间和核空间</h3><p>若 $V_1,V_2$ 都是数域 $K$ 上线性空间，有线性映射$T:V_1 \rightarrow V_2$</p>
<ul>
<li><p><strong>像空间</strong>：$V_1$ 中所有元素的像的集合</p>
</li>
<li><p><strong>核空间</strong>：集合 $N = N(T) = \{\alpha:T\alpha = 0,\alpha \in V_1\}$，记作 $ker(T)$</p>
</li>
</ul>
<p>定理：</p>
<ol>
<li><strong>线性映射的像空间和核空间是线性子空间</strong></li>
</ol>
<h3 id="线性变换的矩阵表示"><a href="#线性变换的矩阵表示" class="headerlink" title="线性变换的矩阵表示"></a>线性变换的矩阵表示</h3><p><strong>定义</strong>：</p>
<ol>
<li><p>设线性变换的矩阵为 $A$，则存在 $(T\varepsilon_1,T\varepsilon_2,\cdots,T\varepsilon_n) = (\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n)A$</p>
<ul>
<li><strong>$A$ 的第 $i$ 个列向量是 $T\varepsilon_i$ 在基 $\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n$ 下的坐标</strong></li>
</ul>
</li>
<li><p>设由基底 $\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n$ 到 $\omega_1,\omega_2,\cdots,\omega_n$ 的过度矩阵为 $P$，也就是 $(\omega_1,\omega_2,\cdots,\omega_n) = (\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n)P$，而且<strong>线性变换的矩阵分别为 $A,B$</strong>，那么有以下结论：</p>
<ul>
<li><p><strong>$B = P^{-1}AP$，可以看出 $P$ 必须可逆</strong></p>
</li>
<li><p>$A$ 相似于 $B$</p>
</li>
</ul>
</li>
</ol>
<p><strong>定理</strong>：</p>
<ol>
<li><p>对 $V$ 的两个线性变换 $T_1,T_2$，有 $T_1 \varepsilon_i = T_2\varepsilon_i$，则 $T_1 = T_2$</p>
</li>
<li><p>$A \sim B$ 的<strong>充要条件</strong>：<u>它们是 $n$ 维的线性空间 $V$ 上的某个线性变换 $T$ 在不同基底下的矩阵</u></p>
</li>
</ol>
<h3 id="线性变换的特征值和特征向量"><a href="#线性变换的特征值和特征向量" class="headerlink" title="线性变换的特征值和特征向量"></a>线性变换的特征值和特征向量</h3><p><strong>特征子空间</strong>：线性变换 $T$ 对应于特征值 $\lambda$ 的子空间 $V_{\lambda} = \{\xi \in V:T\xi = \lambda \xi\}$</p>
<ul>
<li>包括对应于 $\lambda$ 的所有特征向量和零向量</li>
</ul>
<p><strong>最简表示</strong>：线性变换 $T$ 在某组基上的矩阵为<strong>对角矩阵</strong></p>
<p>定理：</p>
<ol>
<li><p><strong>有限维线性空间上的线性变换的特征值和特征多项式与所选基底无关</strong></p>
</li>
<li><p>设 $\lambda_1,\lambda_2,\cdots,\lambda_s$ 是线性变换 $T$ 的 $s$ 个<strong>互异</strong>的特征值，$\xi_i$ 是属于特征值 $\lambda_i$ 的特征向量，则 $\xi_1,\xi_2,\cdots,\xi_s$ 线性无关</p>
</li>
<li><p>$n$ 维线性空间上的一个线性变换 $T$ 有最简表示的<strong>充要条件</strong>： $T$ 有 $n$ 个线性无关的特征向量</p>
<ul>
<li>$T$ 有 $n$ 个互异的特征值（<strong>充分条件</strong>）</li>
</ul>
</li>
<li><p>若 $\xi_1,\xi_2,\cdots,\xi_s$ 和 $\nu_1,\nu_1,\cdots,\nu_s$ 分别是线性变换 $T$ 不同特征值的<strong>线性无关</strong>的特征向量，则 $\xi_1,\xi_2,\cdots,\xi_s$；$\nu_1,\nu_1,\cdots,\nu_s$ 线性无关</p>
</li>
<li><p><strong>若 $\lambda_0$ 是线性变换 $T$ 的 $s$ 重特征值，则属于 $\lambda_0$ 的特征向量中，线性无关的最大组包含的向量个数不超过 $s$</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线代</tag>
      </tags>
  </entry>
  <entry>
    <title>外部存储器</title>
    <url>/2023/11/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>特性：</p>
<ul>
<li><p>用于<u>不经常使用的、数据量较大的信息</u></p>
</li>
<li><p>非易失性</p>
</li>
</ul>
<p>类型：</p>
<ul>
<li><p><strong>磁盘存储器</strong></p>
<ul>
<li><p>软盘floppy disk</p>
</li>
<li><p><strong>硬盘hard disk</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-1.png" alt=""></p>
</li>
</ul>
</li>
<li><p>光存储器</p>
</li>
<li><p>磁带</p>
</li>
<li><p>U盘</p>
</li>
<li><p>固态硬盘</p>
</li>
</ul>
<h2 id="硬磁盘存储器"><a href="#硬磁盘存储器" class="headerlink" title="硬磁盘存储器"></a>硬磁盘存储器</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>磁盘存储器<u>每个盘片表面有一个读写磁头</u>，所有磁头通过机械方式固定在一起，同时移动</p>
<ul>
<li>磁头<u>对盘片进行读写操作</u></li>
</ul>
<p><strong>在任何时候，所有磁头都位于距离磁盘中心等距离的轨道上</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-2.png" alt=""></p>
<ul>
<li><p>蓝色代表<strong>主轴</strong></p>
</li>
<li><p>红色代表<strong>磁盘</strong></p>
</li>
<li><p>绿色代表<strong>磁臂和磁头</strong></p>
</li>
</ul>
<h3 id="读写机制"><a href="#读写机制" class="headerlink" title="读写机制"></a>读写机制</h3><p>在读写操作期间，<strong>磁头静止</strong>，盘片在其下方进行旋转</p>
<ul>
<li><p>单磁头：读写共用</p>
</li>
<li><p>双磁头：使用一个单独的磁头进行读取</p>
</li>
</ul>
<h3 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h3><p>盘片上的数据组织呈现为一组同心圆环，称为<strong>磁道</strong></p>
<p>数据以<strong>扇区</strong>的形式传输到磁盘或传出</p>
<ul>
<li><strong>默认为512B</strong></li>
</ul>
<p>相邻磁道之间有<strong>间隙</strong>，相邻扇区之间也有</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-4.png" alt=""></p>
<p>所有盘片上处于<strong>相同的相对位置</strong>的一组磁道称为<strong>柱面</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-7.png" alt=""></p>
<p><strong>扇区划分</strong>：</p>
<ol>
<li><p><strong>恒定角速度</strong></p>
<p> 保持读写速度恒定，<u>能以磁道号和扇区号直接寻址各个数据块</u></p>
<p> <img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-5.png" alt=""></p>
</li>
<li><p><strong>多带式记录</strong></p>
<p> 将盘面划分为多个同心圆区域，每个区域中各磁道的扇区数量时相同的，<u>距离中心较远的分区包含的扇区数多于距离中心的分区</u><br> <img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt9/cpt9-6.png" alt=""></p>
</li>
</ol>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>磁道必须有一些起始点和辨别每个扇区起点和终点的方法</p>
<p>格式化时会附有一些<strong>仅被磁盘驱动器使用</strong>而不被用户存取的额外数据</p>
<h3 id="I-O访问时间"><a href="#I-O访问时间" class="headerlink" title="I/O访问时间"></a>I/O访问时间</h3><p><strong>寻道时间</strong>：磁头定位到所需移动到的磁道花费的时间</p>
<ul>
<li>初始启动时间，跨越若干磁道所用的时间</li>
</ul>
<p><strong>旋转延迟</strong>：等待响应扇区的起始处到达磁头所需的时间</p>
<ul>
<li>通常是<strong>磁道旋转半周的时间</strong></li>
</ul>
<p><strong>传送时间</strong>：数据传输所需的时间</p>
<ul>
<li>假设：T = 传送时间、b = 传送的字节数、N = 每磁道的字节数、r = 旋转速率(转/秒)，那么$T = \frac{b}{rN}$</li>
</ul>
<p><strong>平均访问时间</strong>：$T_a = T_s + \frac{1}{2r} + \frac{b}{rN}$</p>
<ul>
<li>$T_s$ 是平均寻道时间</li>
</ul>
<p>对于连续访问多个相邻磁道时，<strong>对于每个磁道都要考虑旋转延迟，通常只需要考虑第一个磁道的寻道时间</strong></p>
<ul>
<li>除非明确知道跨越一个磁道需要的时间</li>
</ul>
<h3 id="磁头寻道-磁盘调度"><a href="#磁头寻道-磁盘调度" class="headerlink" title="磁头寻道/磁盘调度"></a>磁头寻道/磁盘调度</h3><ol>
<li><p><strong>先来先服务FCFS</strong></p>
<p> 按照请求访问磁盘的先后次序进行处理</p>
</li>
<li><p><strong>最短寻道时间优先SSTF</strong></p>
<p> 优先处理起始位置与当前磁头位置最接近的读写任务</p>
<p> 可能会出现<strong>饥饿</strong>现象，尤其是位于两端的磁道请求</p>
</li>
<li><p><strong>扫描/电梯SCAN</strong></p>
<p> 总是按照一个方向进行磁盘调度，知道该方向上的边缘，然后改变方向</p>
</li>
<li><p><strong>循环扫描C-SCAN</strong></p>
<p> <strong>只有磁头朝某个方向移动时才会响应请求</strong>，移动到边缘后立即让磁头返回起点（<strong>0</strong>），返回途中不做任何处理</p>
<ul>
<li><strong>从N跳到0</strong></li>
</ul>
</li>
<li><p><strong>LOOK</strong></p>
<p> 只要磁头移动方向上不再有请求就立即改变磁头方向</p>
</li>
<li><p><strong>C-LOOK</strong></p>
<p> 只要在磁头移动方向上不再有请求，就立即让磁头返回起点（<strong>不是0</strong>）</p>
</li>
</ol>
<h2 id="光存储器"><a href="#光存储器" class="headerlink" title="光存储器"></a>光存储器</h2><p>比如<u>光盘(CD)、光盘只读存储器(CD-ROM)、可刻录光盘(CD-R)、可重写光盘(CD-RW)、数字多功能光盘(DVD)</u>等</p>
<h2 id="CD和CD-ROM"><a href="#CD和CD-ROM" class="headerlink" title="CD和CD-ROM"></a>CD和CD-ROM</h2><p>CD-ROM更加耐用且有纠错功能</p>
<p>通过安装在光盘播放器或启动装置内的低强度激光束从CD或CD-ROM读取信息</p>
<ul>
<li><p><strong>凹坑</strong>反射回<strong>低强度激光</strong></p>
</li>
<li><p><strong>台</strong>反射回<strong>高强度激光</strong></p>
</li>
</ul>
<p>盘片上包含一条<strong>单螺旋轨道</strong>，轨道上的所有扇区长度相同</p>
<p><strong>优点</strong>：廉价地大规模复制，可更换</p>
<p><strong>缺点</strong>：只读，存取时间长</p>
<h2 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h2><p>使用与磁盘类似的记录和读取技术</p>
<p>读取：<strong>顺序读取</strong></p>
<ul>
<li>磁盘是直接读取</li>
</ul>
<h2 id="U盘"><a href="#U盘" class="headerlink" title="U盘"></a>U盘</h2><p>采用了快闪存储器，属于<strong>非易失性半导体存储器</strong>，体积小容量大，携带方便</p>
<ul>
<li>固态硬盘容量更大，存储性能更好</li>
</ul>
<h2 id="冗余磁盘阵列RAID"><a href="#冗余磁盘阵列RAID" class="headerlink" title="冗余磁盘阵列RAID"></a>冗余磁盘阵列RAID</h2><p>将多个独立操作的磁盘按某种方式组织成磁盘阵列，以增加容量</p>
<ul>
<li>将数据存储在多个盘体上，通过这些盘并行工作来提高数据传输率</li>
</ul>
<p>采用<strong>数据冗余</strong>来进行错误恢复以提高系统可靠性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>级别</th>
<th>种类</th>
<th>描述</th>
<th>磁盘要求</th>
<th>数据可用性</th>
<th>大I/O数据传输能力</th>
<th>小I/O请求速率</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>条带化</td>
<td>非冗余</td>
<td><strong>N</strong></td>
<td>比单盘低</td>
<td>很高</td>
<td>读和写都很高</td>
</tr>
<tr>
<td>1</td>
<td>镜像</td>
<td>镜像</td>
<td><strong>2N</strong></td>
<td>比RAID 2、3、4、5高，比6低</td>
<td>读比单盘高，写和单盘类似</td>
<td>读高达单盘的两倍，写和单盘类似</td>
</tr>
<tr>
<td>2</td>
<td>并行存取</td>
<td><strong>海明码校验</strong></td>
<td><strong>N+m</strong></td>
<td>比单盘高很多，与RAID 3、4、5差不多</td>
<td>列表各级中最高</td>
<td>接近单盘的两倍</td>
</tr>
<tr>
<td>3</td>
<td>并行存取</td>
<td>位交错奇偶校验</td>
<td><strong>N+1</strong></td>
<td>比单盘高很多，与RAID 2、4、5差不多</td>
<td>列表各级中最高</td>
<td>接近单盘的两倍</td>
</tr>
<tr>
<td>4</td>
<td>独立存取</td>
<td>块交错奇偶校验</td>
<td><strong>N+1</strong></td>
<td>比单盘高很多，与RAID 2、3、5差不多</td>
<td>读和RAID 0类似，写低于单盘</td>
<td>读与RAID 0类似，写显著低于单盘</td>
</tr>
<tr>
<td>5</td>
<td>独立存取</td>
<td>块交错奇偶校验</td>
<td><strong>N+1</strong></td>
<td>比单盘高很多，与RAID 2、3、4差不多</td>
<td>读和RAID 0类似，写低于单盘</td>
<td>读与RAID 0类似，写显著低于单盘</td>
</tr>
<tr>
<td>6</td>
<td>独立存取</td>
<td>块交错奇偶校验</td>
<td><strong>N+2</strong></td>
<td>列表各级中最高</td>
<td>读和RAID 0类似，写比RAID 5低</td>
<td>读与RAID 0类似，写显著低于RAID 5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p>数据以条带的形式在可用的磁盘上分布</p>
<p><strong>不采用冗余来改善性能</strong></p>
<ul>
<li>不是RAID家族的真正成员</li>
</ul>
<p>用途：</p>
<ol>
<li><p>高数据传输率</p>
</li>
<li><p>高速响应I/O请求</p>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/2.png" alt=""></p>
<h3 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h3><p>采用数据条带，简单<strong>备份所有数据</strong>来实现冗余</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/4.png" alt=""></p>
<p>优点：</p>
<ol>
<li><p>高速响应I/O请求</p>
</li>
<li><p>读请求可以选择<strong>寻道时间较小的那个</strong></p>
</li>
<li><p>写请求可以并行完成，受限于写入较慢的磁盘</p>
</li>
</ol>
<ul>
<li>需要更新两个对应的条带</li>
</ul>
<ol>
<li>恢复受损磁盘简单</li>
</ol>
<p>用途：</p>
<p>只限于用在存储系统软件、数据和其他关键文件的驱动器中</p>
<h3 id="RAID-2"><a href="#RAID-2" class="headerlink" title="RAID 2"></a>RAID 2</h3><p>采用并行存取技术，所有磁盘都参与<strong>每个</strong>I/O请求的执行</p>
<p>纠错（<strong>海明码</strong>）：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/5.png" alt=""></p>
<ul>
<li>纠错能力强于RAID 2</li>
</ul>
<p>访问：</p>
<ul>
<li><p>读取：获取请求的数据和对应的校验码</p>
</li>
<li><p>写入：所有数据盘和校验盘都被访问</p>
</li>
</ul>
<h3 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h3><p>优点：</p>
<ul>
<li><p>能够获得非常高的数据传输率</p>
<ul>
<li>对于大量传送，性能改善特别明显</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>一次只能执行一个I/O请求</p>
<ul>
<li>面向多个I/O请求，性能将受损</li>
</ul>
</li>
</ul>
<h3 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID 4"></a>RAID 4</h3><p>采用独立存取技术，采用相对较大的数据条带，根据各个数据盘上的数据来逐位计算奇偶校验条带</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/7.png" alt=""></p>
<p>性能：</p>
<ul>
<li><p>当执行较小规模的I/O写请求时，RAID 4会遭遇写损失</p>
<ul>
<li>每一次写操作，不仅要修改用户数据，而且要<strong>修改对应的校验位</strong></li>
</ul>
</li>
</ul>
<h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p>与RAID 4组织方式相似，但<strong>在所有磁盘上都分布了奇偶校验条带</strong></p>
<ul>
<li>避免潜在的I/O瓶颈问题</li>
</ul>
<p>访问时需要<strong>两读两写</strong></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/8.png" alt=""></p>
<h3 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h3><p>采用两种不同的校验码，并将校验码以分开的块存于不同的磁盘中</p>
<p>优点：</p>
<ul>
<li>提升数据可用性</li>
</ul>
<p>缺点：</p>
<ul>
<li>写损失：<strong>每次都要影响到两个校验块</strong></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt11/9.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据表示及运算</title>
    <url>/2023/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h2><h3 id="信息的二进制编码"><a href="#信息的二进制编码" class="headerlink" title="信息的二进制编码"></a>信息的二进制编码</h3><ul>
<li><p><strong>自信息量</strong>：$I(x_i) = -log_2\:p(x_i)$</p>
</li>
<li><p><strong>系统的信息熵</strong>：$H(X) = E[I(X)] = -\sum_i p(x_i)log_2p(x_i)$</p>
</li>
</ul>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><strong>计算机中普遍使用补码</strong></p>
<p>补码无论同号还是异号都可以直接相加</p>
<ul>
<li>原码可能会出错</li>
</ul>
<p>负数的补码等于<u><strong>对应的正数各位取反末位加一</strong></u></p>
<script type="math/tex; mode=display">负数补码 = 模 - 负数绝对值</script><h3 id="浮点数二进制表示"><a href="#浮点数二进制表示" class="headerlink" title="浮点数二进制表示"></a>浮点数二进制表示</h3><p>科学计数法：$\pm S \times B^E$</p>
<ul>
<li>S：尾数</li>
<li>B：基底</li>
<li>E：阶码</li>
</ul>
<h4 id="规格化数"><a href="#规格化数" class="headerlink" title="规格化数"></a>规格化数</h4><div class="table-container">
<table>
<thead>
<tr>
<th>S</th>
<th>E</th>
<th>M</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>尾数（S）第一位总是1，不需要存于尾数字段</strong>（默认）</p>
<ul>
<li>23位原码表示24位尾数</li>
</ul>
</li>
<li><p>阶码（E）的真实值加偏移量后再存入阶码字段</p>
<ul>
<li><p>真实值 -127~128</p>
</li>
<li><p><strong>全0和全1表示特殊值</strong></p>
<ul>
<li>规格化数的阶码范围为<strong>0000 0001（-126） ~ 1111 1110（127）</strong> </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>规格化表示：</p>
<ul>
<li><p>$\pm 1.bbb…b \times 2^E$</p>
</li>
<li><p>$X = (-1)^S \times M \times 2^E$</p>
</li>
</ul>
<p><strong>规格化数的范围：（<del>重要难耐</del>）</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>最小整数</th>
<th>最大整数</th>
<th>最小负数</th>
<th>最大负数</th>
</tr>
</thead>
<tbody>
<tr>
<td>单精度</td>
<td>E = 1, M=0</td>
<td>E = 254, M = $1 - 2^{-23}$</td>
<td>E = 254, M = $1-2^{-23}$</td>
<td>E = 1, M = 0</td>
</tr>
<tr>
<td>真值</td>
<td>$1.0 \times 2^{-126}$</td>
<td>$(2-2^{-23}) \times 2^{127})$</td>
<td>$-(2-2^{-23}) \times 2^{127}$</td>
<td>$-1.0 \times 2^{-126}$</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt3/cpt3-6.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶码的值</th>
<th>尾数的值</th>
<th>表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>0（全0）</td>
<td>0</td>
<td>$\pm 0$</td>
</tr>
<tr>
<td>0（全0）</td>
<td>非0</td>
<td>非规格化数</td>
</tr>
<tr>
<td>1~254</td>
<td>任意</td>
<td>规格化数</td>
</tr>
<tr>
<td>255（全1）</td>
<td>0</td>
<td>$\pm \infty$</td>
</tr>
<tr>
<td>255（全1）</td>
<td>非0</td>
<td>NaN</td>
</tr>
</tbody>
</table>
</div>
<h4 id="非规格化数"><a href="#非规格化数" class="headerlink" title="非规格化数"></a>非规格化数</h4><p>用于处理规格化数中的下溢情况</p>
<p>$(-1)^S \times 0.bbb…b \times 2^{-126}$</p>
<h3 id="自然BCD码（NBCD-8421码）（随便看看得了）"><a href="#自然BCD码（NBCD-8421码）（随便看看得了）" class="headerlink" title="自然BCD码（NBCD,8421码）（随便看看得了）"></a>自然BCD码（NBCD,8421码）（<del>随便看看得了</del>）</h3><p>用四个二进制位表示每一个十进制数字</p>
<p>符号：四个最高有效位</p>
<ul>
<li>正：1100</li>
<li>负：1101</li>
</ul>
<h2 id="数据校验码"><a href="#数据校验码" class="headerlink" title="数据校验码"></a>数据校验码</h2><h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h3><p><strong>基本思想</strong>：<u>存储额外的信息以进行检错和校正</u></p>
<p><strong>处理过程</strong>：</p>
<ul>
<li><p>数据输入：使用函数f在M位数据D上生成K位校验码C</p>
</li>
<li><p>数据输出：使用函数f在M位数据$D’$上生成新的K位校验码$C’’$，并与取出的K位校验码$C’$进行比较</p>
<ul>
<li><p>没有检测到差错：使用数据$D’$</p>
</li>
<li><p>检测到差错并可以校正：校正数据$D’$来生成数据$D’’$，并用数据$D’’$</p>
</li>
<li><p>检测到差错但无法纠正：报告</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt10/1.png" alt=""></p>
<ul>
<li>一旦进入Memory，C和D就已经<strong>永远消失了</strong></li>
</ul>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>增加1位校验码在<u>数据最后面</u>来表示数据中的<strong>1的数量是奇数还是偶数</strong></p>
<p><strong>处理过程</strong>：</p>
<p>假设数据为$D = D_M \cdots D_2 D_1$ </p>
<ul>
<li><p><strong>数据输入</strong>  </p>
<ul>
<li><p>奇校验：$C = D_M \oplus \cdots D_2 \oplus D_1 \oplus 1$</p>
</li>
<li><p>偶校验：$C = D_M \oplus \cdots D_2 \oplus D_1$</p>
</li>
</ul>
</li>
<li><p><strong>数据输出</strong>  </p>
<ul>
<li><p>奇校验：$C’’ = D’_M \oplus \cdots D’_2 \oplus D’_1 \oplus 1$</p>
</li>
<li><p>偶校验：$C’’ = D’_M \oplus \cdots D’_2 \oplus D’_1$</p>
</li>
</ul>
</li>
<li><p><strong>检错</strong></p>
<p>  $S = C’’ \oplus C’$</p>
<ul>
<li><p>S = 0：正确/数据中出错的位数为偶数</p>
</li>
<li><p>S = 1：数据中出错的位数为奇数</p>
</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：代价低，只需要1位额外数据</p>
<p><strong>缺点</strong>：不能发现出错位数为偶数的情形，发现错误后无法校正</p>
<h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p>将数据分成几组，对每一组都使用奇偶校验码进行检错</p>
<p><strong>处理过程</strong>  ：</p>
<p>将𝑀位数据分成𝐾组  </p>
<ul>
<li><p><strong>数据输入</strong>：</p>
<ul>
<li>为数据𝐷中每组生成1位校验码，合并得到𝐾位校验码𝐶  </li>
</ul>
</li>
<li><p><strong>数据输出</strong>：</p>
<ul>
<li>为数据𝐷′中每组生成1位校验码，合并得到新的𝐾位校验码𝐶′′  </li>
</ul>
</li>
<li><p><strong>检错</strong>：将校验码𝐶′′和取出的校验码  C’ 按位进行异或，生成𝐾位<strong>故障字（syndrome word）</strong>  </p>
</li>
</ul>
<h4 id="检验码"><a href="#检验码" class="headerlink" title="检验码"></a>检验码</h4><p><strong>检验码的长度为 $2^K \geq M + K + 1$</strong>，使K成立的最小值就是校验码的位数</p>
<ul>
<li><p>数据中有1位出现错误：M</p>
</li>
<li><p>检验码中有1位出现错误：K</p>
</li>
<li><p>没有出现错误：1</p>
</li>
</ul>
<p>每一个检验位都放在二进制串中$2^n(n \in \mathbb{N})$的位置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>位置</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据位</td>
<td></td>
<td></td>
<td>$D_1$</td>
<td></td>
<td>$D_2$</td>
<td>$D_3$</td>
<td>$D_4$</td>
<td></td>
<td>$D_5$</td>
<td>$D_6$</td>
<td>$D_7$</td>
<td>$D_8$</td>
</tr>
<tr>
<td>校验位</td>
<td>$C_1$</td>
<td>$C_2$</td>
<td></td>
<td>$C_3$</td>
<td></td>
<td></td>
<td></td>
<td>$C_4$</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>检验位$C_i$负责检验二进制第 i 位为1的位置的检错</strong></p>
<ul>
<li><p>比如$C_1$负责0011、0101、0111 、1001$\cdots$，也就是第3、5、7、9 $\cdots$位</p>
</li>
<li><p>比如$C_2$负责0011、0110、0111、1010 $\cdots$，也就是第3、6、7、10$\cdots$位</p>
</li>
</ul>
</li>
<li><p>检验位$C_i$的值要根据选择的奇/偶校验来决定</p>
<ul>
<li><strong>所有负责的位进行异或</strong>（奇检验最后还要异或1）</li>
</ul>
</li>
</ul>
<h4 id="故障字"><a href="#故障字" class="headerlink" title="故障字"></a>故障字</h4><p>每种取值反映一种情形</p>
<ul>
<li><p>全0：没有检测到错误</p>
</li>
<li><p>有且仅有1位是1：错误发生在校验码中的某一位，不需要纠正</p>
</li>
<li><p>有多位为1：错误发生在数据中的某一位，<strong>将$D’$中对应数据位取反</strong>即可纠正</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>故障字</th>
<th>0001</th>
<th>0010</th>
<th>0011</th>
<th>0100</th>
<th>0101</th>
<th>0110</th>
<th>0111</th>
<th>1000</th>
<th>1001</th>
<th>1010</th>
<th>1011</th>
<th>1100</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据位</td>
<td></td>
<td></td>
<td>$D_1$</td>
<td></td>
<td>$D_2$</td>
<td>$D_3$</td>
<td>$D_4$</td>
<td></td>
<td>$D_5$</td>
<td>$D_6$</td>
<td>$D_7$</td>
<td>$D_8$</td>
</tr>
<tr>
<td>校验位</td>
<td>$C_1$</td>
<td>$C_2$</td>
<td></td>
<td>$C_3$</td>
<td></td>
<td></td>
<td></td>
<td>$C_4$</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h3 id="循环冗余检测"><a href="#循环冗余检测" class="headerlink" title="循环冗余检测"></a>循环冗余检测</h3><ul>
<li><strong>模2运算</strong>：进行加法和减法都不进位</li>
</ul>
<p><strong>循环冗余检测CRC计算</strong>：<u>假定数据M有k个比特，CRC运算就是在数据M后面添加供差错检测用的n位<strong>冗余码</strong>，然后构成一个帧发出去，一共发送(k + n)位</u></p>
<p><strong>n位冗余码获得方式</strong>：在M后面加上n个0，得到的(n + k)位的数初一事先商定的(n + 1)位除数P，得出商是Q而余数是R（n位），这个余数R就作为冗余码拼接在数据M后面发送出去,也就是<strong>发送(k + n)位的CRC码</strong></p>
<ul>
<li>这种冗余码称作<strong>帧检验序列FCS</strong>(Frame Check Sequence)</li>
</ul>
<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.VX98Rc7ifinwUBusCIfxwQAAAA?w=265&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="循环冗余检验 的图像结果"></p>
<p>接收端把收到的数据进行CRC检验：把收到的每一个帧除以相同的除数P（模2运算），然后检查得到的余数R</p>
<ul>
<li><p>R = 0则判定没有差错，接收</p>
</li>
<li><p>R $\ne$ 0则出现差错（<u>无法确定具体位置</u>）</p>
</li>
</ul>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>溢出表示：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt4/cpt4-6.png" alt=""></p>
<h4 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt4/cpt4-2.png" alt=""></p>
<ul>
<li><p>与门延迟：1ty ，或门延迟：2ty，异或门延迟：3ty</p>
</li>
<li><p>进位延迟：2ty，数据延迟：6ty</p>
</li>
</ul>
<h4 id="串行进位加法器"><a href="#串行进位加法器" class="headerlink" title="串行进位加法器"></a>串行进位加法器</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt4/cpt4-3.png" alt=""></p>
<ul>
<li><p>$S_n = 2 \times(n - 1) + 3 = 2n + 1$</p>
<ul>
<li><p>在等待C来的时候，已经提前把$X_i$和$Y_i$进行计算</p>
</li>
<li><p>n=1的时候，计算出来是3，而实际是6</p>
<ul>
<li>需要 $2 \times (n - 1) \geq 3$ 才行</li>
</ul>
</li>
<li><p>$S_1 = 6，S_2 = 6，S_3 = 7$，$S_1$和$S_2$是同时出来的，只要C过去了就行</p>
</li>
</ul>
</li>
</ul>
<h4 id="全先行进位加法器"><a href="#全先行进位加法器" class="headerlink" title="全先行进位加法器"></a>全先行进位加法器</h4><p>超前进位：</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt4/cpt4-4.png" alt=""></p>
<ul>
<li><p>所有的 $P_i$ 和 $G_i$ 都是可以同时计算的，代价是1ty</p>
</li>
<li><p>求出所有 $C_i$ 代价为2ty</p>
<ul>
<li>先计算所有的与，再计算所有的或</li>
</ul>
</li>
<li><p>求出所有的 $S_i$ 代价为3ty</p>
<ul>
<li><p><strong>异或只需要再做一次</strong>（有一次跟上面的时间重叠了）</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt4/1.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<h4 id="部分先行进位加法器"><a href="#部分先行进位加法器" class="headerlink" title="部分先行进位加法器"></a>部分先行进位加法器</h4><p>思路：<u>采用多个CLA并将其串联，取得计算时间和硬件复杂度之间的权衡</u></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt4/cpt4-5.png" alt=""></p>
<ul>
<li><p>最后算出的是最前面的加法部分</p>
</li>
<li><p>最左边是3 = 1 + 2</p>
</li>
<li><p>然后中间两个+2:之前P和G都算好了</p>
</li>
<li><p>最后一步5 = 2 + 3</p>
<ul>
<li>P和G已经算好了</li>
</ul>
</li>
<li><p>多一个加2</p>
</li>
</ul>
<h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>$X - Y = X + (-Y)$</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt4/cpt4-7.png" alt=""></p>
<ul>
<li><p>Sub是控制线，1为减法，0为加法</p>
<ul>
<li>Sub为1会走下面的路（<strong>取反</strong>）</li>
</ul>
</li>
<li><p>Sub另一端连接在CarryIn上面</p>
</li>
</ul>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><h4 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h4><p>所有数用原码表示</p>
<p>计算X + Y：</p>
<ol>
<li><p><strong>符号位单独计算</strong></p>
</li>
<li><p><strong>X和Y数值位的绝对值进行计算</strong></p>
</li>
</ol>
<p><img src="https://pic2.zhimg.com/v2-ccb27e6caf7b8ac185a91527cc5e27a1_r.jpg" alt=""></p>
<ul>
<li><p>根据Y低位决定ACC</p>
<ul>
<li><p><strong>低位为1则ACC加X，然后逻辑右移</strong></p>
</li>
<li><p><strong>低位为0则ACC不变，然后逻辑右移</strong></p>
</li>
</ul>
</li>
<li><p>进行n次计算（X和Y的位数为n）</p>
</li>
</ul>
<h4 id="布斯乘法（补码一位乘法）"><a href="#布斯乘法（补码一位乘法）" class="headerlink" title="布斯乘法（补码一位乘法）"></a>布斯乘法（补码一位乘法）</h4><p>所有数用补码表示</p>
<p>计算 X + Y：</p>
<ol>
<li><strong>乘数末尾补0</strong></li>
</ol>
<p><strong>这张图有问题，但是思想没问题</strong></p>
<ul>
<li>错误点是<u>第三次横移应该高位补1</u></li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt4/cpt4-13.png" alt=""></p>
<ul>
<li><p>根据乘数最低两位决定ACC</p>
<ul>
<li><p><strong>最低位- 倒二低位 = 1：加上X补码，然后算数右移</strong></p>
</li>
<li><p><strong>最低位- 倒二低位 = 0：不变，然后算术右移</strong></p>
</li>
<li><p><strong>最低位- 倒二低位 = -1：加上-X补码，然后算术右移</strong></p>
</li>
</ul>
</li>
<li><p>进行n次运算（X和Y的位数为n）</p>
</li>
</ul>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><h4 id="原码恢复余数法"><a href="#原码恢复余数法" class="headerlink" title="原码恢复余数法"></a>原码恢复余数法</h4><ol>
<li><p>所有数用原码表示</p>
</li>
<li><p><strong>符号位单独处理</strong></p>
</li>
<li><p><strong>数值位采用绝对值计算</strong></p>
</li>
</ol>
<p>计算X / Y</p>
<p><img src="https://cdn.acwing.com/media/article/image/2021/10/17/43346_473210542f-QQ%E6%88%AA%E5%9B%BE20211017160010.png" alt="计组学习笔记第三章运算方法与运算器3.6 - AcWing"></p>
<ul>
<li><p>根据$X + [-Y]_补$来计算</p>
<ul>
<li><p><strong>结果为负：上商0，加Y恢复余数，被除数和商左移一位</strong></p>
</li>
<li><p><strong>结果为非负：上商1，被除数和商左移一位</strong></p>
</li>
</ul>
</li>
<li><p>左移n次，上商n+1次（n为数值位）</p>
<ul>
<li>最后一次不用左移</li>
</ul>
</li>
</ul>
<h4 id="原码不恢复余数法"><a href="#原码不恢复余数法" class="headerlink" title="原码不恢复余数法"></a>原码不恢复余数法</h4><ol>
<li><p>所有数用原码表示</p>
</li>
<li><p><strong>符号位单独处理</strong></p>
</li>
<li><p><strong>数值位采用绝对值计算</strong></p>
</li>
</ol>
<p>计算X / Y</p>
<p><img src="https://cdn.acwing.com/media/article/image/2021/10/17/43346_d5a69c622f-QQ%E6%88%AA%E5%9B%BE20211017160416.png" alt="QQ截图20211017160416.png"></p>
<ul>
<li><p>根据$X + [-Y]_补$来计算</p>
<ul>
<li><p><strong>结果为负：上商0，余数左移一位，再加Y</strong></p>
</li>
<li><p><strong>结果为非负：上商1，余数左移一位，再减Y</strong></p>
</li>
</ul>
</li>
<li><p>左移n次，上商n+1次（n为数值位）</p>
<ul>
<li><p>最后一次不用左移</p>
</li>
<li><p>若最后一次余数为负，需要加Y得到正确的余数</p>
</li>
</ul>
</li>
</ul>
<h4 id="补码不恢复余数法"><a href="#补码不恢复余数法" class="headerlink" title="补码不恢复余数法"></a>补码不恢复余数法</h4><ol>
<li><p>所有数用补码表示</p>
</li>
<li><p><strong>符号位参与运算</strong></p>
<ul>
<li>拓展为双符号位</li>
</ul>
</li>
</ol>
<p>计算X / Y</p>
<ul>
<li><p>根据<strong>X和Y</strong>的符号来确定运算方式</p>
<ul>
<li><p>同号：$X - Y$</p>
</li>
<li><p>异号：$X + Y$</p>
</li>
</ul>
</li>
<li><p>根据<strong>余数和除数</strong>的符号来计算</p>
<ul>
<li><p><strong>同号：上商1，余数左移一位，然后再减Y</strong></p>
</li>
<li><p><strong>异号：上商0，余数左移一位，再加Y</strong></p>
</li>
</ul>
</li>
<li><p>左移n次，上商n+1次（n为数值位）</p>
<ul>
<li><strong>第n+1次上的商恒置为1</strong></li>
</ul>
</li>
</ul>
<h2 id="浮点数运算与表示"><a href="#浮点数运算与表示" class="headerlink" title="浮点数运算与表示"></a>浮点数运算与表示</h2><h3 id="加法和减法"><a href="#加法和减法" class="headerlink" title="加法和减法"></a>加法和减法</h3><p>必须保证两个操作数有相同的指数值</p>
<ul>
<li><p>$X_E \leq Y_E$</p>
<ul>
<li><p>$X+Y = (X_S \times B^{X_E - Y_E} + Y_S) \times B^{Y_E}$</p>
</li>
<li><p>$X-Y = (X_S \times B^{X_E - Y_E} - Y_S) \times B^{Y_E}$</p>
</li>
</ul>
</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>检查0</p>
</li>
<li><p>对齐有效值</p>
</li>
<li><p>加或减有效值</p>
</li>
<li><p>规格化结果</p>
</li>
</ol>
<h4 id="原码加法"><a href="#原码加法" class="headerlink" title="原码加法"></a>原码加法</h4><p>如果两个操作数有相同的符号，做加法；否则，做减法</p>
<ul>
<li><p><strong>做加法</strong>：直接相加</p>
<ul>
<li><p>如果最高位有进位，则溢出</p>
</li>
<li><p><strong>符号和被加数（被减数）相同</strong></p>
</li>
</ul>
</li>
<li><p><strong>做减法</strong>：加第二个操作数的补数</p>
<ul>
<li><p><strong>如果最高位有进位，正确</strong></p>
<ul>
<li><strong>符号与被减数相同</strong></li>
</ul>
</li>
<li><p><strong>否则，计算它的补码</strong></p>
<ul>
<li><strong>符号与被减数相反</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt6/cpt6-10.png" alt=""></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt6/cpt6-11.png" alt=""></p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt6/cpt6-12.png" alt=""></p>
<h3 id="乘法-1"><a href="#乘法-1" class="headerlink" title="乘法"></a>乘法</h3><ol>
<li><p>无论哪个操作数是0，乘积都为0</p>
</li>
<li><p><strong>从阶值的和中减去一个偏移量</strong></p>
<ul>
<li>其实是减去两个，但是最后表示出来要加一个</li>
</ul>
</li>
<li><p>有效值相乘</p>
</li>
<li><p>结果规格化和舍入</p>
<ul>
<li>规格化可能导致阶值下溢</li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt6/cpt6-14.png" alt=""></p>
<h3 id="除法-1"><a href="#除法-1" class="headerlink" title="除法"></a>除法</h3><ol>
<li><p>如果除数是0，则报告出错</p>
</li>
<li><p>如果被除数是0，则结果是0</p>
</li>
<li><p>被除数的阶值减除数的阶值，加上偏移量</p>
</li>
<li><p>有效值相除</p>
</li>
<li><p>结果规格化和舍入处理</p>
</li>
</ol>
<h3 id="精度考虑"><a href="#精度考虑" class="headerlink" title="精度考虑"></a>精度考虑</h3><p>寄存器的长度几乎总是大于有效值位长与一个隐含位之和，这些附加位称为<strong>保护位</strong></p>
<ul>
<li>保护位用0填充，用于扩充有效值的右端</li>
</ul>
<h4 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h4><ul>
<li><p><strong>四舍五入</strong>：结果被舍入成最近的可表示数</p>
<ul>
<li><p>最后四位：如果第一位是0，直接截去</p>
</li>
<li><p>最后四位：如果第一位是1，产生进位</p>
</li>
</ul>
</li>
<li><p><strong>朝$\pm\infty$舍入</strong>：结果朝无穷大的方向舍入</p>
</li>
<li><p><strong>朝0舍入</strong>：结果朝0舍入</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟存储器</title>
    <url>/2023/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如何将更多任务装入主存</p>
<ul>
<li><p>增大主存容量</p>
</li>
<li><p>使用交换技术、</p>
<ul>
<li><p>当主存中没有处于就绪的任务时，操作系统调入其他任务来执行</p>
</li>
<li><p><strong>分区和分页</strong></p>
</li>
</ul>
</li>
<li><p><strong>虚拟存储器</strong></p>
<ul>
<li><p><strong>请求分页</strong>：每次访问仅将当前需要的页面调入主存，而其他不活跃的页面放在外存磁盘上</p>
</li>
<li><p><strong>虚拟地址</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="分区方式"><a href="#分区方式" class="headerlink" title="分区方式"></a>分区方式</h3><p>主存分为两大区域：<u>系统区、用户区</u></p>
<ol>
<li><p><strong>简单固定分区</strong></p>
<p> 用户区划分成长度不等的<strong>固定长</strong>的分区，当一个任务调入主存时，分配一个可用的、能容纳它的、最小的分区</p>
<p> <img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/1.png" alt=""></p>
</li>
<li><p><strong>可变长分区</strong></p>
<p> 用户区按每个人物所需要的内存大小进行分配</p>
<ul>
<li><strong>时间越长，存储器中的碎片就会越多</strong><br><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/4.png" alt=""></li>
</ul>
</li>
</ol>
<h3 id="分页方式"><a href="#分页方式" class="headerlink" title="分页方式"></a>分页方式</h3><p>基本思想：</p>
<ul>
<li><p>把主存分成固定长且比较小的存储块，称为<strong>页框</strong>，每个任务也被划分成固定长的程序块，称为<strong>页</strong></p>
</li>
<li><p>将页装入页框上，且无需采用连续的页框来存放一个任务中所有的页</p>
</li>
</ul>
<p><strong>逻辑地址</strong>：指令中的地址</p>
<p><strong>物理地址</strong>：实际主存地址</p>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/2.png" alt=""></p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>基本思想：</p>
<ul>
<li><p><strong>请求分页</strong>：仅将当前需要的页面调入主存</p>
<ul>
<li><p>通过硬件将逻辑地址转换为物理地址</p>
</li>
<li><p>未命中时在主存和硬盘之间交换信息</p>
</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ol>
<li><p><strong>在不扩大物理内存的前提下，可以载入更多的任务</strong></p>
</li>
<li><p>编写程序时不需要考虑可用物理内存的状态</p>
</li>
<li><p>可以在大于物理内存的逻辑地址空间中编程</p>
</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li><p>先把程序加载到硬盘的特定区域，然后我们什么时候需要这个内存，移动到主存中去</p>
</li>
<li><p>存储是否被加载到物理内存中，如果被加载进物理内存，则是物理地址，如果没有在里面就在磁盘中</p>
<ul>
<li>满了可以使用替换策略进行替换</li>
</ul>
</li>
<li><p>内存中有的，硬盘中也是有的</p>
<ul>
<li><strong>拷贝关系</strong></li>
</ul>
</li>
</ol>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/3.png" alt=""></p>
<p><strong>页大小</strong>：4KB、8KB、$\cdots$\</p>
<p><strong>映射算法</strong>：全相联映射</p>
<p><strong>写策略</strong>：写回法</p>
<ul>
<li>被替换出来才修改硬盘中的数据</li>
</ul>
<p><strong>种类</strong>：</p>
<ul>
<li><p><strong>分页式虚拟存储器</strong></p>
</li>
<li><p>分段式虚拟存储器</p>
</li>
<li><p>段页式虚拟存储器</p>
</li>
</ul>
<h2 id="分页式虚拟存储器"><a href="#分页式虚拟存储器" class="headerlink" title="分页式虚拟存储器"></a>分页式虚拟存储器</h2><p><strong>主存储器和虚拟地址空间都被划分成大小相等的页面</strong></p>
<ul>
<li><p><strong>虚拟页/逻辑页</strong>：虚拟地址空间中的页面</p>
</li>
<li><p><strong>物理页/页框</strong>：主存空间中的页面</p>
</li>
</ul>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表中包含了<strong>所有虚拟页的信息</strong>，包括<u>虚拟页的存放位置、有效位（<strong>有无被加载到物理内存中</strong>）、修改位、存取权限位</u>等等</p>
<ul>
<li>保存在主存中</li>
</ul>
<p><strong>虚拟地址：<u>页号+页内偏移量</u></strong><br>|页号|页内偏移量|<br>|—|—|</p>
<p>根据页表中记录的物理页存放位置，可以将虚拟地址转化为物理地址</p>
<ul>
<li>虚拟页号 + 页内偏移量 $\rightarrow$ 物理页号 + 页内偏移量</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/8.png" alt=""></p>
<ul>
<li><p><strong>location没写</strong>：指向硬盘的指针</p>
</li>
<li><p><strong>loaction = null</strong>：表示磁盘里没有，而不是内存中没有</p>
</li>
<li><p><strong>虚拟页号比物理页号大一些</strong></p>
<ul>
<li>虚拟页号没必要存储，按照相应的物理页号位置来找虚拟页号的位置</li>
</ul>
</li>
</ul>
<p>如果location的长度是不同的，那么必须<strong>按照最长的部分等长存储</strong>，以免无法进行更换</p>
<h3 id="快表TLB"><a href="#快表TLB" class="headerlink" title="快表TLB"></a>快表TLB</h3><p>为了减少对内存的访问，我们将<strong>常用的页表的行</strong>放到Cache中去</p>
<ul>
<li><p>需要在前面加上个标记<strong>表示第几行</strong> </p>
</li>
<li><p>映射方式：<strong>全相联映射、组相联映射</strong></p>
</li>
<li><p>替换策略：<strong>随机替换</strong></p>
</li>
</ul>
<h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/9.png" alt=""></p>
<p>我们只要将虚拟页号根据页表转换到物理页号中去</p>
<ul>
<li><p>前提：<strong>在物理内存中</strong></p>
</li>
<li><p><strong>如果hit，直接传入物理地址；如果miss，到页表中去访问</strong></p>
<ul>
<li><p>这里的hit和miss发生在Cache中，因为TLB存放在Cache中</p>
</li>
<li><p>如果hit并且是invaild（无效）的情况下，我们用硬盘把页送到内存中去，<strong>然后到Cache正常访问</strong></p>
<ul>
<li>有效位是表示有无加载到物理内存中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果没在物理内存中的话，就是发生了<strong>缺页操作</strong>，于是对磁盘进行操作</p>
<ul>
<li>也就是invaild操作</li>
</ul>
<p><img src="https://spricoder.oss-cn-shanghai.aliyuncs.com/2019-COA19/img/cpt12/10.png" alt=""></p>
<h4 id="TLB、页表、Cache缺失组合"><a href="#TLB、页表、Cache缺失组合" class="headerlink" title="TLB、页表、Cache缺失组合"></a>TLB、页表、Cache缺失组合</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>TLB</th>
<th>页</th>
<th>Cache</th>
<th>可能性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>hit</td>
<td>hit</td>
<td>hit</td>
<td>可能</td>
<td>TLB命中则页一定命中，信息在主存里，就可能在Cache中</td>
</tr>
<tr>
<td>2</td>
<td>hit</td>
<td>hit</td>
<td>miss</td>
<td>可能</td>
<td>TLB命中则页一定命中，信息在主存里，可能不在Cache中</td>
</tr>
<tr>
<td>3</td>
<td>miss</td>
<td>hit</td>
<td>hit</td>
<td>可能</td>
<td>TLB缺失但页可能命中，信息在主存里，就可能在Cache中</td>
</tr>
<tr>
<td>4</td>
<td>miss</td>
<td>hit</td>
<td>miss</td>
<td>可能</td>
<td>TLB缺失但页可能命中，信息在主存里，但可能不在Cache中</td>
</tr>
<tr>
<td>5</td>
<td>miss</td>
<td>miss</td>
<td>miss</td>
<td>可能</td>
<td>TLB缺失，则页也可能缺失，信息不在主存，一定也不在Cache</td>
</tr>
<tr>
<td>6</td>
<td>hit</td>
<td>miss</td>
<td>miss</td>
<td>不可能</td>
<td>页缺失，说明信息不在主存，TLB一定没有该页表项</td>
</tr>
<tr>
<td>7</td>
<td>hit</td>
<td>miss</td>
<td>hit</td>
<td>不可能</td>
<td>页缺失，说明信息不在主存，TLB一定没有该页表项</td>
</tr>
<tr>
<td>8</td>
<td>miss</td>
<td>miss</td>
<td>hit</td>
<td>不可能</td>
<td>页缺失，说明信息不在主存，Cache一定没有该信息</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>Cache是内存的拷贝</p>
</li>
<li><p><strong>TLB miss的情况下只是比hit的情况多一次内存访问</strong></p>
</li>
</ul>
<p><strong>访问主存和硬盘次数</strong>：</p>
<ul>
<li><p><strong>无需访问主存</strong>：1</p>
</li>
<li><p><strong>访问一次主存</strong>：2、3</p>
</li>
<li><p><strong>访问两次主存</strong>：4</p>
</li>
<li><p><strong>访问2次主存，且访问硬盘</strong>：5</p>
</li>
</ul>
<h2 id="分段式虚拟存储器"><a href="#分段式虚拟存储器" class="headerlink" title="分段式虚拟存储器"></a>分段式虚拟存储器</h2><p>将程序和数据分成不同长度的段，将所需的段加载到主存中</p>
<p><strong>虚拟地址：段号 + 段内偏移量</strong></p>
<p><strong>优点</strong>：段的分解与程序的自然分解相对应，易于变易、管理、修改和保护</p>
<p><strong>缺点</strong>：段的长度不固定</p>
<h2 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h2><p>将程序和数据分段，段内再进行分页</p>
<ul>
<li>每个分段都有一个页表</li>
</ul>
<p><strong>虚拟地址：段号 + 页号 + 页内偏移量</strong></p>
<p><strong>优点</strong>：程序按段实现共享与保护</p>
<p><strong>缺点</strong>：需要多次查表</p>
]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统</title>
    <url>/2023/11/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87%E4%B8%8E%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="组织和结构"><a href="#组织和结构" class="headerlink" title="组织和结构"></a>组织和结构</h3><p><strong>组织</strong>：对编程人员<strong>不可见</strong></p>
<ul>
<li><p>操作单元及其相互连接</p>
</li>
<li><p>包括<u>控制信号、存储技术，…</u></p>
</li>
</ul>
<p><strong>结构</strong>：对编程人员<strong>可见</strong></p>
<ul>
<li><p>直接影响程序逻辑执行的属性</p>
</li>
<li><p>包括<u>指令集、表示数据类型的位数，…</u></p>
</li>
</ul>
<h3 id="计算机简史"><a href="#计算机简史" class="headerlink" title="计算机简史"></a>计算机简史</h3><ul>
<li><p>第一代：真空管</p>
<ul>
<li><strong>出现冯诺依曼模型</strong></li>
</ul>
</li>
<li><p>第二代：晶体管</p>
</li>
<li><p>第三代及后续几代：集成电路</p>
</li>
</ul>
<h3 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h3><p>基本原则：计算机由<strong>运算器、存储器、控制器、输入设备、输出设备</strong>组成，指令和数据均用二进制表示</p>
<p><strong>最重要的思想</strong>：存储程序</p>
<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.wBDk7wgoSrnl8owuevDsQQHaEs?rs=1&amp;pid=ImgDetMain" alt="01 | 冯·诺依曼体系结构：计算机组成的金字塔-CSDN博客"></p>
<ol>
<li><p><strong>主存储器</strong>：地址和存储内容</p>
</li>
<li><p><strong>算术逻辑单元</strong>：执行信息的实际处理</p>
</li>
<li><p><strong>程序控制单元</strong>：指挥信息的处理</p>
</li>
<li><p><strong>输入设备</strong>：将信息送入计算机中</p>
</li>
<li><p><strong>输出设备</strong>：将处理结果以某种形式显示在计算机外</p>
</li>
</ol>
<h3 id="摩尔定律"><a href="#摩尔定律" class="headerlink" title="摩尔定律"></a>摩尔定律</h3><p>单芯片上所能包含的晶体管数量每年翻一番 (1965-1969) / 1970<br>年起减慢为<strong>每18个月翻一番</strong></p>
<h3 id="CPU性能"><a href="#CPU性能" class="headerlink" title="CPU性能"></a>CPU性能</h3><h4 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h4><ul>
<li><p><strong>时钟频率</strong>（时钟速度）：<u>计算机在单位时间内执行最基本操作的次数</u>，单位Hz</p>
</li>
<li><p><strong>时钟周期</strong>（周期时间）：<u>执行每次最基本操作的时间</u>，单位s</p>
</li>
</ul>
<h4 id="指令执行"><a href="#指令执行" class="headerlink" title="指令执行"></a>指令执行</h4><p>处理器由时钟驱动，时钟具有固定的频率，或等价为<u.固定的时钟周期t</u></p>
<p><strong>CPI</strong>：<strong>每条计算机指令执行所需的时钟周期数</strong></p>
<ul>
<li><p>$CPI = \frac{\sum_{i = 1} ^{n}(CPI_i \times I_i)}{I_c}，I_c = \sum_{i = 1} ^ {n} I_i$</p>
<ul>
<li><p>$CPI_i$：<u>指定类型i所需要的周期数</u></p>
</li>
<li><p>$I_i$：<u>某一给定程序中所执行的i类指令的条数</u></p>
</li>
</ul>
</li>
</ul>
<p><strong>执行一个给定程序的处理时间是：</strong></p>
<ul>
<li>$T = I_c \times CPI \times t$</li>
</ul>
<p>每秒百万条指令（MIPS）:</p>
<ul>
<li>$MIPS = \frac{I_c}{T \times 10^6} = \frac{f}{CPI \times 10^6}$</li>
</ul>
<p>每秒百万条浮点操作（MFLOPS）：</p>
<ul>
<li>$MFLOPS = \frac{N_{floating-point\:op}}{T \times 10^6}$</li>
</ul>
<p><strong>平均结果</strong>：</p>
<ul>
<li><p><strong>算术平均值</strong>：$R_A = \frac{1}{m}\sum_{i = 1}^m R_i$</p>
</li>
<li><p><strong>调和平均值</strong>：$R_H = \frac{m}{\sum_{i = 1}^m \frac{1}{R_i}}$</p>
</li>
<li><p><strong>几何平均值</strong>：$R_G = (\prod_{i = 1}^n R_i)^{\frac{1}{n}}$</p>
</li>
</ul>
<h4 id="性能设计基本原则"><a href="#性能设计基本原则" class="headerlink" title="性能设计基本原则"></a>性能设计基本原则</h4><p><strong>大概率事件优先原则</strong>：对于大概率事件（或最常见的事件），赋予它优先的处理权和资源使用权</p>
<ul>
<li>$系统加速比 = \frac{总执行时间_{改进前}}{总执行时间_{改进后}}$</li>
</ul>
<p><strong>Amdahl定律</strong>：</p>
<ul>
<li><p>加快某部件执行速度所获得的系统性能加速比，受限于该部件在系统中所占的重要性比例</p>
</li>
<li><p><strong>性能增加的递减规则</strong>：如果仅仅对计算机中的<strong>一部分</strong>做性能改进，<u>改进越多，系统获得的效果越小</u>  </p>
<ul>
<li>$系统总加速比 = \frac{总执行时间_{改进前}}{总执行时间_{改进后}} = \frac{1}{(1 - 局部占比) + \frac{局部占比}{提升的性能}}$</li>
</ul>
</li>
</ul>
<h2 id="顶层视图"><a href="#顶层视图" class="headerlink" title="顶层视图"></a>顶层视图</h2><p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.RaXqRwYy3vA5Vf6y1GbrXAHaEi?rs=1&amp;pid=ImgDetMain" alt="COA-2019-第二章 A Top-Level View of Computer Function and Interconnection ..."></p>
<h3 id="计算机工作原理（感觉不是很重要）"><a href="#计算机工作原理（感觉不是很重要）" class="headerlink" title="计算机工作原理（感觉不是很重要）"></a>计算机工作原理（<del>感觉不是很重要</del>）</h3><ul>
<li><p>指令和数据存储在单个读写存储器中</p>
</li>
<li><p>主存中的内容按位置访问，无需考虑其中包含的类型</p>
</li>
<li><p>CPU从一条指令到下一条指令到下一条指令以顺序方式执行</p>
</li>
<li><p>I/O模块与CPU、贮存交换计算机系统外部的数据</p>
</li>
</ul>
<p><strong>CPU频率不能无限提高</strong>（<del>随便提一嘴</del>）：</p>
<ul>
<li><p>理论限制：</p>
<ol>
<li><p>mos管开关、脉冲通过门电路需要时间</p>
</li>
<li><p>为了信号同步、每个脉冲信号需要持续一定时间</p>
</li>
</ol>
</li>
<li><p>制造限制：</p>
<ol>
<li><p>芯片面积越来越大。导致连线延迟越来越大，需要保证信号在设计指定时钟周期内从芯片的一角到达另一角</p>
</li>
<li><p>频率越高会导致开关损耗也越高，CPU会费电和散热高</p>
</li>
</ol>
</li>
<li><p><strong>解决方法</strong>：</p>
<ol>
<li>改进CPU芯片结构</li>
</ol>
</li>
</ul>
<p><strong>主存和CPU之间传输数据的速度跟不上CPU的速度（内存墙）</strong>（<del>也是随便提一嘴</del>）</p>
<ul>
<li>采用高速缓存Cache</li>
</ul>
<p><strong>CPU在等待I/O设备时保持空闲</strong>（<del>还是随便提一嘴</del>）</p>
<ul>
<li>采用中断机制</li>
</ul>
<p><strong>层次式存储结构可以兼顾存储容量、速度和成本</strong>（<del>知道我要说什么吧</del>）</p>
<p>I/<strong>O设备传输速率差异大</strong>（<del>累了</del>）</p>
<ul>
<li>采用缓冲区和改进I/O操作技术</li>
</ul>
<p><strong>计算机部件互连复杂</strong>（<del>这个可以看看</del>）：</p>
<ul>
<li><p>采用总线</p>
<ul>
<li><p>控制线：<u>控制数据线和地址线的访问和使用</u></p>
</li>
<li><p>地址线：<u>指定数据总线和地址I/O端口上的数据的来源或去向</u></p>
</li>
<li><p>数据线：<u>在系统模块之间传送数据</u></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机组织与结构</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
</search>
